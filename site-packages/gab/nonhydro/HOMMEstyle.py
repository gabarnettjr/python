import numpy as np

###########################################################################

#prognostic variables:  u, w, theta, dpids, phi
#diagnostic variables:  P

# https://www.overleaf.com/read/jykswzpjrvyh

###########################################################################

def setGhostNodes( U \
, verticalRemap \
, Wa, Ws \
, TxBot, TzBot, NxBot, NzBot \
, TxTop, TzTop, NxTop, NzTop \
, wIbot, wEbot, wDbot \
, wItop, wEtop, wDtop \
, nLev, nCol, stc, backgroundStates \
, Po, g, Rd, Cv, Cp, zBot, zTop, z ) :
    
    #extrapolate uT to bottom ghost nodes:
    uT = U[0,1:stc+1,:] * TxBot + U[1,1:stc+1,:] * TzBot
    uT = wEbot.dot( uT )
    
    #get uN on bottom ghost nodes:
    uN = U[0,1:stc,:] * NxBot + U[1,1:stc,:] * NzBot
    uN = - wIbot[1:stc].dot( uN ) / wIbot[0]
    
    #use uT and uN to get (u,w) on bottom ghost nodes, then get (u,w) on top ghost nodes:
    U[0,0,:] = uT*TxBot[0,:] + uN*NxBot[0,:]
    U[1,0,:] = uT*TzBot[0,:] + uN*NzBot[0,:]
    U[0,-1,:] = wEtop.dot( U[0,-2:-stc-2:-1,:] )
    U[1,-1,:] = - wItop[1:stc].dot( U[1,-2:-stc-1:-1,:] ) / wItop[0]
    
    #get geopotential phi on bottom and top boundaries using Dirichlet BC:
    U[4,0,:]  = ( g*zBot - wIbot[1:stc].dot(U[4,1:stc,:]) ) / wIbot[0]
    U[4,-1,:] = ( g*zTop - wItop[1:stc].dot(U[4,-2:-stc-1:-1,:]) ) / wItop[0]
    
    # backgroundStatesTmp = backgroundStates
    backgroundStatesTmp = verticalRemap( backgroundStates, z, U[4,:,:]/g )
    thetaBar = backgroundStatesTmp[0,:,:]
    dpidsBar = backgroundStatesTmp[1,:,:]
    Pbar     = backgroundStatesTmp[2,:,:]
    
    #extrapolate theta to bottom and top ghost nodes:
    U[2,0,:] = wEbot.dot( U[2,1:stc+1,:] - thetaBar[1:stc+1,:] ) + thetaBar[0,:]
    U[2,-1,:] = wEtop.dot( U[2,-2:-stc-2:-1,:] - thetaBar[-2:-stc-2:-1,:] ) + thetaBar[-1,:]
    
    #extrapolate pseudo-density dpids to bottom and top ghost nodes:
    U[3,0,:] = wEbot.dot( U[3,1:stc+1,:] - dpidsBar[1:stc+1,:] ) + dpidsBar[0,:]
    U[3,-1,:] = wEtop.dot( U[3,-2:-stc-2:-1,:] - dpidsBar[-2:-stc-2:-1,:] ) + dpidsBar[-1,:]
    
    #get pressure using the equation of state:
    P = Po**(-Rd/Cv) * ( -Rd * U[2,:,:] * U[3,:,:] / Ws.dot(U[4,:,:]) ) ** (Cp/Cv) - Pbar
    
    #set pressure on bottom ghost nodes:
    dphids = wDbot.dot( U[4,0:stc,:] )
    dphida = wIbot.dot(U[4,0:stc,:]) @ Wa
    dPda = wIbot.dot(P[0:stc,:]) @ Wa
    dpids = wIbot.dot( U[3,0:stc,:] - dpidsBar[0:stc,:] )
    tmp = 1./(dphida**2.+g**2.) * ( g**2.*dpids + dphids*dphida*dPda )
    P[0,:] = ( tmp - wDbot[1:stc].dot(P[1:stc,:]) ) / wDbot[0]
    
    #set pressure on top ghost nodes:
    dpids = wItop.dot( U[3,-1:-stc-1:-1,:] - dpidsBar[-1:-stc-1:-1,:] )
    P[-1,:] = ( dpids - wDtop[1:stc].dot(P[-2:-stc-1:-1,:]) ) / wDtop[0]
    
    P = P + Pbar
    
    return U, P, backgroundStatesTmp

###########################################################################

#3D arrays U, P are given to this function with correct ghost node values.

def implicitPart( U, P \
, nLev, nCol ) :
    
    V = np.zeros(( 5, nLev, nCol ))
    
    return V

###########################################################################

#3D arrays U, P are given to this function with correct ghost node values.

def explicitPart( U, P, backgroundStatesTmp \
, Da, Ds, HV, verticalRemap \
, nLev, nCol, g, wIbot, wItop, stc, z ) :
    
    V = np.zeros(( 5, nLev, nCol ))
    
    u = U[0,1:-1,:]
    
    sDot = np.zeros(( nLev+2, nCol ))
    sDot[1:-1,:] = u * ( -Da(U[4,:,:]) / Ds(U[4,:,:]) ) \
    + U[1,1:-1,:] * ( g / Ds(U[4,:,:]) )
    sDot[0,:] = ( 0. - wIbot[1:stc].dot(sDot[1:stc,:]) ) / wIbot[0]
    sDot[-1,:] = ( 0. - wItop[1:stc].dot(sDot[-2:-stc-1:-1]) ) / wItop[0]
    
    thetaBar = backgroundStatesTmp[0,:,:]
    dpidsBar = backgroundStatesTmp[1,:,:]
    Pbar     = backgroundStatesTmp[2,:,:]
    
    V[0,:,:] = -u*Da(U[0,:,:]) - sDot[1:-1,:]*Ds(U[0,:,:]) \
    + Ds(U[4,:,:]) / U[3,1:-1,:] * Da(P) \
    - Ds(P) / U[3,1:-1,:] * Da(U[4,:,:]) \
    + HV( U[0,:,:] )
    
    V[1,:,:] = -u*Da(U[1,:,:]) - sDot[1:-1,:]*Ds(U[1,:,:]) \
    - g * ( U[3,1:-1,:]-dpidsBar[1:-1,:] - Ds(P-Pbar) ) / U[3,1:-1,:] \
    + HV( U[1,:,:] )
    
    V[2,:,:] = -u*Da(U[2,:,:]) - sDot[1:-1,:]*Ds(U[2,:,:]) \
    + HV( U[2,:,:] - thetaBar )
    
    V[3,:,:] = -Da( U[3,:,:] * U[0,:,:] ) - Ds( U[3,:,:] * sDot ) \
    + HV( U[3,:,:] - dpidsBar )
    
    V[4,:,:] = -u*Da(U[4,:,:]) - sDot[1:-1,:]*Ds(U[4,:,:]) \
    + g * U[1,1:-1,:]
    
    return V

###########################################################################
