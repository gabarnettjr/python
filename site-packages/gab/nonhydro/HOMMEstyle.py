import numpy as np

###########################################################################

#prognostic variables:  u, w, theta, dpids, phi
#diagnostic variables:  P

# https://www.overleaf.com/read/jykswzpjrvyh

###########################################################################

def quickBackgroundStates( testCase, x, z, dsdz \
, g, Cp, Cv, Rd, Po, backgroundStatesTmp ) :
    
    if testCase == "igw" :
        N = .01
        theta0 = 300.
        backgroundStatesTmp[0,:,:] = theta0 * np.exp( (N**2./g) * z )
        piBar = 1. + g**2. / Cp / theta0 / N**2. * ( np.exp(-N**2./g*z) - 1. )
        backgroundStatesTmp[1,:,:] = -g / Rd / backgroundStatesTmp[0,:,:] / dsdz(x,z) * Po * piBar**(Cv/Rd)
        backgroundStatesTmp[2,:,:] = Po * piBar ** (Cp/Rd)
        backgroundStatesTmp[3,:,:] = (N**2/g) * backgroundStatesTmp[0,:,:]
    elif testCase == "bubble" :
        backgroundStatesTmp[0,:,:] = 300.
        piBar = 1. - g / Cp / backgroundStatesTmp[0,:,:] * z
        backgroundStatesTmp[1,:,:] = -g / Rd / backgroundStatesTmp[0,:,:] / dsdz(x,z) * Po * piBar**(Cv/Rd)
        backgroundStatesTmp[2,:,:] = Po * piBar ** (Cp/Rd)
        backgroundStatesTmp[3,:,:] = 0.
        
    return backgroundStatesTmp          #thetaBar,dpidsBar,Pbar,dthetaBarDz

###########################################################################

def setGhostNodes( U \
, verticalRemap, dsdz, testCase \
, Wa, Ws \
, TxBot, TzBot, NxBot, NzBot \
, TxTop, TzTop, NxTop, NzTop \
, wIbot, wEbot, wDbot, wHbot \
, wItop, wEtop, wDtop, wHtop \
, dsdxBot, dsdzBot, dsdxTop, dsdzTop \
, nLev, nCol, stc, backgroundStates \
, Po, g, Rd, Cv, Cp, zBot, zTop, x, z, VL ) :
    
    #get geopotential phi on bottom and top boundaries using Dirichlet BC:
    U[4,0,:]  = ( 0. - wIbot[1:stc].dot(U[4,1:stc,:]-g*z[1:stc,:]) ) / wIbot[0] + g*z[0,:]
    U[4,-1,:] = ( 0. - wItop[1:stc].dot(U[4,-2:-stc-1:-1,:]-g*z[-2:-stc-1:-1,:]) ) / wItop[0] + g*z[-1,:]
    
    #get tangents and normals on bottom using geopotential phi:
    tmp = wDbot.dot(U[4,0:stc,:])
    NxBot = - Wa.dot(wIbot.dot(U[4,0:stc,:]).T).T / tmp
    NzBot = g / tmp
    tmp = np.sqrt( NxBot**2. + NzBot**2. )
    NxBot = NxBot / tmp
    NzBot = NzBot / tmp
    TxBot = np.tile( -NzBot, (stc,1) )
    TzBot = np.tile(  NxBot, (stc,1) )
    NxBot = np.tile( NxBot, (stc-1,1) )
    NzBot = np.tile( NzBot, (stc-1,1) )
    
    #get tangents and normals on top using geopotential phi:
    tmp = wDtop.dot(U[4,-1:-stc-1:-1,:])
    NxTop = - Wa.dot( wItop.dot(U[4,-1:-stc-1:-1,:]).T ).T / tmp
    NzTop = g / tmp
    tmp = np.sqrt( NxTop**2. + NzTop**2. )
    NxTop = NxTop / tmp
    NzTop = NzTop / tmp
    TxTop = np.tile( -NzTop, (stc,1) )
    TzTop = np.tile(  NxTop, (stc,1) )
    NxTop = np.tile( NxTop, (stc-1,1) )
    NzTop = np.tile( NzTop, (stc-1,1) )
    
    #extrapolate uT to bottom ghost nodes:
    uT = U[0,1:stc+1,:] * TxBot + U[1,1:stc+1,:] * TzBot
    uT = wEbot.dot( uT )
    
    #get uN on bottom ghost nodes:
    uN = U[0,1:stc,:] * NxBot + U[1,1:stc,:] * NzBot
    uN = - wIbot[1:stc].dot( uN ) / wIbot[0]
    
    #use uT and uN to get (u,w) on bottom ghost nodes:
    U[0,0,:] = uT*TxBot[0,:] + uN*NxBot[0,:]
    U[1,0,:] = uT*TzBot[0,:] + uN*NzBot[0,:]
    
    #extrapolate uT to top ghost nodes:
    uT = U[0,-2:-stc-2:-1,:] * TxTop + U[1,-2:-stc-2:-1,:] * TzTop
    uT = wEtop.dot( uT )
    
    #get uN on top ghost nodes:
    uN = U[0,-2:-stc-1:-1,:] * NxTop + U[1,-2:-stc-1:-1,:] * NzTop
    uN = - wItop[1:stc].dot( uN ) / wItop[0]
    
    #use uT and uN to get (u,w) on top ghost nodes:
    U[0,-1,:] = uT*TxTop[0,:] + uN*NxTop[0,:]
    U[1,-1,:] = uT*TzTop[0,:] + uN*NzTop[0,:]
    
    # #extrapolate u to bottom ghost nodes:
    # U[0,0,:] = wEbot.dot( U[0,1:stc+1,:] )
    
    # #extrapolate u to top ghost nodes:
    # U[0,-1,:] = wEtop.dot( U[0,-2:-stc-2:-1,:] )
    
    # #get w on bottom ghost nodes:
    # tmp = wHbot.dot(U[0,1:stc+1,:])/g \
    # * ( wIbot.dot(U[4,0:stc,:]) @ Wa )
    # U[1,0,:] = ( tmp - wIbot[1:stc].dot(U[1,1:stc,:]) ) / wIbot[0]
    
    # #get w on top ghost nodes:
    # tmp = wHtop.dot(U[0,-2:-stc-2:-1,:])/g \
    # * ( wItop.dot(U[4,-1:-stc-1:-1,:]) @ Wa )
    # U[1,-1,:] = ( tmp - wItop[1:stc].dot(U[1,-2:-stc-1:-1,:]) ) / wItop[0]
    
    if VL == 1 :
        backgroundStatesTmp = quickBackgroundStates( testCase, x, U[4,:,:]/g, dsdz \
        , g, Cp, Cv, Rd, Po, backgroundStates )
        # backgroundStatesTmp = verticalRemap( backgroundStates, g*z, U[4,:,:] )
    else :
        backgroundStatesTmp = backgroundStates
    
    thetaBar    = backgroundStatesTmp[0,:,:]
    dpidsBar    = backgroundStatesTmp[1,:,:]
    Pbar        = backgroundStatesTmp[2,:,:]
    
    #extrapolate theta to bottom and top ghost nodes:
    U[2,0,:] = wEbot.dot( U[2,1:stc+1,:] )
    U[2,-1,:] = wEtop.dot( U[2,-2:-stc-2:-1,:] )
    
    #extrapolate pseudo-density dpids to bottom and top ghost nodes:
    U[3,0,:] = wEbot.dot( U[3,1:stc+1,:] )
    U[3,-1,:] = wEtop.dot( U[3,-2:-stc-2:-1,:] )
    
    #get pressure perturbation on interior using the equation of state:
    P = np.zeros(( nLev+2, nCol ))
    P[1:-1,:] = ( -Rd/Po**(Rd/Cp) * (U[2,1:-1,:]+thetaBar[1:-1,:]) * (U[3,1:-1,:]+dpidsBar[1:-1,:]) \
    / (Ws[1:-1,:].dot(U[4,:,:])) ) ** (Cp/Cv) - Pbar[1:-1,:]
    
    #get pressure on bottom ghost nodes using phi-based boundary condition enforcement:
    dpidq = wHbot.dot( U[3,1:stc+1,:] )
    dPdb = Wa.dot(wHbot.dot(P[1:stc+1,:]).T).T
    dphidb = Wa.dot(wIbot.dot(U[4,0:stc,:]).T).T
    dphidq = wDbot.dot(U[4,0:stc,:]-g*z[0:stc,:]) + wDbot.dot(g*z[0:stc,:])
    tmp = 1. / ( dphidb**2. + g**2. ) * ( g**2.*dpidq + dphidb*dphidq*dPdb )
    P[0,:] = ( tmp - wDbot[1:stc].dot(P[1:stc,:]) ) / wDbot[0]
    
    #get pressure on top ghost nodes using phi-based boundary condition enforcement:
    dpidq = wHtop.dot( U[3,-2:-stc-2:-1,:] )
    dPdb = Wa.dot(wHtop.dot(P[-2:-stc-2:-1,:]).T).T
    dphidb = Wa.dot(wItop.dot(U[4,-1:-stc-1:-1,:]).T).T
    dphidq = wDtop.dot(U[4,-1:-stc-1:-1,:]-g*z[-1:-stc-1:-1,:]) + wDtop.dot(g*z[-1:-stc-1:-1,:])
    tmp = 1. / ( dphidb**2. + g**2. ) * ( g**2.*dpidq + dphidb*dphidq*dPdb )
    P[-1,:] = ( tmp - wDtop[1:stc].dot(P[-2:-stc-1:-1,:]) ) / wDtop[0]
    
    # #over-write pressure on bottom ghost nodes using Neumann BC:
    # dphidq = wDbot.dot( U[4,0:stc,:] )
    # dqds = g / dphidq / dsdzBot
    # dqda = ( - wIbot.dot(U[4,0:stc,:]) @ Wa ) / dphidq - g / dphidq * dsdxBot / dsdzBot
    # tmp = dsdzBot**2. * dqds * wIbot.dot(U[3,0:stc,:]-dpidsBar[0:stc,:]) \
    # - dsdxBot * ( wIbot.dot(P[0:stc,:]) @ Wa )
    # tmp = tmp / ( (dsdxBot**2.+dsdzBot**2.) * dqds + dsdxBot * dqda )
    # P[0,:] = ( tmp - wDbot[1:stc].dot(P[1:stc,:]) ) / wDbot[0]
    
    # #over-write pressure on top ghost nodes using Neumann BC:
    # dphidq = wDtop.dot( U[4,-1:-stc-1:-1,:] )
    # dqds = g / dphidq / dsdzTop
    # dqda = ( - wItop.dot(U[4,-1:-stc-1:-1,:]) @ Wa ) / dphidq - g / dphidq * dsdxTop / dsdzTop
    # tmp = dsdzTop**2. * dqds * wItop.dot(U[3,-1:-stc-1:-1,:]-dpidsBar[-1:-stc-1:-1,:]) \
    # - dsdxTop * ( wItop.dot(P[-1:-stc-1:-1,:]) @ Wa )
    # tmp = tmp / ( (dsdxTop**2.+dsdzTop**2.) * dqds + dsdxTop * dqda )
    # P[-1,:] = ( tmp - wDtop[1:stc].dot(P[-2:-stc-1:-1,:]) ) / wDtop[0]
    
    # P = P + Pbar
    
    return U, P, backgroundStatesTmp

###########################################################################

#3D arrays U, P are given to this function with correct ghost node values.

def implicitPart( U, P \
, nLev, nCol ) :
    
    V = np.zeros(( 5, nLev, nCol ))
    
    return V

###########################################################################

#3D arrays U, P are given to this function with correct ghost node values.

def explicitPart( U, P, backgroundStatesTmp \
, Da, Ds, HV, verticalRemap \
, nLev, nCol, g, wIbot, wItop, stc, z, VL ) :
    
    V = np.zeros(( 5, nLev, nCol ))
    
    u = U[0,1:-1,:]
    dphids = Ds( U[4,:,:] )
    
    sDot = np.zeros(( nLev+2, nCol ))
    if VL != 1 :
        sDot[1:-1,:] = u * ( -Da(U[4,:,:]) / dphids ) + U[1,1:-1,:] * ( g / dphids )
        sDot[0,:] = ( 0. - wIbot[1:stc].dot(sDot[1:stc,:]) ) / wIbot[0]
        sDot[-1,:] = ( 0. - wItop[1:stc].dot(sDot[-2:-stc-1:-1]) ) / wItop[0]
    
    thetaBar    = backgroundStatesTmp[0,:,:]
    dpidsBar    = backgroundStatesTmp[1,:,:]
    Pbar        = backgroundStatesTmp[2,:,:]
    dthetaBarDz = backgroundStatesTmp[3,:,:]
    
    V[0,:,:] = -u*Da(U[0,:,:]) - sDot[1:-1,:]*Ds(U[0,:,:]) \
    + dphids / (dpidsBar[1:-1,:]+U[3,1:-1,:]) * Da(P) \
    - Ds(P) / (dpidsBar[1:-1,:]+U[3,1:-1,:]) * Da(U[4,:,:]) \
    + HV( U[0,:,:] )
    
    V[1,:,:] = -u*Da(U[1,:,:]) - sDot[1:-1,:]*Ds(U[1,:,:]) \
    - g * ( U[3,1:-1,:] - Ds(P) ) / (dpidsBar[1:-1,:]+U[3,1:-1,:]) \
    + HV( U[1,:,:] )
    
    V[2,:,:] = -u*Da(U[2,:,:]) - sDot[1:-1,:]*Ds(U[2,:,:]) \
    - sDot[1:-1,:] * dphids/g * dthetaBarDz[1:-1,:]
    + HV( U[2,:,:] )
    
    V[3,:,:] = - Da( U[3,:,:] * U[0,:,:] ) - Ds( U[3,:,:] * sDot ) \
    - Da( dpidsBar * U[0,:,:] ) - Ds( dpidsBar * sDot )
    + HV( U[3,:,:] )
    
    V[4,:,:] = -u*Da(U[4,:,:]) - sDot[1:-1,:]*dphids \
    + g * U[1,1:-1,:] \
    + HV( U[4,:,:] )
    
    return V

###########################################################################
