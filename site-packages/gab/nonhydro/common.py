import sys
import numpy as np
# from scipy import spatial
# from scipy.sparse.linalg import gmres

sys.path.append('../../../site-packages')
from gab import phs1

###########################################################################

def constants() :

    Cp = 1004.               #specific heat of dry air at constant pressure
    Cv = 717.                  #specific heat dry of air at constant volume
    Rd = Cp - Cv                                  #gas constant for dry air
    g  = 9.81                                       #gravitational constant
    Po = 10.**5.                             #reference pressure in Pascals

    th0 = 300.                   #reference potential temperature in kelvin
    N   = .01        #Brunt-Vaisala frequency for inertia gravity wave case

    return Cp, Cv, Rd, g, Po, th0, N

###########################################################################

def domainParameters(testCase, refinementLevel, g, Cp, th0):
    """
    Get some test-specific parameters, such as the size of the domain, the
    horizontal node spacing dx, the number of vertical levels nLev, the
    time between saves saveDel, the topogrophy function zSurf(x), and the
    initial perturbation in potential temperature thetaPtb(x,z):
    """
    if testCase == "risingBubble":

        left    = -5000.
        right   = 5000.
        bottom  = 0.
        top     = 10000.
        dx      = 400. / 2**refinementLevel
        nLev    = 25 * 2**refinementLevel
        dt      = 1./2. / 2**refinementLevel
        tf      = 1200.
        saveDel = 100

        def zSurf(x):
            return 1000. * np.sin(2.*np.pi / 10000. * x)

        def thetaPtb(x, z):
            R = 1500.
            xc = 0.
            zc = 3000.
            r = np.sqrt((x-xc)**2 + (z-zc)**2)
            ind = r < R
            c0bubble = np.zeros(np.shape(x))
            c0bubble[ind] = 2. * ( 1. - r[ind]/R )
            return c0bubble
            # return 2. * np.exp(-1e-6*(x**2. + (z-4000.)**2.))

    elif testCase == "densityCurrent":

        left    = -25600.
        right   = 25600.
        bottom  = 0.
        top     = 6400.
        dx      = 400. / 2**refinementLevel
        nLev    = 16 * 2**refinementLevel
        dt      = 1./3. / 2**refinementLevel
        tf      = 900.
        saveDel = 50

        def zSurf(x):
            return np.zeros(np.shape(x))

        def thetaPtb(x, z):
            xc = 0.
            zc = 3000.
            xr = 4000.
            zr = 2000.
            rTilde = np.sqrt(((x-xc)/xr)**2 + ((z-zc)/zr)**2)
            Tptb = np.zeros(np.shape(x))
            ind = rTilde <= 1
            Tptb[ind] = -15./2. * (1. + np.cos(np.pi*rTilde[ind]))
            piBar = 1. - g / Cp / th0 * z
            return Tptb / piBar

    elif testCase == "inertiaGravityWaves":

        left    = -150000.
        right   = 150000.
        bottom  = 0.
        top     = 10000.
        dx      = 1000. / 2**refinementLevel
        nLev    = 10 * 2**refinementLevel
        dt      = 1. / 2**refinementLevel
        tf      = 3000.
        saveDel = 250

        def zSurf(x):
            return np.zeros(np.shape(x))

        def thetaPtb(x, z):
            thetaC = .01
            hC = 10000.
            aC = 5000.
            xC = -50000.
            return thetaC * np.sin(np.pi * z / hC) \
            / (1. + ((x - xC) / aC)**2.)

    elif testCase == "steadyState":

        left    = -5000.
        right   = 5000.
        bottom  = 0.
        top     = 10000.
        dx      = 1000. / 2**refinementLevel
        nLev    = 10 * 2**refinementLevel
        dt      = 1. / 2**refinementLevel
        tf      = 5000.
        saveDel = 500

        def zSurf(x):
            return 1000. * np.sin(2.*np.pi / 10000. * x)

        def thetaPtb(x, z):
            return np.zeros(np.shape(x))

    else:

        raise ValueError("Invalid test case string.  Please choose " \
        + "'risingBubble', 'densityCurrent', 'inertiaGravityWaves', " \
        + "or 'steadyState'.")

    return left, right, bottom, top, dx, nLev, dt, tf, saveDel \
    , zSurf, thetaPtb

###########################################################################

def hydrostaticProfiles(testCase, th0, g, Cp, N, e, null):
    """
    All of the test cases are defined in terms of hydrostatic background
    states for potential temperature (th) and Exner pressure (pi), and
    these are functions of z only.  In the pressure coordinate case, the
    initial z-levels are defined using the inverse Exner pressure function.
    """
    if (testCase == "risingBubble") or (testCase == "densityCurrent"):
        
        def potentialTemperature(z, e, null):
            return th0 * e
        
        def potentialTemperatureDerivative(z, e, null):
            return null
        
        def exnerPressure(z, e, null):
            return 1. - g/Cp/th0 * z
        
        def inverseExnerPressure(pi):
            return (1. - pi) * Cp*th0/g
        
    elif testCase == "inertiaGravityWaves":
        
        def potentialTemperature(z, e, null):
            return th0 * np.exp(N**2/g * z)
        
        def potentialTemperatureDerivative(z, e, null):
            return th0 * N**2/g * np.exp(N**2/g * z)
        
        def exnerPressure(z, e, null):
            return 1. + g**2/Cp/th0/N**2 * (np.exp(-N**2/g*z) - 1.)
        
        def inverseExnerPressure(pi):
            return -g/N**2. * np.log(1. + (pi-1.) * Cp*th0*N**2/g**2.)

    elif testCase == "steadyState":
        
        def potentialTemperature(z, e, null):
            return th0 * np.exp(N**2/g * z)

        def potentialTemperatureDerivative(z, e, null):
            return th0 * N**2/g * np.exp(N**2/g * z)

        def exnerPressure(z, e, null):
            return 1. + g**2/Cp/th0/N**2 * (np.exp(-N**2/g*z) - 1.)

        def inverseExnerPressure(pi):
            return -g/N**2. * np.log(1. + (pi-1.) * Cp*th0*N**2/g**2.)

    else:
        
        raise ValueError("Invalid test case string.  Please choose " \
        + "'risingBubble', 'densityCurrent', 'inertiaGravityWaves', " \
        + "or 'steadyState'.")

    return potentialTemperature, potentialTemperatureDerivative \
    , exnerPressure, inverseExnerPressure

###########################################################################

def derivativeApproximations(x, dx, left, right, s, ds):
    """
    This is where all of the weights for approximating spatial derivatives
    are calculated.  Also, at the end, the function outputs functions
    Da(), Ds(), and HV(), which are used to approximate the corresponding
    derivative of something.
    """
    phs = 11                             #lateral PHS exponent (odd number)
    pol = 5                     #highest degree polynomial in lateral basis
    stc = 11                                          #lateral stencil size
    alp = 2.**-9 * 300.                    #lateral dissipation coefficient
    Wa   = phs1.getPeriodicDM(z=x, x=x, m=1 \
    , phs=phs, pol=pol, stc=stc, period=right-left)           #d/da weights
    Whva = phs1.getPeriodicDM(z=x, x=x, m=6 \
    , phs=phs, pol=pol, stc=stc, period=right-left)
    Whva = alp * dx**5 * Whva                  #lateral dissipation weights
    
    phs = 5                                          #vertical PHS exponent
    pol = 2                    #highest degree polynomial in vertical basis
    stc = 5                                          #vertical stencil size
    alp = -2.**-20. * 300.                #vertical dissipation coefficient
    Ws   = phs1.getDM(z=s,       x=s, m=1 \
    , phs=phs, pol=pol, stc=stc)                              #d/ds weights
    Whvs = phs1.getDM(z=s[1:-1], x=s, m=4 \
    , phs=phs, pol=pol, stc=stc)
    Whvs = alp * ds**3 * Whvs                 #vertical dissipation weights
    
    sTop = (s[0] + s[1]) / 2.

    wItop = phs1.getWeights(z=sTop,  x=s[0:stc],        m=0 \
    , phs=phs, pol=pol)                        #interpolate to top boundary

    wEtop = phs1.getWeights(z=s[0],  x=s[1:stc+1],      m=0 \
    , phs=phs, pol=pol)                     #extrapolate to top ghost nodes

    wDtop = phs1.getWeights(z=sTop,  x=s[0:stc],        m=1 \
    , phs=phs, pol=pol)                         #derivative on top boundary

    wHtop = phs1.getWeights(z=sTop,  x=s[1:stc+1],      m=0 \
    , phs=phs, pol=pol)                        #extrapolate to top boundary
    
    wIbot = phs1.getWeights(z=1.,    x=s[-1:-1-stc:-1], m=0 \
    , phs=phs, pol=pol)                     #interpolate to bottom boundary

    wEbot = phs1.getWeights(z=s[-1], x=s[-2:-2-stc:-1], m=0 \
    , phs=phs, pol=pol)                  #extrapolate to bottom ghost nodes

    wDbot = phs1.getWeights(z=1.,    x=s[-1:-1-stc:-1], m=1 \
    , phs=phs, pol=pol)                      #derivative on bottom boundary

    wHbot = phs1.getWeights(z=1.,    x=s[-2:-2-stc:-1], m=0 \
    , phs=phs, pol=pol)                     #extrapolate to bottom boundary
    
    #Lateral derivative on all levels:
    def Da(U):
        return Wa.dot(U.T).T
    
    #Vertical first derivative on all levels:
    def Ds(U):
        return Ws.dot(U)
    
    #Total dissipation on non-ghost levels:
    def HV(U):
        return Whva.dot(U[1:-1,:].T).T + Whvs.dot(U)

    return Wa, stc, wItop, wEtop, wDtop, wHtop, wIbot, wEbot, wDbot, wHbot \
    , Da, Ds, HV

###########################################################################

def tangentsAndNormals(zSurfPrime, stc):
    """
    Unit tangent and unit normal vectors along bottom and top boundaries.
    """
    nCol = len(zSurfPrime)
    
    TzBot = zSurfPrime
    TxBot = np.ones((nCol))
    tmp = np.sqrt(TxBot**2 + TzBot**2)
    TxBot = TxBot / tmp              #x-component of unit tangent on bottom
    TzBot = TzBot / tmp              #z-component of unit tangent on bottom
    
    NxBot = np.tile(-TzBot, (stc-1,1))#x-component of unit normal on bottom
    NzBot = np.tile(TxBot, (stc-1,1)) #z-component of unit normal on bottom
    """
    Tile the tangent and normal vectors vertically according to the
    stencil size, so that they can be more effectively used inside the
    setGhostNodes() function below.  Inside this function, the tangent
    velocity will be extrapolated to the ghost nodes, while the normal
    velocity will be found by forcing the boundary value to be zero
    (no-flux boundary condition):
    """
    TxBot = np.tile(TxBot, (stc,1))
    TzBot = np.tile(TzBot, (stc,1))
    
    NxTop = np.zeros((stc-1, nCol))
    NzTop = np.ones((stc-1, nCol))
    
    TxTop = np.ones((stc, nCol))
    TzTop = np.zeros((stc, nCol))

    return TxBot, TzBot, NxBot, NzBot \
    , TxTop, TzTop, NxTop, NzTop

###########################################################################

def verticalRemap(U, z, Z, V):          #used only in vertically Lagrangian
    """
    Interpolate columns of 3D array U from z to Z using quadratics
    nLev is the number of interior levels of U
    z and Z are 2D arrays such that each row is a new z-level
    V is the output array
    """
    nLev = np.shape(z)[0] - 2

    z = np.tile(z, (np.shape(U)[0], 1, 1))
    Z = np.tile(Z, (np.shape(U)[0], 1, 1))

    #quadratic on bottom:
    z0 = z[:,0,:]                                               #first node
    z1 = z[:,1,:]                                              #second node
    z2 = z[:,2,:]                                               #third node
    ZZ = Z[:,0,:]                                         #evaluation point
    V[:,0,:] = \
      (ZZ - z1) * (ZZ - z2) * U[:,0,:] / (z0 - z1) / (z0 - z2) \
    + (ZZ - z0) * (ZZ - z2) * U[:,1,:] / (z1 - z0) / (z1 - z2) \
    + (ZZ - z0) * (ZZ - z1) * U[:,2,:] / (z2 - z0) / (z2 - z1)

    #quadratic on interior:
    z0 = z[:,0:nLev+0,:]
    z1 = z[:,1:nLev+1,:]
    z2 = z[:,2:nLev+2,:]
    ZZ = Z[:,1:nLev+1,:]
    V[:,1:nLev+1,:] = \
      (ZZ - z1) * (ZZ - z2) * U[:,0:nLev+0,:] / (z0 - z1) / (z0 - z2) \
    + (ZZ - z0) * (ZZ - z2) * U[:,1:nLev+1,:] / (z1 - z0) / (z1 - z2) \
    + (ZZ - z0) * (ZZ - z1) * U[:,2:nLev+2,:] / (z2 - z0) / (z2 - z1)

    #quadratic on top:
    z0 = z[:,nLev-1,:]
    z1 = z[:,nLev+0,:]
    z2 = z[:,nLev+1,:]
    ZZ = Z[:,nLev+1,:]
    V[:,nLev+1,:] = \
      (ZZ - z1) * (ZZ - z2) * U[:,nLev-1,:] / (z0 - z1) / (z0 - z2) \
    + (ZZ - z0) * (ZZ - z2) * U[:,nLev+0,:] / (z1 - z0) / (z1 - z2) \
    + (ZZ - z0) * (ZZ - z1) * U[:,nLev+1,:] / (z2 - z0) / (z2 - z1)

    return V

###########################################################################

def printMinAndMax(t, et, U, phiBar):
    
    print("t = {0:5d},  et = {1:6.2f},  MIN:  u = {2:+.2e},  \
w = {3:+.2e},  T = {4:+.2e},  rho = {5:+.2e},  \
phi = {6:+.2e},  P = {7:+.2e}" \
    . format(np.int(np.round(t)) \
    , et \
    , np.min(U[0,:,:]) \
    , np.min(U[1,:,:]) \
    , np.min(U[2,:,:]) \
    , np.min(U[3,:,:]) \
    , np.min(U[4,:,:]-phiBar) \
    , np.min(U[5,:,:])))

    print("                          MAX:  u = {0:+.2e},  \
w = {1:+.2e},  T = {2:+.2e},  rho = {3:+.2e},  \
phi = {4:+.2e},  P = {5:+.2e}\n" \
    . format(np.max(U[0,:,:]) \
    , np.max(U[1,:,:]) \
    , np.max(U[2,:,:]) \
    , np.max(U[3,:,:]) \
    , np.max(U[4,:,:]-phiBar) \
    , np.max(U[5,:,:])))

###########################################################################


































###########################################################################

# #Scale-preserving and terrain-following height coordinate transformation.
# #zBottom is assumed to be zero, and zTop is a positive length in meters.
# #zSurf and zSurfPrime are functions of x.
# #s, dsdx, and dsdz are functions of original variables xTilde and zTilde.
# 
# def getHeightCoordinate( zTop, zSurf, zSurfPrime ) :
#     
#     def s( xTilde, zTilde ) :
#         return ( zTilde - zSurf(xTilde) ) / ( zTop - zSurf(xTilde) ) * zTop
#     
#     def dsdx( xTilde, zTilde ) :
#         return ( zTilde - zTop ) * zSurfPrime(xTilde) \
#         / ( zTop - zSurf(xTilde) )**2. * zTop
#     
#     def dsdz( xTilde, zTilde ) :
#         return zTop / ( zTop - zSurf(xTilde) )
#     
#     return s, dsdx, dsdz

###########################################################################

# def getInitialConditions( testCase, formulation \
# , x, z \
# , Cp, Cv, Rd, g, Po \
# , dsdz ) :
#     
#     if formulation == "HOMMEstyle" :
#         U = np.zeros(( 5, np.shape(x)[0], np.shape(x)[1] ))
#     else :
#         U = np.zeros(( 4, np.shape(x)[0], np.shape(x)[1] ))
#     
#     if testCase == "bubble" :
#         thetaBar = 300. * np.ones( np.shape(x) )
#         piBar    = 1. - g / Cp / thetaBar * z
#         R = 1500.
#         xc = 5000.
#         zc = 3000.
#         r = np.sqrt( (x-xc)**2 + (z-zc)**2 )
#         ind = r < R
#         thetaPrime0 = np.zeros( np.shape(x) )
#         thetaPrime0[ind] = 2. * ( 1. - r[ind]/R )
#         piPrime0 = 0.
#         # U[0,:,:] = 20. * np.ones( np.shape(x) )
#         U[0,:,:] = np.zeros( np.shape(x) )
#         dthetaBarDz = np.zeros( np.shape(x) )
#     elif testCase == "igw" :
#         N = .01
#         theta0 = 300.
#         thetaBar = theta0 * np.exp( (N**2/g) * z )
#         piBar = 1. + g**2. / Cp / theta0 / N**2. * ( np.exp(-N**2./g*z) - 1. )
#         thetaC = .01
#         hC = 10000.
#         aC = 5000.
#         xC = 100000.
#         thetaPrime0 = thetaC * np.sin( np.pi*z/hC ) / ( 1. + ((x-xC)/aC)**2 )
#         piPrime0 = 0.
#         U[0,:,:] = 20. * np.ones( np.shape(x) )
#         dthetaBarDz = (N**2/g) * thetaBar
#     elif testCase == "densityCurrent" :
#         thetaBar = 300. * np.ones( np.shape(x) )
#         piBar = 1. - g / Cp / thetaBar * z
#         xc = 0.
#         zc = 3000.
#         xr = 4000.
#         zr = 2000.
#         rTilde = np.sqrt( ((x-xc)/xr)**2 + ((z-zc)/zr)**2 )
#         Tprime0 = np.zeros( np.shape(x) )
#         ind = rTilde <= 1
#         Tprime0[ind] = -15./2. * ( 1. + np.cos(np.pi*rTilde[ind]) )
#         thetaPrime0 = Tprime0 / piBar
#         piPrime0 = 0.
#         U[0,:,:] = np.zeros( np.shape(x) )
#         dthetaBarDz = np.zeros( np.shape(x) )
#     elif testCase == "doubleDensityCurrent" :
#         thetaBar = 300. * np.ones( np.shape(x) )
#         piBar = 1. - g / Cp / thetaBar * z
#         xc1 = -6400.
#         xc2 = 6400.
#         zc = 3000.
#         xr = 4000.
#         zr = 2000.
#         rTilde1 = np.sqrt( ((x-xc1)/xr)**2 + ((z-zc)/zr)**2 )
#         rTilde2 = np.sqrt( ((x-xc2)/xr)**2 + ((z-zc)/zr)**2 )
#         #Not infinitely smooth:
#         Tprime0 = np.zeros( np.shape(x) )
#         ind1 = rTilde1 <= 1
#         ind2 = rTilde2 <= 1
#         Tprime0[ind1] = -15./2. * ( 1. + np.cos(np.pi*rTilde1[ind1]) )
#         Tprime0[ind2] = -15./2. * ( 1. + np.cos(np.pi*rTilde2[ind2]) )
#         # #Infinitely smooth:
#         # Tprime0 = -15. * np.exp( -(2.*rTilde1)**2. )
#         # Tprime0 = Tprime0 - 15. * np.exp( -(2.*rTilde2)**2. )
#         thetaPrime0 = Tprime0 / piBar
#         piPrime0 = 0.
#         U[0,:,:] = np.zeros( np.shape(x) )
#         dthetaBarDz = np.zeros( np.shape(x) )
#     elif testCase == "movingDensityCurrent" :
#         thetaBar = 300. * np.ones( np.shape(x) )
#         piBar = 1. - g / Cp / thetaBar * z
#         xc = 0.
#         zc = 3000.
#         xr = 4000.
#         zr = 2000.
#         rTilde = np.sqrt( ((x-xc)/xr)**2 + ((z-zc)/zr)**2 )
#         Tprime0 = np.zeros( np.shape(x) )
#         ind = rTilde <= 1
#         Tprime0[ind] = -15. * np.exp( -(2.*rTilde[ind])**2. )
#         # Tprime0[ind] = -15./2. * ( 1. + np.cos(np.pi*rTilde[ind]) )
#         thetaPrime0 = Tprime0 / piBar
#         piPrime0 = 0.
#         U[0,:,:] = 20. * np.ones( np.shape(x) )
#         dthetaBarDz = np.zeros( np.shape(x) )
#     else :
#         sys.exit("\nError: Invalid test case string.\n")
#     
#     dpidsBar    = -g / Rd / thetaBar            / dsdz(x,z) * Po * piBar**(Cv/Rd)
#     dpidsPrime0 = -g / Rd / (thetaBar+thetaPrime0) / dsdz(x,z) * Po * (piBar+piPrime0)**(Cv/Rd) - dpidsBar
#     
#     Tbar   = thetaBar * piBar
#     Pbar   = Po * piBar ** (Cp/Rd)
#     rhoBar = Pbar / ( Rd * Tbar )
#     
#     dpiBarDz  = -g / Cp / thetaBar
#     dTbarDz   = thetaBar * dpiBarDz + piBar * dthetaBarDz
#     dPbarDz   = -rhoBar * g
#     drhoBarDz = ( Tbar * dPbarDz - Pbar * dTbarDz ) / ( Rd * Tbar**2. )
#     
#     Tprime0   = ( thetaBar + thetaPrime0 ) * ( piBar + piPrime0 ) - Tbar
#     Pprime0   = Po * ( piBar + piPrime0 ) ** (Cp/Rd) - Pbar
#     rhoPrime0 = ( Pbar + Pprime0 ) / Rd / ( Tbar + Tprime0 ) - rhoBar
#     
#     U[1,:,:] = np.zeros( np.shape(x) )
#     
#     if formulation == "theta_pi" :
#         U[2,:,:] = thetaPrime0
#         U[3,:,:] = piPrime0
#     elif formulation == "T_rho_P" :
#         U[2,:,:] = Tprime0
#         U[3,:,:] = rhoPrime0
#     elif formulation == "theta_rho_P" :
#         U[2,:,:] = thetaPrime0
#         U[3,:,:] = rhoPrime0
#     elif formulation == "HOMMEstyle" :
#         U[2,:,:] = thetaPrime0
#         U[3,:,:] = dpidsPrime0
#         U[4,:,:] = g * z
#     else :
#         sys.exit( "\nError: formulation should be 'theta_pi', 'T_rho_P', 'theta_rho_P', or 'HOMMEstyle'.\n" )
#     
#     return U, thetaBar, piBar, dpidsBar, Pbar, rhoBar, Tbar \
#     , dthetaBarDz, dpiBarDz, dTbarDz, dPbarDz, drhoBarDz

###########################################################################

#Only necessary if you want to approximate derivatives on 2D stencils:

# def getIndexes( X, Z, xLeft, xRight, zSurf, zTop, nLev, nCol ) :
    
    # x = X.flatten()
    # z = Z.flatten()
    
    # pts = np.transpose( np.vstack((x,z)) )
    # tree = spatial.cKDTree( pts )
    
    # class ind :
        # pass
    
    # tmp = np.arange( 0, len(x) )
    
    # ind.m = (x>xLeft) & (x<xRight) & (z>zSurf(x)) & (z<zTop)
    # ind.m = tmp[ ind.m ]
    
    # ind.gl = (x<xLeft)
    # ind.r  = tree.query( np.transpose( np.vstack(( x[ind.gl]+(xRight-xLeft), z[ind.gl] )) ), 1 )
    # ind.r  = ind.r[1]
    # ind.gl = tmp[ ind.gl ]
    
    # ind.gr = (x>xRight)
    # ind.l  = tree.query( np.transpose( np.vstack(( x[ind.gr]-(xRight-xLeft), z[ind.gr] )) ), 1 )
    # ind.l  = ind.l[1]
    # ind.gr = tmp[ ind.gr ]
    
    # ind.gb = tree.query( np.transpose( np.vstack(( X[0,FDo2:nCol+FDo2], Z[0,FDo2:nCol+FDo2] )) ), 1 )
    # ind.gb = ind.gb[1]
    
    # ind.b = tree.query( np.transpose( np.vstack(( X[1,FDo2:nCol+FDo2], Z[1,FDo2:nCol+FDo2] )) ), 1 )
    # ind.b = ind.b[1]
    
    # ind.gt = tree.query( np.transpose( np.vstack(( X[nLev+1,FDo2:nCol+FDo2], Z[nLev+1,FDo2:nCol+FDo2] )) ), 1 )
    # ind.gt = ind.gt[1]
    
    # ind.t = tree.query( np.transpose( np.vstack(( X[nLev,FDo2:nCol+FDo2], Z[nLev,FDo2:nCol+FDo2] )) ), 1 )
    # ind.t = ind.t[1]
    
    # return ind

###########################################################################

# def plotNodes( x, z, testCase ) :
#     
#     x = x.flatten()
#     z = z.flatten()
# 
#     ms = 12
# 
#     plt.plot( x, z, ".", color="black" )
#     # plt.plot( x[ind.m],  z[ind.m],  "o", color="black",  fillstyle="none", markersize=10 )
#     # plt.plot( x[ind.gl], z[ind.gl], "o", color="red",    fillstyle="none", markersize=ms )
#     # plt.plot( x[ind.r],  z[ind.r],  "s", color="red",    fillstyle="none", markersize=ms )
#     # plt.plot( x[ind.gr], z[ind.gr], "o", color="blue",   fillstyle="none", markersize=ms )
#     # plt.plot( x[ind.l],  z[ind.l],  "s", color="blue",   fillstyle="none", markersize=ms )
#     # plt.plot( x[ind.gb], z[ind.gb], "^", color="orange", fillstyle="none", markersize=ms )
#     # plt.plot( x[ind.b],  z[ind.b],  "v", color="orange", fillstyle="none", markersize=ms )
#     # plt.plot( x[ind.gt], z[ind.gt], "v", color="green",  fillstyle="none", markersize=ms )
#     # plt.plot( x[ind.t],  z[ind.t],  "^", color="green",  fillstyle="none", markersize=ms )
#     if testCase != "igw" :
#         plt.axis( 'equal' )
#     plt.show()

###########################################################################

# #Given a vector U, this function evaluates the matrix-vector product
# #(I-dt*implicitPart(U))*U on the main nodes, using the correct ghost values
# #on the other nodes.
# 
# def L( U \
# , dt, setGhostNodes, implicitPart, nLev, nCol ) :
#     
#     U = np.transpose( np.reshape( U.flatten(), (4,nCol,nLev+2) ), (0,2,1) )
#     
#     U, P, tmp = setGhostNodes( U )
#     
#     V = np.zeros(( 4, nLev+2, nCol ))
#     
#     V[:,1:-1,:] = U[:,1:-1,:] - dt * implicitPart( U, P )
#     
#     V = np.transpose( V, (0,2,1) ) . flatten()
#     
#     return V

###########################################################################

# def leapfrogTimestep( t, U0, P0, U1, P1, dt \
# , nLev, nCol \
# , L, implicitPart, explicitPart, gmresTol ) :
#     
#     V = np.zeros(( 4, nLev+2, nCol ))
#     
#     V[:,1:-1,:] = ( U0[:,1:-1,:] + dt*implicitPart(U0,P0) ) + 2.*dt*explicitPart(U1,P1)
#     
#     V  = np.transpose( V,  (0,2,1) ) . flatten()
#     U0 = np.transpose( U0, (0,2,1) ) . flatten()
#     U1 = np.transpose( U1, (0,2,1) ) . flatten()
#     
#     U2, flag = gmres( L, V, x0=2*U1-U0, tol=gmresTol )
#     # U2, flag = minres( L, V, x0=2*U1-U0, tol=gmresTol )
#     # U2, flag =    cg( L, V, x0=2*U1-U0, tol=gmresTol )
#     
#     # print()
#     # print(flag)
#     
#     U2 = np.transpose( np.reshape( U2, (4,nCol,nLev+2) ), (0,2,1) )
#     
#     t = t + dt
#     
#     return t, U2

###########################################################################

# #CL are the contour levels to use for potential temperature perturbation,
# #which is the most commonly plotted field for comparisons.
# 
# def setFigAndContourLevels( testCase ) :
#     
#     if testCase == "densityCurrent" :
#         
#         fig = plt.figure( figsize = (28,3) )
#         CL = np.arange( -16.5, 1.5, 1. )
#         
#     elif testCase == "doubleDensityCurrent" :
#         
#         fig = plt.figure( figsize = (30,12) )
#         CL = np.arange( -16.5, 1.5, 1. )
#         
#     elif testCase == "movingDensityCurrent" :
#         
#         fig = plt.figure( figsize = (30,5) )
#         CL = np.arange( -16.5, 1.5, 1. )
#         
#     elif testCase == "bubble" :
#         
#         fig = plt.figure( figsize = (18,14) )
#         CL = np.arange( -.05, 2.15, .1 )
#         
#     elif testCase == "igw" :
#         
#         fig = plt.figure( figsize = (40,4) )
#         CL = np.arange( -.0021, .0035, .0002 )
#         
#     else :
#         
#         sys.exit( "\nError: Invalid test case string.\n" )
#     
#     return fig, CL

###########################################################################

# def getStandardVariables( U \
# , setGhostNodes, formulation, Tbar, Pbar, thetaBar, piBar, dpidsBar, dsdz \
# , Po, Rd, Cp, Cv, g ) :
# 
#     U, P, tmp = setGhostNodes(U)
#     
#     if formulation == "HOMMEstyle" :                 #(u,w,th,dpids,phi), P
#         V = np.zeros(( 5, np.shape(U)[1], np.shape(U)[2] ))
#     else :
#         V = np.zeros(( 4, np.shape(U)[1], np.shape(U)[2] ))
#     
#     if formulation == "theta_pi" :                             #(u,w,th,pi)
#         V[0,:,:] = U[0,:,:]
#         V[1,:,:] = U[1,:,:]
#         V[2,:,:] = U[2,:,:]
#         V[3,:,:] = U[3,:,:]
#     elif formulation == "T_rho_P" :                         #(u,w,T,rho), P
#         V[0,:,:] = U[0,:,:]
#         V[1,:,:] = U[1,:,:]
#         V[2,:,:] = ( Tbar + U[2,:,:] ) / ((Pbar+P)/Po)**(Rd/Cp) - thetaBar
#         V[3,:,:] = ((Pbar+P)/Po)**(Rd/Cp) - piBar
#     elif formulation == "theta_rho_P" :                    #(u,w,th,rho), P
#         V[0,:,:] = U[0,:,:]
#         V[1,:,:] = U[1,:,:]
#         V[2,:,:] = U[2,:,:]
#         V[3,:,:] = ((Pbar+P)/Po)**(Rd/Cp) - piBar
#     elif formulation == "HOMMEstyle" :
#         V[0,:,:] = U[0,:,:]
#         V[1,:,:] = U[1,:,:]
#         V[2,:,:] = U[2,:,:]
#         V[3,:,:] = ((Pbar+P)/Po)**(Rd/Cp) - piBar
#         V[4,:,:] = U[4,:,:] / g
#     else :
#         sys.exit( "\nError: formulation should be 'theta_pi', 'T_rho_P', 'theta_rho_P' or 'HOMMEstyle'.\n" )
#     
#     return V

###########################################################################

# def saveContourPlot( U, t, z \
# , testCase, var, fig \
# , x, CL \
# , xLeft, xRight, zTop, dx, ds ) :
#     
#     nContours = 20
#     
#     fs = 20                                                      #font size
#     
#     ax = plt.subplot(111, xlabel='x', ylabel='z')
#     for item in ([ax.title, ax.xaxis.label, ax.yaxis.label] + ax.get_xticklabels() + ax.get_yticklabels()):
#         item.set_fontsize(fs)
#     
#     if var == 0 :
#         if testCase == "igw" :
#             plt.contourf( x, z, U[0,:,:], np.linspace(19.985,20.015,nContours) )
#         elif testCase == "doubleDensityCurrent" :
#             plt.contourf( x, z, U[0,:,:], np.linspace(-30,30,nContours) )
#         else :
#             plt.contourf( x, z, U[0,:,:], nContours )
#     elif var == 1 :
#         if testCase == "igw" :
#             plt.contourf( x, z, U[1,:,:], np.linspace(-.004,.004,nContours) )
#         elif testCase == "doubleDensityCurrent" :
#             plt.contourf( x, z, U[1,:,:], np.linspace(-30,20,nContours) )
#         else :
#             plt.contourf( x, z, U[1,:,:], nContours )
#     elif var == 2 :
#         plt.contourf( x, z, U[2,:,:], CL )
#     elif var == 3 :
#         if testCase == "igw" :
#             plt.contourf( x, z, U[3,:,:], np.linspace(-1.5e-6,1.5e-6,nContours) )
#         elif testCase == "doubleDensityCurrent" :
#             plt.contourf( x, z, U[3,:,:], np.linspace(-.002,.002,nContours) )
#         elif testCase == "bubble" :
#             plt.contourf( x, z, U[3,:,:], np.linspace(-.00005,.00005,nContours) )
#         else :
#             plt.contourf( x, z, U[3,:,:], nContours )
#     elif var == 4 :
#         plt.contourf( x, z, U[4,:,:]-z, nContours )
#     else :
#         sys.exit( "\nError: var should be 0, 1, 2, or 3 (u,w,th(th)[T],pi(dpids)[rho])\n" )
#     
#     if testCase != "igw" :
#         plt.axis( 'equal' )
#     plt.axis( [ xLeft-dx, xRight+dx, -ds, zTop+ds ] )
#     cb = plt.colorbar()
#     # cb.ax.set_yticklabels(cb.ax.get_yticklabels(), fontsize=fs)
#     # plt.title( 'testCase = {0}, t = {1:04d}'.format(testCase,np.int(np.round(t)+1e-12)) )
#     # plt.rc( 'font', size=fs )
#     # plt.rc( 'xlabel', size=fs )
#     fig.savefig( '{0:04d}'.format(np.int(np.round(t)+1e-12))+'.png', bbox_inches = 'tight' )
#     plt.clf()

###########################################################################

# def printInfo( U, P, et , t ) :
#     
#     print()
#     print( "t =", np.int(np.round(t)+1e-10) )
#     tmp = time.time()
#     print( "et =", tmp-et )
#     et = tmp
#     print( "minmaxU  =", [ np.min(U[0,:,:]), np.max(U[0,:,:]) ] )
#     print( "minmaxW  =", [ np.min(U[1,:,:]), np.max(U[1,:,:]) ] )
#     print( "minmaxTh =", [ np.min(U[2,:,:]), np.max(U[2,:,:]) ] )
#     print( "minmaxPi =", [ np.min(U[3,:,:]), np.max(U[3,:,:]) ] )
#     if np.shape(U)[0] == 5 :
#         print( "minmaxPhi =", [ np.min(U[4,:,:]), np.max(U[4,:,:]) ] )
#     
#     return et

###########################################################################
