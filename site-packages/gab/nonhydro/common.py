import sys
import numpy as np
import matplotlib.pyplot as plt
from scipy import spatial
from scipy.sparse.linalg import gmres
import time

###########################################################################

def getConstants() :
    
    Cp = 1004.
    Cv = 717.
    Rd = Cp - Cv
    g  = 9.81
    Po = 10.**5.
    
    return Cp, Cv, Rd, g, Po

###########################################################################

def getSpaceDomain( testCase, dx, ds, FD ) :
    
    if testCase == "bubble" :
        xLeft = 0.
        xRight = 10000.
        zTop = 10000.
        kap = 10.
        def zSurf(xTilde) :
            # return 1000. * np.exp( -(kap*(xTilde-6000.)/(xRight-xLeft))**2 )
            return 500. * ( 1. + np.sin( 2.*np.pi*xTilde / 5000. ) )
            # return np.zeros( np.shape(xTilde) )
        def zSurfPrime(xTilde) :
            # return -2. * ( kap*(xTilde-6000.)/(xRight-xLeft) ) * kap/(xRight-xLeft) * zSurf(xTilde)
            return np.pi/5. * np.cos( 2.*np.pi*xTilde / 5000. )
            # return np.zeros( np.shape(xTilde) )
    elif testCase == "igw" :
        xLeft = 0.
        xRight = 300000.
        zTop = 10000.
        def zSurf(xTilde) :
            return np.zeros( np.shape(xTilde) )
        def zSurfPrime(xTilde) :
            return np.zeros( np.shape(xTilde) )
    elif testCase == "densityCurrent" :
        xLeft = -25600.
        xRight = 25600.
        zTop = 6400.
        def zSurf(xTilde) :
            return np.zeros( np.shape(xTilde) )
        def zSurfPrime(xTilde) :
            return np.zeros( np.shape(xTilde) )
    elif testCase == "doubleDensityCurrent" :
        xLeft = -6400.
        xRight = 6400.
        zTop = 6400.
        def zSurf(xTilde) :
            return 1000. * np.exp( -(16.*(xTilde-1000.)/(xRight-xLeft))**2. )
            # return np.zeros( np.shape(xTilde) )
        def zSurfPrime(xTilde) :
            return -2. * 16.*(xTilde-1000.)/(xRight-xLeft) *  16./(xRight-xLeft) * zSurf(xTilde)
            # return np.zeros( np.shape(xTilde) )
    elif testCase == "movingDensityCurrent" :
        xLeft = -18000.
        xRight = 18000.
        zTop = 6400.
        def zSurf(xTilde) :
            # return np.zeros( np.shape(xTilde) )
            return 500. * ( 1. + np.sin( 2.*np.pi*xTilde / 18000. ) )
        def zSurfPrime(xTilde) :
            return np.pi/18. * np.cos( 2.*np.pi*xTilde / 18000. )
            # return np.zeros( np.shape(xTilde) )
    else :
        sys.exit( "\nError: Invalid test case string.\n" )
    
    nLev = np.int( np.round( zTop / ds ) )
    nCol = np.int( np.round( (xRight-xLeft) / dx ) )
    
    x = np.linspace( xLeft+dx/2.-(FD/2.)*dx, xRight-dx/2.+(FD/2.)*dx, nCol+FD )
    zs = zSurf(x)
    dz = ( zTop - zs ) / zTop * ds
    z = np.zeros(( nLev+2, nCol+FD ))
    z[0,:] = zs - dz/2
    for i in np.arange(1,nLev+1) :
        z[i,:] = zs + dz/2 + (i-1)*dz
    z[nLev+1,:] = zTop + dz/2.
    x = np.tile( x, (nLev+2,1) )
    
    return xLeft, xRight, nLev, nCol, zTop, zSurf, zSurfPrime, x, z

###########################################################################

def getTfinal( testCase ) :

    if testCase == "bubble" :
        tf = 1500.
    elif testCase == "igw" :
        tf = 3000.
    elif testCase == "densityCurrent" :
        tf = 900.
    elif testCase == "doubleDensityCurrent" :
        tf = 900.
    elif testCase == "movingDensityCurrent" :
        tf = 900.
    else :
        sys.exit( "\nError: Invalid testCase string.\n" )
    
    return tf

###########################################################################

#Don't really use this right now, but maybe it will determine the time-step
#automatically once I know how it should do that.

def getTimeDomain( testCase, dx, ds ) :
    
    maxVel = 40.
    
    if testCase == "bubble" :
        tf = 1500.
    elif testCase == "igw" :
        tf = 3000.
    elif testCase == "densityCurrent" :
        tf = 900.
    elif testCase == "doubleDensityCurrent" :
        tf = 900.
    elif testCase == "movingDensityCurrent" :
        tf = 900.
    else :
        sys.exit( "\nError: Invalid testCase string.\n" )
    
    dx = min( dx, ds )
    dt = dx / 16. / maxVel
    dt = 1. / np.round(1./dt)
    nTimesteps = np.int( np.round(tf/dt) + 1e-12 )
    dtEul = dt
    
    return tf, dt, dtEul, nTimesteps

###########################################################################

#Scale-preserving and terrain-following height coordinate transformation.
#zBottom is assumed to be zero, and zTop is a positive length in meters.
#zSurf and zSurfPrime are functions of x.
#s, dsdx, and dsdz are functions of original variables xTilde and zTilde.

def getHeightCoordinate( zTop, zSurf, zSurfPrime ) :
    
    def s( xTilde, zTilde ) :
        return ( zTilde - zSurf(xTilde) ) / ( zTop - zSurf(xTilde) ) * zTop
    
    def dsdx( xTilde, zTilde ) :
        return ( zTilde - zTop ) * zSurfPrime(xTilde) / ( zTop - zSurf(xTilde) )**2. * zTop
    
    def dsdz( xTilde, zTilde ) :
        return zTop / ( zTop - zSurf(xTilde) )
    
    return s, dsdx, dsdz

###########################################################################

#Get unit tangent and normal vectors on bottom boundary, which will be used
#to enforce the bottom boundary conditions:

def getTanNorm( zSurfPrime, x ) :
    
    Tz = zSurfPrime( x )
    Tx = np.ones( np.shape(Tz) )
    normT = np.sqrt( Tx**2 + Tz**2 )
    Tx = Tx / normT
    Tz = Tz / normT
    Nx = -Tz
    Nz = Tx
    
    return Tx, Tz, Nx, Nz

###########################################################################

def getInitialConditions( testCase, formulation \
, nLev, nCol, FD, x, z \
, Cp, Cv, Rd, g, Po \
, dsdz ) :
    
    U = np.zeros(( 4, nLev+2, nCol+FD ))
    
    if testCase == "bubble" :
        thetaBar = 300. * np.ones( np.shape(x) )
        piBar    = 1. - g / Cp / thetaBar * z
        R = 1500.
        xc = 5000.
        zc = 3000.
        r = np.sqrt( (x-xc)**2 + (z-zc)**2 )
        ind = r < R
        thetaPrime0 = np. zeros( np.shape(x) )
        thetaPrime0[ind] = 2. * ( 1. - r[ind]/R )
        piPrime0 = 0.
        # U[0,:,:] = 20. * np.ones( np.shape(x) )
        U[0,:,:] = np.zeros( np.shape(x) )
        dthetaBarDz = np.zeros( np.shape(x) )
    elif testCase == "igw" :
        N = .01
        theta0 = 300.
        thetaBar = theta0 * np.exp( (N**2/g) * z )
        piBar = 1. + g**2. / Cp / theta0 / N**2. * ( np.exp(-N**2./g*z) - 1. )
        thetaC = .01
        hC = 10000.
        aC = 5000.
        xC = 100000.
        thetaPrime0 = thetaC * np.sin( np.pi*z/hC ) / ( 1. + ((x-xC)/aC)**2 )
        piPrime0 = 0.
        U[0,:,:] = 20. * np.ones( np.shape(x) )
        dthetaBarDz = (N**2/g) * thetaBar
    elif testCase == "densityCurrent" :
        thetaBar = 300. * np.ones( np.shape(x) )
        piBar = 1. - g / Cp / thetaBar * z
        xc = 0.
        zc = 3000.
        xr = 4000.
        zr = 2000.
        rTilde = np.sqrt( ((x-xc)/xr)**2 + ((z-zc)/zr)**2 )
        Tprime0 = np.zeros( np.shape(x) )
        ind = rTilde <= 1
        Tprime0[ind] = -15./2. * ( 1. + np.cos(np.pi*rTilde[ind]) )
        thetaPrime0 = Tprime0 / piBar
        piPrime0 = 0.
        U[0,:,:] = np.zeros( np.shape(x) )
        dthetaBarDz = np.zeros( np.shape(x) )
    elif testCase == "doubleDensityCurrent" :
        thetaBar = 300. * np.ones( np.shape(x) )
        piBar = 1. - g / Cp / thetaBar * z
        xc1 = -6400.
        xc2 = 6400.
        zc = 3000.
        xr = 4000.
        zr = 2000.
        rTilde1 = np.sqrt( ((x-xc1)/xr)**2 + ((z-zc)/zr)**2 )
        rTilde2 = np.sqrt( ((x-xc2)/xr)**2 + ((z-zc)/zr)**2 )
        Tprime0 = np.zeros( np.shape(x) )
        ind1 = rTilde1 <= 1
        ind2 = rTilde2 <= 1
        Tprime0[ind1] = -15./2. * ( 1. + np.cos(np.pi*rTilde1[ind1]) )
        Tprime0[ind2] = -15./2. * ( 1. + np.cos(np.pi*rTilde2[ind2]) )
        thetaPrime0 = Tprime0 / piBar
        piPrime0 = 0.
        U[0,:,:] = np.zeros( np.shape(x) )
        dthetaBarDz = np.zeros( np.shape(x) )
    elif testCase == "movingDensityCurrent" :
        thetaBar = 300. * np.ones( np.shape(x) )
        piBar = 1. - g / Cp / thetaBar * z
        xc = 0.
        zc = 3000.
        xr = 4000.
        zr = 2000.
        rTilde = np.sqrt( ((x-xc)/xr)**2 + ((z-zc)/zr)**2 )
        Tprime0 = np.zeros( np.shape(x) )
        ind = rTilde <= 1
        Tprime0[ind] = -15./2. * ( 1. + np.cos(np.pi*rTilde[ind]) )
        thetaPrime0 = Tprime0 / piBar
        piPrime0 = 0.
        U[0,:,:] = 20. * np.ones( np.shape(x) )
        dthetaBarDz = np.zeros( np.shape(x) )
    else :
        sys.exit("\nError: Invalid test case string.\n")
    
    dpidsBar    = -g / Rd / thetaBar            / dsdz(x,z) * Po * piBar**(Cv/Rd)
    dpidsPrime0 = -g / Rd / (thetaBar+U[2,:,:]) / dsdz(x,z) * Po * (piBar+piPrime0)**(Cv/Rd) - dpidsBar
    
    Tbar   = thetaBar * piBar
    Pbar   = Po * piBar ** (Cp/Rd)
    rhoBar = Pbar / ( Rd * Tbar )
    
    dpiBarDz  = -g / Cp / thetaBar
    dTbarDz   = thetaBar * dpiBarDz + piBar * dthetaBarDz
    dPbarDz   = -rhoBar * g
    drhoBarDz = ( Tbar * dPbarDz - Pbar * dTbarDz ) / ( Rd * Tbar**2. )
    
    Tprime0   = ( thetaBar + thetaPrime0 ) * ( piBar + piPrime0 ) - Tbar
    Pprime0   = Po * ( piBar + piPrime0 ) ** (Cp/Rd) - Pbar
    rhoPrime0 = ( Pbar + Pprime0 ) / Rd / ( Tbar + Tprime0 ) - rhoBar
    
    U[1,:,:] = np.zeros( np.shape(x) )
    
    if formulation == "theta_pi" :
        U[2,:,:] = thetaPrime0
        U[3,:,:] = piPrime0
    elif formulation == "theta_dpids_pi" :
        U[2,:,:] = thetaPrime0
        U[3,:,:] = dpidsPrime0
    elif formulation == "T_rho_P" :
        U[2,:,:] = Tprime0
        U[3,:,:] = rhoPrime0
    elif formulation == "theta_rho_P" :
        U[2,:,:] = thetaPrime0
        U[3,:,:] = rhoPrime0
    else :
        sys.exit( "\nError: formulation should be 'theta_pi', 'T_rho_P' or 'theta_rho_P'.\n" )
    
    return U, thetaBar, piBar, dpidsBar, Pbar, rhoBar, Tbar \
    , dthetaBarDz, dpiBarDz, dTbarDz, dPbarDz, drhoBarDz

###########################################################################

#Only necessary if you want to approximate derivatives on 2D stencils:

def getIndexes( X, Z, xLeft, xRight, zSurf, zTop, FD, nLev, nCol ) :
    
    x = X.flatten()
    z = Z.flatten()
    
    pts = np.transpose( np.vstack((x,z)) )
    tree = spatial.cKDTree( pts )
    
    class ind :
        pass
    
    tmp = np.arange( 0, len(x) )
    
    ind.m = (x>xLeft) & (x<xRight) & (z>zSurf(x)) & (z<zTop)
    ind.m = tmp[ ind.m ]
    
    ind.gl = (x<xLeft)
    ind.r  = tree.query( np.transpose( np.vstack(( x[ind.gl]+(xRight-xLeft), z[ind.gl] )) ), 1 )
    ind.r  = ind.r[1]
    ind.gl = tmp[ ind.gl ]
    
    ind.gr = (x>xRight)
    ind.l  = tree.query( np.transpose( np.vstack(( x[ind.gr]-(xRight-xLeft), z[ind.gr] )) ), 1 )
    ind.l  = ind.l[1]
    ind.gr = tmp[ ind.gr ]
    
    FDo2 = np.int(FD/2)
    
    ind.gb = tree.query( np.transpose( np.vstack(( X[0,FDo2:nCol+FDo2], Z[0,FDo2:nCol+FDo2] )) ), 1 )
    ind.gb = ind.gb[1]
    
    ind.b = tree.query( np.transpose( np.vstack(( X[1,FDo2:nCol+FDo2], Z[1,FDo2:nCol+FDo2] )) ), 1 )
    ind.b = ind.b[1]
    
    ind.gt = tree.query( np.transpose( np.vstack(( X[nLev+1,FDo2:nCol+FDo2], Z[nLev+1,FDo2:nCol+FDo2] )) ), 1 )
    ind.gt = ind.gt[1]
    
    ind.t = tree.query( np.transpose( np.vstack(( X[nLev,FDo2:nCol+FDo2], Z[nLev,FDo2:nCol+FDo2] )) ), 1 )
    ind.t = ind.t[1]
    
    return ind

###########################################################################

def plotNodes( x, z, ind, testCase ) :
    
    x = x.flatten()
    z = z.flatten()

    ms = 12

    plt.plot( x, z, ".", color="black" )
    plt.plot( x[ind.m],  z[ind.m],  "o", color="black",  fillstyle="none", markersize=10 )
    plt.plot( x[ind.gl], z[ind.gl], "o", color="red",    fillstyle="none", markersize=ms )
    plt.plot( x[ind.r],  z[ind.r],  "s", color="red",    fillstyle="none", markersize=ms )
    plt.plot( x[ind.gr], z[ind.gr], "o", color="blue",   fillstyle="none", markersize=ms )
    plt.plot( x[ind.l],  z[ind.l],  "s", color="blue",   fillstyle="none", markersize=ms )
    plt.plot( x[ind.gb], z[ind.gb], "^", color="orange", fillstyle="none", markersize=ms )
    plt.plot( x[ind.b],  z[ind.b],  "v", color="orange", fillstyle="none", markersize=ms )
    plt.plot( x[ind.gt], z[ind.gt], "v", color="green",  fillstyle="none", markersize=ms )
    plt.plot( x[ind.t],  z[ind.t],  "^", color="green",  fillstyle="none", markersize=ms )
    if testCase != "igw" :
        plt.axis( 'equal' )
    plt.show()

###########################################################################

#Apply a differential operator (first derivative or HV) laterally (2D input):

def LxFD_2D( U, w, j0, j1, FD, FDo2 ) :
    V = w[0] * U[:,(j0-FDo2):(j1-FDo2)]
    for i in range(1,FD+1) :
        V = V + w[i] * U[:,(j0-FDo2+i):(j1-FDo2+i)]
    return V

###########################################################################

#Apply a differential operator (first derivative or HV) vertically (2D input):

def LsFD_2D( U, w, i0, i1 ) :
    V = w[0]*U[(i0-1):(i1-1),:] + w[1]*U[i0:i1,:] + w[2]*U[(i0+1):(i1+1),:,]
    return V

###########################################################################

#Apply a differential operator (first derivative or HV) laterally (3D input):

def LxFD_3D( U, w, j0, j1, FD, FDo2 ) :
    V = w[0] * U[:,:,(j0-FDo2):(j1-FDo2)]
    for i in range(1,FD+1) :
        V = V + w[i] * U[:,:,(j0-FDo2+i):(j1-FDo2+i)]
    return V

###########################################################################

#Apply a differential operator (first derivative or HV) vertically (3D input):

def LsFD_3D( U, w, i0, i1 ) :
    V = w[0]*U[:,(i0-1):(i1-1),:] + w[1]*U[:,i0:i1,:] + w[2]*U[:,(i0+1):(i1+1),:,]
    return V

###########################################################################

#Apply differential operator using the sparse PHS-FD matrix W:

def Lphs( U \
, W \
, nLev, nCol, FD \
, ind_m, i0, i1, j0, j1 ) :
    U = np.reshape( U, ( 4, (nLev+2)*(nCol+FD) ) )
    V = np.zeros( np.shape(U) )
    U = W.dot( np.transpose(U) )
    V[ :, ind_m ] = np.transpose(U)
    V = np.reshape( V, (4,nLev+2,nCol+FD) )
    return V[:,i0:i1,j0:j1]

###########################################################################

#Given a vector U, this function evaluates the matrix-vector product
#(I-dt*implicitPart(U))*U on the main nodes, using the correct ghost values
#on the other nodes.

def L( U \
, dt, setGhostNodes, implicitPart, nLev, nCol, FD \
, i0, i1, j0, j1 ) :
    
    U = np.transpose( np.reshape( U.flatten(), (4,nCol+FD,nLev+2) ), (0,2,1) )
    
    U, P = setGhostNodes( U )
    
    V = np.zeros(( 4, nLev+2, nCol+FD ))
    
    V[:,i0:i1,j0:j1] = U[:,i0:i1,j0:j1] - dt * implicitPart( U, P )
    
    V = np.transpose( V, (0,2,1) ) . flatten()
    
    return V

###########################################################################

def leapfrogTimestep( t, U0, P0, U1, P1, dt \
, nLev, nCol, FD, i0, i1, j0, j1 \
, L, implicitPart, explicitPart, gmresTol ) :
    
    V = np.zeros(( 4, nLev+2, nCol+FD ))
    
    V[:,i0:i1,j0:j1] = ( U0[:,i0:i1,j0:j1] + dt*implicitPart(U0,P0) ) + 2.*dt*explicitPart(U1,P1)
    
    V  = np.transpose( V,  (0,2,1) ) . flatten()
    U0 = np.transpose( U0, (0,2,1) ) . flatten()
    U1 = np.transpose( U1, (0,2,1) ) . flatten()
    
    U2, flag = gmres( L, V, x0=2*U1-U0, tol=gmresTol )
    # U2, flag = minres( L, V, x0=2*U1-U0, tol=gmresTol )
    # U2, flag =    cg( L, V, x0=2*U1-U0, tol=gmresTol )
    
    # print()
    # print(flag)
    
    U2 = np.transpose( np.reshape( U2, (4,nCol+FD,nLev+2) ), (0,2,1) )
    
    t = t + dt
    
    return t, U2

###########################################################################

#CL are the contour levels to use for potential temperature perturbation,
#which is the most commonly plotted field for comparisons.

def setFigAndContourLevels( testCase ) :
    
    if testCase == "densityCurrent" :
        
        fig = plt.figure( figsize = (28,3) )
        CL = np.arange( -16.5, 1.5, 1. )
        
    elif testCase == "doubleDensityCurrent" :
        
        fig = plt.figure( figsize = (30,12) )
        CL = np.arange( -16.5, 1.5, 1. )
        
    elif testCase == "movingDensityCurrent" :
        
        fig = plt.figure( figsize = (30,5) )
        CL = np.arange( -16.5, 1.5, 1. )
        
    elif testCase == "bubble" :
        
        fig = plt.figure( figsize = (18,14) )
        CL = np.arange( -.05, 2.15, .1 )
        
    elif testCase == "igw" :
        
        fig = plt.figure( figsize = (40,4) )
        CL = np.arange( -.0021, .0035, .0002 )
        
    else :
        
        sys.exit( "\nError: Invalid test case string.\n" )
    
    return fig, CL

###########################################################################

def getStandardVariables( U \
, setGhostNodes, formulation, Tbar, Pbar, thetaBar, piBar, dpidsBar, dsdz \
, Po, Rd, Cp, Cv, g ) :

    U, P = setGhostNodes(U)
    
    V = np.zeros( np.shape(U) )
    
    if formulation == "theta_pi" :                             #(u,w,th,pi)
        V[0,:,:] = U[0,:,:]
        V[1,:,:] = U[1,:,:]
        V[2,:,:] = U[2,:,:]
        V[3,:,:] = U[3,:,:]
    elif formulation == "T_rho_P" :                         #(u,w,T,rho), P
        V[0,:,:] = U[0,:,:]
        V[1,:,:] = U[1,:,:]
        V[2,:,:] = ( Tbar + U[2,:,:] ) / ((Pbar+P)/Po)**(Rd/Cp) - thetaBar
        V[3,:,:] = ((Pbar+P)/Po)**(Rd/Cp) - piBar
    elif formulation == "theta_rho_P" :                    #(u,w,th,rho), P
        V[0,:,:] = U[0,:,:]
        V[1,:,:] = U[1,:,:]
        V[2,:,:] = U[2,:,:]
        V[3,:,:] = ((Pbar+P)/Po)**(Rd/Cp) - piBar
    elif formulation == "theta_dpids_P" :
        V[0,:,:] = U[0,:,:]
        V[1,:,:] = U[1,:,:]
        V[2,:,:] = U[2,:,:]
        V[3,:,:] = ( -1/g*dsdz*(U[3,:,:]+dpidsBar) * Rd * (thetaBar+U[2,:,:]) / Po ) ** (Rd/Cv) - piBar
    else :
        sys.exit( "\nError: formulation should be 'theta_pi', 'T_rho_P' or 'theta_rho_P' or 'theta_dpids_P'.\n" )
    
    return V

###########################################################################

def saveContourPlot( U, t \
, testCase, var, fig \
, x, z, CL, FDo2 \
, xLeft, xRight, zTop, dx, ds ) :
    
    nContours = 20
    
    if var == 0 :
        plt.contourf( x, z, U[0,:,:], nContours )
    elif var == 1 :
        plt.contourf( x, z, U[1,:,:], nContours )
    elif var == 2 :
        plt.contourf( x, z, U[2,:,:], CL )
    elif var == 3 :
        plt.contourf( x, z, U[3,:,:], nContours )
    else :
        sys.exit( "\nError: var should be 0, 1, 2, or 3 (u,w,th(th)[T],pi(dpids)[rho])\n" )
    
    if testCase != "igw" :
        plt.axis( 'equal' )
    plt.axis( [ xLeft-FDo2*dx, xRight+FDo2*dx, -ds, zTop+ds ] )
    plt.colorbar()
    # plt.title( 'testCase = {0}, t = {1:04d}'.format(testCase,np.int(np.round(t)+1e-12)) )
    fig.savefig( '{0:04d}'.format(np.int(np.round(t)+1e-12))+'.png', bbox_inches = 'tight' )
    plt.clf()

###########################################################################

def printInfo( U, P, et , t ) :
    
    print()
    print( "t =", np.int(np.round(t)+1e-10) )
    print( "et =", time.clock()-et )
    et = time.clock()
    print( "minmaxU  =", [ np.min(U[0,:,:]), np.max(U[0,:,:]) ] )
    print( "minmaxW  =", [ np.min(U[1,:,:]), np.max(U[1,:,:]) ] )
    print( "minmaxTh =", [ np.min(U[2,:,:]), np.max(U[2,:,:]) ] )
    print( "minmaxPi =", [ np.min(U[3,:,:]), np.max(U[3,:,:]) ] )
    
    # if formulation == "pdt" :
        # print(     "minmaxT     =", [ np.min(U[2,:,:]), np.max(U[2,:,:]) ] )
    # else :
        # print(     "minmaxTh    =", [ np.min(U[2,:,:]), np.max(U[2,:,:]) ] )
    
    # if formulation == "exner" :
        # print( "minmaxPi    =", [ np.min(U[3,:,:]), np.max(U[3,:,:]) ] )
    # elif formulation == "pseudoDensity" :
        # print( "minmaxDpids =", [ np.min(U[3,:,:]), np.max(U[3,:,:]) ] )
    # elif ( formulation == "pdt" ) | ( formulation == "pdTh" ) :
        # print( "minmaxRho   =", [ np.min(U[3,:,:]), np.max(U[3,:,:]) ] )
        # print( "minmaxP     =", [ np.min(P),        np.max(P)        ] )
    # else :
        # sys.exit( "\nError: formulation should be 'exner' or 'hydrostaticPressure'.\n" )
    
    return et

###########################################################################
