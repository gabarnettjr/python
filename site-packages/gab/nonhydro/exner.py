import numpy as np

###########################################################################

#prognostic variables:  u, w, th, pi, where pi is Exner pressure
#diagnostic variables:  none

def setGhostNodes( U, Dx \
, Tx, Tz, Nx, Nz, bigTx, bigTz, j0, j1 \
, nLev, nCol, FD, FDo2, ds, thetaBarBot, thetaBarTop \
, g, Cp, normGradS, dsdxBot, dsdzBot ) :
    
    #extrapolate uT to bottom ghost nodes:
    uT = U[0,1:3,j0:j1] * bigTx + U[1,1:3,j0:j1] * bigTz
    uT = 2*uT[0,:] - uT[1,:]
    
    #get uN on bottom ghost nodes:
    uN = U[0,1,j0:j1]*Nx + U[1,1,j0:j1]*Nz
    uN = -uN
    
    #use uT and uN to get (u,w) on bottom ghost nodes, then get (u,w) on top ghost nodes:
    U[0,0,j0:j1] = uT*Tx + uN*Nx
    U[1,0,j0:j1] = uT*Tz + uN*Nz
    U[0,nLev+1,j0:j1] = 2*U[0,nLev,j0:j1] - U[0,nLev-1,j0:j1]
    U[1,nLev+1,j0:j1] = -U[1,nLev,j0:j1]
    
    #extrapolate theta to bottom and top ghost nodes:
    U[2,0,j0:j1] = 2*U[2,1,j0:j1] - U[2,2,j0:j1]
    U[2,nLev+1,j0:j1] = 2*U[2,nLev,j0:j1] - U[2,nLev-1,j0:j1]
    
    #get pi on bottom ghost nodes using derived BC:
    dpidx = Dx( U[3,1:3,:] )
    dpidx = 3./2.*dpidx[0,:] - 1./2.*dpidx[1,:]
    tmp = g/Cp/thetaBarBot**2 * dsdzBot * (U[2,0,j0:j1]+U[2,1,j0:j1])/2.
    U[3,0,j0:j1] = U[3,1,j0:j1] - ds/normGradS**2. * ( tmp - dpidx*dsdxBot )
    
    #get pi on top ghost nodes:
    tmp = g/Cp/thetaBarTop**2 * dsdzBot * (U[2,nLev,j0:j1]+U[2,nLev+1,j0:j1])/2.
    U[3,nLev+1,j0:j1] = U[3,nLev,j0:j1] + ds/dsdzBot**2. * ( tmp - dpidx*0. ) 
    
    #enforce periodic lateral boundary condition:
    U[ :, :,         0:FDo2    ] = U[ :, :, nCol:nCol+FDo2 ]
    U[ :, :, nCol+FDo2:nCol+FD ] = U[ :, :, FDo2:FD        ]
    
    return U

###########################################################################

#The 3D array U is given to this function with correct ghost node values.

def implicitPart( U \
, Dx, Ds, HVx, HVs \
, nLev, nCol, i0, i1, j0, j1, Cp, Cv, Rd, g \
, dsdx, dsdz, thetaBar, piBar, dthetaBarDz ) :
    
    V = np.zeros(( 4, nLev, nCol ))
    
    V[0,:,:] = -Cp*thetaBar * ( Dx(U[3,i0:i1,:]) + Ds(U[3,:,j0:j1])*dsdx ) \
    + HVx(U[0,i0:i1,:]) + HVs(U[0,:,j0:j1])
    
    V[1,:,:] = -Cp*thetaBar * Ds(U[3,:,j0:j1])*dsdz \
    +g/thetaBar * U[2,i0:i1,j0:j1] \
    + HVx(U[1,i0:i1,:]) + HVs(U[1,:,j0:j1])
    
    V[2,:,:] = -U[1,i0:i1,j0:j1] * dthetaBarDz \
    + HVx(U[2,i0:i1,:]) + HVs(U[2,:,j0:j1])
    
    V[3,:,:] = g/Cp/thetaBar * U[1,i0:i1,j0:j1] \
    -Rd/Cv*piBar * ( Dx(U[0,i0:i1,:])+Ds(U[0,:,j0:j1])*dsdx + Ds(U[1,:,j0:j1])*dsdz ) \
    + HVx(U[3,i0:i1,:]) + HVs(U[3,:,j0:j1])
    
    return V

###########################################################################

#The 3D array U is given to this function with correct ghost node values.

def explicitPart( U \
, Dx, Ds \
, nLev, nCol, i0, i1, j0, j1, Cp, Cv, Rd \
, dsdx, dsdz ) :
    
    V = np.zeros(( 4, nLev, nCol ))
    
    sDot = U[0,i0:i1,j0:j1]*dsdx + U[1,i0:i1,j0:j1]*dsdz
    
    V[0,:,:] = -U[0,i0:i1,j0:j1]*Dx(U[0,i0:i1,:]) - sDot*Ds(U[0,:,j0:j1]) \
    -Cp*U[2,i0:i1,j0:j1] * ( Dx(U[3,i0:i1,:]) + Ds(U[3,:,j0:j1])*dsdx )
    
    V[1,:,:] = -U[0,i0:i1,j0:j1]*Dx(U[1,i0:i1,:]) - sDot*Ds(U[1,:,j0:j1]) \
    -Cp*U[2,i0:i1,j0:j1] * ( Ds(U[3,:,j0:j1])*dsdz )
    
    V[2,:,:] = -U[0,i0:i1,j0:j1]*Dx(U[2,i0:i1,:]) - sDot*Ds(U[2,:,j0:j1])
    
    V[3,:,:] = -U[0,i0:i1,j0:j1]*Dx(U[3,i0:i1,:]) - sDot*Ds(U[3,:,j0:j1]) \
    -Rd/Cv*U[3,i0:i1,j0:j1] \
    * ( Dx(U[0,i0:i1,:])+Ds(U[0,:,j0:j1])*dsdx + Ds(U[1,:,j0:j1])*dsdz )
    
    return V

###########################################################################

# #prognostic variables:  u, w, th, dpids, where pi is hydrostatic pressure
# #diagnostic variables:  P

# def setGhostNodes2( U \
# , Tx, Tz, Nx, Nz, bigTx, bigTz, jj \
# , nLev, nCol, thetaBar, dpidsBar, g, Cp, Po, Rd, Cv \
# , normGradS, ds, dsdxBottom, dsdzBottom, dsdz \
# , wx, j0, j1, dx, FD, FDo2 ) :
    
    # #extrapolate uT to bottom ghost nodes:
    # uT = U[0,1:3,:][:,jj] * bigTx + U[1,1:3,:][:,jj] * bigTz
    # uT = 2*uT[0,:] - uT[1,:]
    
    # #get uN on bottom ghost nodes:
    # uN = U[0,1,jj]*Nx + U[1,1,jj]*Nz
    # uN = -uN
    
    # #use uT and uN to get (u,w) on bottom ghost nodes, then get (u,w) on top ghost nodes:
    # U[0,0,jj] = uT*Tx + uN*Nx
    # U[1,0,jj] = uT*Tz + uN*Nz
    # U[0,nLev+1,jj] = 2*U[0,nLev,jj] - U[0,nLev-1,jj]
    # U[1,nLev+1,jj] = -U[1,nLev,jj]
    
    # #extrapolate theta to bottom and top ghost nodes:
    # U[2,0,jj] = thetaBar[0,jj] + 2*(U[2,1,jj]-thetaBar[1,jj]) \
    # - (U[2,2,jj]-thetaBar[2,jj])
    # U[2,nLev+1,jj] = thetaBar[nLev+1,jj] + 2*(U[2,nLev,jj]-thetaBar[nLev,jj]) \
    # - (U[2,nLev-1,jj]-thetaBar[nLev-1,jj])
    
    # #get P using the equation of state:
    # P = Po**(-Rd/Cv) * ( -Rd * U[2,:,:] / g * U[3,:,:] * dsdz ) ** (Cp/Cv)
    # P[ 1:3,         0:FDo2    ] = P[ 1:3, nCol:nCol+FDo2 ]
    # P[ 1:3, nCol+FDo2:nCol+FD ] = P[ 1:3, FDo2:FD        ]
    
    # #get P on bottom ghost nodes:
    # dpids = (dpidsBar[0,jj]+dpidsBar[1,jj])/2. \
    # + 3./2.*(U[3,1,jj]-dpidsBar[1,jj]) - 1./2.*(U[3,2,jj]-dpidsBar[2,jj])
    # dpdx = LxFD_2D( P[1:3,:], wx, j0, j1, dx, FD, FDo2 )
    # dpdx = 3./2.*dpdx[0,:] - 1./2.*dpdx[1,:]
    # P[0,jj] = P[1,jj] - ds/normGradS**2. * ( dpids*dsdzBottom**2. - dpdx*dsdxBottom )
    
    # #get P on top ghost nodes:
    # dpids = (dpidsBar[nLev,jj]+dpidsBar[nLev+1,jj])/2. \
    # + 3./2.*(U[3,nLev,jj]-dpidsBar[nLev,jj]) - 1./2.*(U[3,nLev-1,jj]-dpidsBar[nLev-1,jj])
    # P[nLev+1,jj] = P[nLev,jj] + ds * dpids
    
    # #get dpids on bottom and top ghost nodes:
    # U[3,0,jj] = dpidsBar[0,jj] + 2.*(U[3,1,jj]-dpidsBar[1,jj]) \
    # - (U[3,2,jj]-dpidsBar[2,jj])
    # U[3,nLev+1,jj] = dpidsBar[nLev+1,jj] + 2.*(U[3,nLev,jj]-dpidsBar[nLev,jj]) \
    # - (U[3,nLev-1,jj]-dpidsBar[nLev-1,jj])
    
    # #enforce periodic lateral boundary condition in prognostic variables:
    # U[ :, :,         0:FDo2    ] = U[ :, :, nCol:nCol+FDo2 ]
    # U[ :, :, nCol+FDo2:nCol+FD ] = U[ :, :, FDo2:FD        ]
    
    # #enforce periodic lateral boundary condition in diagnostic pressure:
    # P[    :,         0:FDo2    ] = P[    :, nCol:nCol+FDo2 ]
    # P[    :, nCol+FDo2:nCol+FD ] = P[    :, FDo2:FD        ]
    
    # return U, P

###########################################################################

# #prognostic variables:  u, w, th, dpids, where pi is hydrostatic pressure
# #diagnostic variables:  P

# def odefun2( t, U \
# , setGhostNodes, Dx, Dx2D, Ds, Ds2D, HVx, HVs \
# , ii, jj, i0, i1, j0, j1 \
# , dsdx, dsdz, dsdxAll, dsdzAll \
# , Cp, Cv, Rd, g, gamma ) :
    
    # #Initialize output array:
    # V = np.zeros( np.shape(U) )
    
    # #Set ghost node values for all variables and get diagnostic pressure:
    # U, P = setGhostNodes( U )
    
    # #Us and Ux:
    # Us = Ds( U[:,:,jj] )
    # Ux = Dx( U[:,ii,:] )
    
    # #Get u and sDot and dpds:
    # u = np.tile( U[0,ii,:][:,jj], (4,1,1) )
    # sDotAll = U[0,:,:] * dsdxAll + U[1,:,:] * dsdzAll
    # sDot = sDotAll[ii,:][:,jj]
    # sDot = np.tile( sDot, (4,1,1) )
    # dpds = Ds2D( P[:,jj] )
    
    # #RHS of ODE function:
    # V[ :, i0:i1, j0:j1 ] = - u * Ux - sDot * Us
    # V[ 0, i0:i1, j0:j1 ] = V[0,ii,:][:,jj] + g / U[3,ii,:][:,jj] / dsdz * ( Dx2D(P[ii,:]) + dpds*dsdx )
    # V[ 1, i0:i1, j0:j1 ] = V[1,ii,:][:,jj] - g * ( 1 - dpds/U[3,ii,:][:,jj] )
    # V[ 3, i0:i1, j0:j1 ] = V[3,ii,:][:,jj] - U[3,ii,:][:,jj] * ( Ux[0,:,:] + Ds2D(sDotAll[:,jj]) )
    
    # #Add dissipation:
    # V[ :, i0:i1, j0:j1 ] = V[:,ii,:][:,:,jj] \
    # + gamma * np.abs(u) * HVx( U[:,ii,:] ) \
    # + (1./2.) * np.abs(sDot) * HVs( U[:,:,jj] )
    
    # return V

###########################################################################

# #WARNING:  THIS DOES NOT WORK IF THERE IS TOPOGRAPHY.
# #ACTUALLY, IT DOESN'T REALLY WORK AT ALL

# def conventionalSemiLagrangianTimestep( U0, U1, alp, bet \
# , setGhostNodes, Dx, Ds \
# , nLev, nCol, FD, FDo2, ds \
# , Cp, Rd, Cv, g, dt \
# , x2, z2, dsdx, dsdz \
# , ind_m, i0, i1, j0, j1 \
# , rbfOrder, polyOrder, stencilSize ) :
    
    # U1star = 3./2.*U1 - 1./2.*U0
    
    # dpidx = np.zeros(( nLev+2, nCol+FD ))
    # dpidx[ :, j0:j1 ] = Dx( U1star[ 3, :, : ] )
    # dpidx[ :,         0:FDo2    ] = dpidx[ :, nCol:nCol+FDo2 ]
    # dpidx[ :, nCol+FDo2:nCol+FD ] = dpidx[ :, FDo2:FD        ]
    # dpidx = dpidx.flatten()
    
    # dpids = np.zeros(( nLev+2, nCol+FD ))
    # dpids[ i0:i1, : ] = Ds( U1star[ 3, :, : ] )
    # dpids[0,:]      = ( U1star[3,1,:]      - U1star[3,0,:] )    / ds
    # dpids[nLev+1,:] = ( U1star[3,nLev+1,:] - U1star[3,nLev,:] ) / ds
    # dpids = dpids.flatten()
    
    # dudx = np.zeros(( nLev+2, nCol+FD ))
    # dudx[ :, j0:j1 ] = Dx( U1star[ 0, :, : ] )
    # dudx[ :,         0:FDo2    ] = dudx[ :, nCol:nCol+FDo2 ]
    # dudx[ :, nCol+FDo2:nCol+FD ] = dudx[ :, FDo2:FD        ]
    # dudx = dudx.flatten()
    
    # duds = np.zeros(( nLev+2, nCol+FD ))
    # duds[ i0:i1, : ] = Ds( U1star[ 0, :, : ] )
    # duds[0,:]      = ( U1star[0,1,:]      - U1star[0,0,:] )    / ds
    # duds[nLev+1,:] = ( U1star[0,nLev+1,:] - U1star[0,nLev,:] ) / ds
    # duds = duds.flatten()
    
    # dwds = np.zeros(( nLev+2, nCol+FD ))
    # dwds[ i0:i1, : ] = Ds( U1star[ 1, :, : ] )
    # dwds[0,:]      = ( U1star[1,1,:]      - U1star[1,0,:] )    / ds
    # dwds[nLev+1,:] = ( U1star[1,nLev+1,:] - U1star[1,nLev,:] ) / ds
    # dwds = dwds.flatten()
    
    # u1star  = U1star[0,:,:] . flatten()
    # w1star  = U1star[1,:,:] . flatten()
    # pi1star = U1star[3,:,:] . flatten()
    
    # for i in range(3) :
        # stencils = phs2.getStencils( x2, z2, x2-alp/2., z2-bet/2., stencilSize )
        # A = phs2.getAmatrices( stencils, rbfOrder, polyOrder )
        # W = phs2.getWeights( stencils, A, "i", 0 )
        # alp = dt * np.sum( W*u1star[stencils.idx], axis=1 )
        # bet = dt * np.sum( W*w1star[stencils.idx], axis=1 )
    
    # x1 = x2[ind_m] - alp[ind_m]
    # z1 = z2[ind_m] - bet[ind_m]
    
    # u1  = U1[0,:,:] . flatten()
    # w1  = U1[1,:,:] . flatten()
    # th1 = U1[2,:,:] . flatten()
    # pi1 = U1[3,:,:] . flatten()
    
    # stencils = phs2.getStencils( x2, z2, x1, z1, stencilSize )
    # A = phs2.getAmatrices( stencils, rbfOrder, polyOrder )
    # W = phs2.getWeights( stencils, A, "i", 0 )
    # u1  = np.sum( W*u1[stencils.idx],  axis=1 )
    # w1  = np.sum( W*w1[stencils.idx],  axis=1 )
    # th1 = np.sum( W*th1[stencils.idx], axis=1 )
    # pi1 = np.sum( W*pi1[stencils.idx], axis=1 )
    
    # x1star = x2[ind_m] - alp[ind_m]/2.
    # z1star = z2[ind_m] - bet[ind_m]/2.
    
    # stencils = phs2.getStencils( x2, z2, x1star, z1star, stencilSize )
    # A = phs2.getAmatrices( stencils, rbfOrder, polyOrder )
    # W = phs2.getWeights( stencils, A, "i", 0 )
    # th1star = th1
    # pi1star = np.sum( W*pi1star[stencils.idx], axis=1 )
    # dpidx   = np.sum( W*dpidx[stencils.idx],   axis=1 )
    # dpids   = np.sum( W*dpids[stencils.idx],   axis=1 )
    # dudx    = np.sum( W*dudx[stencils.idx],    axis=1 )
    # duds    = np.sum( W*duds[stencils.idx],    axis=1 )
    # dwds    = np.sum( W*dwds[stencils.idx],    axis=1 )
    
    # u2 = u1 - dt * Cp * th1star * ( dpidx + dpids * dsdx(x1star,z1star) )
    # w2 = w1 - dt * ( Cp * th1star * dpids * dsdz(x1star,z1star) + g )
    # th2 = th1
    # pi2 = pi1 - dt * Rd/Cv * pi1star * ( dudx + duds * dsdx(x1star,z1star) + dwds * dsdz(x1star,z1star) )
    
    # U2 = np.zeros(( 4, (nLev+2)*(nCol+FD) ))
    # U2[0,ind_m] = u2
    # U2[1,ind_m] = w2
    # U2[2,ind_m] = th2
    # U2[3,ind_m] = pi2
    
    # U2 = np.reshape( U2, (4,nLev+2,nCol+FD) )
    
    # U2, P = setGhostNodes( U2 )
    
    # return U2, alp, bet

###########################################################################

# #One leap-frog semi-Lagrangian step

# #WARNING:  THIS DOES NOT WORK IF THERE IS TOPOGRAPHY
# #ACTUALLY, IT DOESN'T REALLY WORK AT ALL.

# def mySemiLagrangianTimestep( Un1, U \
# , setGhostNodes, Dx, Ds \
# , x0, z0, ind_m, dt \
# , nLev, nCol, FD, i0, i1, j0, j1 \
# , Cp, Rd, Cv, g, dsdx, dsdz \
# , rbfOrder, polyOrder, stencilSize ) :
    
    # #Get all spatial derivatives that will be needed:
    
    # dpidx = np.zeros(( nLev+2, nCol+FD ))
    # dpidx[ i0:i1, j0:j1 ] = Dx( U[ 3, i0:i1, : ] )
    # dpidx = dpidx.flatten()
    # dpidx = dpidx[ind_m]
    
    # dpids = np.zeros(( nLev+2, nCol+FD ))
    # dpids[ i0:i1, j0:j1 ] = Ds( U[ 3, :, j0:j1 ] )
    # dpids = dpids.flatten()
    # dpids = dpids[ind_m]
    
    # dudx = np.zeros(( nLev+2, nCol+FD ))
    # dudx[ i0:i1, j0:j1 ] = Dx( U[ 0, i0:i1, : ] )
    # dudx = dudx.flatten()
    # dudx = dudx[ind_m]
    
    # duds = np.zeros(( nLev+2, nCol+FD ))
    # duds[ i0:i1, j0:j1 ] = Ds( U[ 0, :, j0:j1 ] )
    # duds = duds.flatten()
    # duds = duds[ind_m]
    
    # dwds = np.zeros(( nLev+2, nCol+FD ))
    # dwds[ i0:i1, j0:j1 ] = Ds( U[ 1, :, j0:j1 ] )
    # dwds = dwds.flatten()
    # dwds = dwds[ind_m]
    
    # #Re-shape into vectors:
    
    # un1  = Un1[0,:,:] . flatten()
    # wn1  = Un1[1,:,:] . flatten()
    # thn1 = Un1[2,:,:] . flatten()
    # pin1 = Un1[3,:,:] . flatten()
    
    # u0  = U[0,:,:] . flatten()
    # w0  = U[1,:,:] . flatten()
    # th0 = U[2,:,:] . flatten()
    # pi0 = U[3,:,:] . flatten()
    
    # #2(a)  Set (xStar,zStar) = (x0,z0) - dt/2 * (u0,w0) :
    # xStar = x0[ind_m] - dt/2. * u0[ind_m]
    # zStar = z0[ind_m] - dt/2. * w0[ind_m]
    
    # #2(b)  Set (uStar,wStar) = ( (un1,wn1) + (u0,w0) ) / 2 :
    # uStar = ( un1 + u0 ) / 2.
    # wStar = ( wn1 + w0 ) / 2.
    
    # #2(c)  Interpolate (uStar,wStar) from (x0,z0) to (xStar,zStar) :
    # stencils = phs2.getStencils( x0, z0, xStar, zStar, stencilSize )
    # A = phs2.getAmatrices( stencils, rbfOrder, polyOrder )
    # W = phs2.getWeights( stencils, A, "i", 0 )
    # uStar = np.sum( W*uStar[stencils.idx], axis=1 )
    # wStar = np.sum( W*wStar[stencils.idx], axis=1 )
    
    # #2(d)  Set (xn1,zn1) = (x0,z0) - dt * (uStar,wStar) :
    # xn1 = x0[ind_m] - dt * uStar
    # zn1 = z0[ind_m] - dt * wStar
    
    # #3  Interpolate (un1,wn1,thn1,pin1) from (x0,z0) to (xn1,zn1) :
    # stencils = phs2.getStencils( x0, z0, xn1, zn1, stencilSize )
    # A = phs2.getAmatrices( stencils, rbfOrder, polyOrder )
    # W = phs2.getWeights( stencils, A, "i", 0 )
    # un1  = np.sum( W*un1[stencils.idx],  axis=1 )
    # wn1  = np.sum( W*wn1[stencils.idx],  axis=1 )
    # thn1 = np.sum( W*thn1[stencils.idx], axis=1 )
    # pin1 = np.sum( W*pin1[stencils.idx], axis=1 )
    
    # #4  Use S-L step to get (x1,z1) and (u1,w1,th1,pi1) :
    # x1 = xn1 + 2.*dt * u0[ind_m]
    # z1 = zn1 + 2.*dt * w0[ind_m]
    # u1 = un1 - 2.*dt * Cp * th0[ind_m] * ( dpidx + dpids*dsdx )
    # w1 = wn1 - 2.*dt * ( Cp * th0[ind_m] * dpids*dsdz + g )
    # th1 = thn1
    # pi1 = pin1 - 2.*dt * Rd/Cv*pi0[ind_m] * ( dudx+duds*dsdx + dwds*dsdz )
    
    # #5  Interpolate (u1,w1,th1,pi1) from (x1,z1) to (x0,z0) :
    # stencils = phs2.getStencils( x1, z1, x0[ind_m], z0[ind_m], stencilSize )
    # A = phs2.getAmatrices( stencils, rbfOrder, polyOrder )
    # W = phs2.getWeights( stencils, A, "i", 0 )
    # u1  = np.sum( W*u1[stencils.idx],  axis=1 )
    # w1  = np.sum( W*w1[stencils.idx],  axis=1 )
    # th1 = np.sum( W*th1[stencils.idx], axis=1 )
    # pi1 = np.sum( W*pi1[stencils.idx], axis=1 )
    
    # U = np.zeros(( 4, (nLev+2)*(nCol+FD) ))
    # U[0,ind_m] = u1
    # U[1,ind_m] = w1
    # U[2,ind_m] = th1
    # U[3,ind_m] = pi1
    
    # U = np.reshape( U, (4,nLev+2,nCol+FD) )
    
    # U, P = setGhostNodes( U )
    
    # return U

###########################################################################
