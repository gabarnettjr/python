import numpy as np

###########################################################################

#prognostic variables:  u, w, theta, rho
#diagnostic variables:  P

#Very similar to T_rho_P formulation, which is described here:
# https://www.overleaf.com/read/hnynhvhqmtyw

###########################################################################

def setGhostNodes( U, Wa \
, TxBot, TzBot, NxBot, NzBot \
, TxTop, TzTop, NxTop, NzTop \
, wIbot, wEbot, wDbot \
, wItop, wEtop, wDtop \
, nLev, nCol, stc, ds, Pbar, rhoBar, thetaBar \
, g, Rd, Cp, Cv, Po, normGradS, dsdxBot, dsdzBot ) :
    
    #extrapolate uT to bottom ghost nodes:
    uT = U[0,1:stc+1,:] * TxBot + U[1,1:stc+1,:] * TzBot
    uT = wEbot.dot( uT )
    
    #get uN on bottom ghost nodes:
    uN = U[0,1:stc,:] * NxBot + U[1,1:stc,:] * NzBot
    uN = - wIbot[1:stc].dot( uN ) / wIbot[0]
    
    #use uT and uN to get (u,w) on bottom ghost nodes, then get (u,w) on top ghost nodes:
    U[0,0,:] = uT*TxBot[0,:] + uN*NxBot[0,:]
    U[1,0,:] = uT*TzBot[0,:] + uN*NzBot[0,:]
    U[0,-1,:] = wEtop.dot( U[0,-2:-(stc+2):-1,:] )
    U[1,-1,:] = - wItop[1:stc].dot( U[1,-2:-(stc+1):-1,:] ) / wItop[0]
    
    #extrapolate theta to bottom and top ghost nodes:
    U[2,0,:] = wEbot.dot( U[2,1:stc+1,:] )
    U[2,-1,:] = wEtop.dot( U[2,-2:-(stc+2):-1,:] )
    
    #extrapolate density to bottom and top ghost nodes:
    U[3,0,:] = wEbot.dot( U[3,1:stc+1,:] )
    U[3,-1,:] = wEtop.dot( U[3,-2:-(stc+2):-1,:] )
    
    #get pressure using the equation of state:
    P = Po * ( (rhoBar+U[3,:,:]) * Rd * (thetaBar+U[2,:,:]) / Po ) ** (Cp/Cv) - Pbar
    
    #set pressure on bottom ghost nodes:
    dpda = Wa.dot(wIbot.dot(P[0:stc,:]).T).T
    rho = wIbot.dot( U[3,0:stc,:] )
    tmp = -1./normGradS**2. * ( rho*g*dsdzBot + dpda*dsdxBot )
    P[0,:] = ( tmp - wDbot[1:stc].dot(P[1:stc,:]) ) / wDbot[0]
    
    #set pressure on top ghost nodes:
    rho = wEtop.dot( U[3,-2:-(stc+2):-1,:] )
    tmp = -1/dsdzBot**2. * ( rho*g*dsdzBot )
    P[-1,:] = ( tmp - wDtop[1:stc].dot(P[-2:-(stc+1):-1,:]) ) / wDtop[0]
    
    return U, P

###########################################################################

#3D arrays U, P are given to this function with correct ghost node values.

def implicitPart( U, P \
, Da, Ds, HV \
, nLev, nCol, Cp, Cv, Rd, g \
, dsdx, dsdz, rhoBar, drhoBarDz, dthetaBarDz ) :
    
    V = np.zeros(( 4, nLev, nCol ))
    
    dpds = Ds(P)
    
    V[0,:,:] = -1/rhoBar * ( Da(P) + dpds*dsdx ) \
    + HV( U[0,:,:] )
    
    V[1,:,:] = -1/rhoBar * ( dpds*dsdz + U[3,1:-1,:]*g ) \
    + HV( U[1,:,:] )
    
    V[2,:,:] = -U[1,1:-1,:] * dthetaBarDz \
    + HV( U[2,:,:] )
    
    V[3,:,:] = -U[1,1:-1,:] * drhoBarDz \
    - rhoBar * ( Da(U[0,:,:])+Ds(U[0,:,:])*dsdx + Ds(U[1,:,:])*dsdz ) \
    + HV( U[3,:,:] )
    
    return V

###########################################################################

#3D arrays U, P are given to this function with correct ghost node values.

def explicitPart( U, P \
, Da, Ds \
, nLev, nCol, Cv, Rd, g \
, dsdx, dsdz, rhoBar ) :
    
    V = np.zeros(( 4, nLev, nCol ))
    
    u = U[0,1:-1,:]
    sDot = u*dsdx + U[1,1:-1,:]*dsdz
    
    dpds = Ds(P)
    duda = Da(U[0,:,:])
    duds = Ds(U[0,:,:])
    dwds = Ds(U[1,:,:])
    
    tmp = U[3,1:-1,:] / rhoBar / (rhoBar+U[3,1:-1,:])
    
    V[0,:,:] = -u*duda - sDot*duds \
    + tmp * ( Da(P) + dpds*dsdx )
    
    V[1,:,:] = -u*Da(U[1,:,:]) - sDot*dwds \
    + tmp * ( dpds*dsdz + U[3,1:-1,:]*g )
    
    V[2,:,:] = -u*Da(U[2,:,:]) - sDot*Ds(U[2,:,:])
    
    V[3,:,:] = -u*Da(U[3,:,:]) - sDot*Ds(U[3,:,:]) \
    - U[3,1:-1,:] * ( duda+duds*dsdx + dwds*dsdz )
    
    return V

###########################################################################
