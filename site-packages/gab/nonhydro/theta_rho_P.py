import numpy as np

###########################################################################

#prognostic variables:  u, w, theta, rho
#diagnostic variables:  P

#Very similar to T_rho_P formulation, which is described here:
# https://www.overleaf.com/read/hnynhvhqmtyw

###########################################################################

def setGhostNodes( U, Dx \
, Tx, Tz, Nx, Nz, bigTx, bigTz, j0, j1 \
, nLev, nCol, FD, FDo2, ds, Pbar, rhoBar, thetaBar \
, g, Rd, Cp, Cv, Po, normGradS, dsdxBot, dsdzBot ) :
    
    #extrapolate uT to bottom ghost nodes:
    uT = U[0,1:3,j0:j1] * bigTx + U[1,1:3,j0:j1] * bigTz
    uT = 2*uT[0,:] - uT[1,:]
    
    #get uN on bottom ghost nodes:
    uN = U[0,1,j0:j1]*Nx + U[1,1,j0:j1]*Nz
    uN = -uN
    
    #use uT and uN to get (u,w) on bottom ghost nodes, then get (u,w) on top ghost nodes:
    U[0,0,j0:j1] = uT*Tx + uN*Nx
    U[1,0,j0:j1] = uT*Tz + uN*Nz
    U[0,nLev+1,j0:j1] = 2*U[0,nLev,j0:j1] - U[0,nLev-1,j0:j1]
    U[1,nLev+1,j0:j1] = -U[1,nLev,j0:j1]
    
    #extrapolate theta to bottom and top ghost nodes:
    U[2,0,j0:j1]      = 2*U[2,1,j0:j1]    - U[2,2,j0:j1]
    U[2,nLev+1,j0:j1] = 2*U[2,nLev,j0:j1] - U[2,nLev-1,j0:j1]
    
    #extrapolate density to bottom and top ghost nodes:
    U[3,0,j0:j1]      = 2*U[3,1,j0:j1]    - U[3,2,j0:j1]
    U[3,nLev+1,j0:j1] = 2*U[3,nLev,j0:j1] - U[3,nLev-1,j0:j1]
    
    #get pressure using the equation of state:
    P = Po * ( (rhoBar+U[3,:,:]) * Rd * (thetaBar+U[2,:,:]) / Po ) ** (Cp/Cv) - Pbar
    
    #set pressure on bottom ghost nodes:
    P[ 1:3,         0:FDo2    ] = P[ 1:3, nCol:nCol+FDo2 ]
    P[ 1:3, nCol+FDo2:nCol+FD ] = P[ 1:3, FDo2:FD        ]
    dpdx = Dx(P[1:3,:])
    dpdx = 3./2.*dpdx[0,:] - 1./2.*dpdx[1,:]
    rho = ( U[3,0,j0:j1] + U[3,1,j0:j1] ) / 2.
    P[0,j0:j1] = P[1,j0:j1] + ds/normGradS**2. * ( rho*g*dsdzBot + dpdx*dsdxBot )
    
    #set pressure on top ghost nodes:
    rho = ( U[3,nLev,j0:j1] + U[3,nLev+1,j0:j1] ) / 2.
    P[nLev+1,j0:j1] = P[nLev,j0:j1] - ds/dsdzBot**2. * ( rho*g*dsdzBot )
    
    #enforce periodic lateral boundary condition:
    U[ :, :,         0:FDo2    ] = U[ :, :, nCol:nCol+FDo2 ]
    U[ :, :, nCol+FDo2:nCol+FD ] = U[ :, :, FDo2:FD        ]
    
    #same thing for pressure:
    P[ :,         0:FDo2    ] = P[ :, nCol:nCol+FDo2 ]
    P[ :, nCol+FDo2:nCol+FD ] = P[ :, FDo2:FD        ]
    
    return U, P

###########################################################################

#3D arrays U, P are given to this function with correct ghost node values.

def implicitPart( U, P \
, Dx, Ds, HVx, HVs \
, nLev, nCol, i0, i1, j0, j1, Cp, Cv, Rd, g \
, dsdx, dsdz, rhoBar, drhoBarDz, dthetaBarDz ) :
    
    V = np.zeros(( 4, nLev, nCol ))
    
    dpds = Ds(P[:,j0:j1])
    
    # absU = np.abs( U[0,i0:i1,j0:j1] )
    # absSdot = np.abs( U[0,i0:i1,j0:j1]*dsdx + U[1,i0:i1,j0:j1]*dsdz )
    def hvx(U) :
        return HVx(U)
    def hvs(U) :
        return HVs(U)
    
    V[0,:,:] = -1/rhoBar * ( Dx(P[i0:i1,:]) + dpds*dsdx ) \
    + hvx(U[0,i0:i1,:]) + hvs(U[0,:,j0:j1])
    
    V[1,:,:] = -1/rhoBar * ( dpds*dsdz + U[3,i0:i1,j0:j1]*g ) \
    + hvx(U[1,i0:i1,:]) + hvs(U[1,:,j0:j1])
    
    V[2,:,:] = -U[1,i0:i1,j0:j1] * dthetaBarDz \
    + hvx(U[2,i0:i1,:]) + hvs(U[2,:,j0:j1])
    
    V[3,:,:] = -U[1,i0:i1,j0:j1] * drhoBarDz \
    - rhoBar * ( Dx(U[0,i0:i1,:])+Ds(U[0,:,j0:j1])*dsdx + Ds(U[1,:,j0:j1])*dsdz ) \
    + hvx(U[3,i0:i1,:]) + hvs(U[3,:,j0:j1])
    
    return V

###########################################################################

#3D arrays U, P are given to this function with correct ghost node values.

def explicitPart( U, P \
, Dx, Ds \
, nLev, nCol, i0, i1, j0, j1, Cv, Rd, g \
, dsdx, dsdz, rhoBar ) :
    
    V = np.zeros(( 4, nLev, nCol ))
    
    u = U[0,i0:i1,j0:j1]
    sDot = u*dsdx + U[1,i0:i1,j0:j1]*dsdz
    
    dpds = Ds(P[:,j0:j1])
    dudx = Dx(U[0,i0:i1,:])
    duds = Ds(U[0,:,j0:j1])
    dwds = Ds(U[1,:,j0:j1])
    
    tmp = U[3,i0:i1,j0:j1] / rhoBar / (rhoBar+U[3,i0:i1,j0:j1])
    
    V[0,:,:] = -u*dudx - sDot*duds \
    + tmp * ( Dx(P[i0:i1,:]) + dpds*dsdx )
    
    V[1,:,:] = -u*Dx(U[1,i0:i1,:]) - sDot*dwds \
    + tmp * ( dpds*dsdz + U[3,i0:i1,j0:j1]*g )
    
    V[2,:,:] = -u*Dx(U[2,i0:i1,:]) - sDot*Ds(U[2,:,j0:j1])
    
    V[3,:,:] = -u*Dx(U[3,i0:i1,:]) - sDot*Ds(U[3,:,j0:j1]) \
    - U[3,i0:i1,j0:j1] * ( dudx+duds*dsdx + dwds*dsdz )
    
    return V

###########################################################################
