import sys
import numpy as np

###########################################################################

def getMainIndex( FDr, FDth, nr, nth ) :
    
    if FDr == 2 :
        ii = np.arange( 1, nr-1 )
    else :
        sys.exit("\nError: FDr should be 2 for now.\n")
    
    if FDth == 2 :
        jj = np.arange( 1, nth-1 )
    elif FDth == 4 :
        jj = np.arange( 2, nth-2 )
    else :
        sys.exit("\nError: FDth should be 2 or 4 for now.\n")
    
    return ii, jj

###########################################################################

def getCenteredWeights( derivative, FD ) :
    
    if derivative == 1 :
        if FD == 2 :
            w = np.array( [ -1./2., 0., 1./2. ] )
        elif FD == 4 :
            w = np.array( [ 1./12., -2./3., 0., 2./3., -1./12. ] )
        else :
            sys.exit("\nError: FD should be 2 or 4.\n")
    elif derivative == 2 :
        if FD == 2 :
            w = np.array( [ 1., -2., 1. ] )
        else :
            sys.exit("\nError: FD should be 2 for this.\n")
    elif derivative == 4 :
        if FD == 4 :
            w = np.array( [ 1., -4., 6., -4., 1. ] )
        else :
            sys.exit("\nError: FD should be 4 for this.\n")
    else :
        sys.exit("\nError: derivative should be 1, 2, or 4.\n")
    
    return w

###########################################################################

#Apply FD operator in radial direction (r):

def Lr( U, FDr, ii, wr, dr ) :
    
    if FDr == 2 :
        U = wr[0]*U[ii-1,:] + wr[1]*U[ii,:] + wr[2]*U[ii+1,:]
    else :
        sys.exit("\nInput FDr should be 2.\n")
    
    return U / dr

###########################################################################

#Apply FD operator in angular direction (th):

def Lth( U, FDth, jj, wth, dth ) :
    
    V = np.zeros( np.shape(U) )
    
    if FDth == 2 :
        V[:,0]  = wth[0]*U[:,-1]   + wth[1]*U[:,0]  + wth[2]*U[:,1]
        V[:,jj] = wth[0]*U[:,jj-1] + wth[1]*U[:,jj] + wth[2]*U[:,jj+1]
        V[:,-1] = wth[0]*U[:,-2]   + wth[1]*U[:,-1] + wth[2]*U[:,0]
    elif FDth == 4 :
        V[:,0]  = wth[0]*U[:,-2]   + wth[1]*U[:,-1]    + wth[2]*U[:,0]  + wth[3]*U[:,1]    + wth[4]*U[:,2]
        V[:,1]  = wth[0]*U[:,-1]   + wth[1]*U[:,0]     + wth[2]*U[:,1]  + wth[3]*U[:,2]    + wth[4]*U[:,3]
        V[:,jj] = wth[0]*U[:,jj-2] + wth[1]*U[:,jj-1]  + wth[2]*U[:,jj] + wth[3]*U[:,jj+1] + wth[4]*U[:,jj+2]
        V[:,-2] = wth[0]*U[:,-4]   + wth[1]*U[:,-3]    + wth[2]*U[:,-2] + wth[3]*U[:,-1]   + wth[4]*U[:,0]
        V[:,-1] = wth[0]*U[:,-3]   + wth[1]*U[:,-2]    + wth[2]*U[:,-1] + wth[3]*U[:,0]    + wth[4]*U[:,1]
    else :
        sys.exit("\nInput FDth should be 2 or 4.\n")
    
    return V / dth

###########################################################################

def odefun( t, U \
, Dr, Dth, HVr, HVth, th, r, ii, c, rhoB, rhoT ) :
    
    U[0,0,:]  = 2*rhoB - U[0,1,:]
    U[0,-1,:] = 2*rhoT - U[0,-2,:]
    
    U[1,0,:]  = 2.*U[1,1,:]  - U[1,2,:]
    U[1,-1,:] = 2.*U[1,-2,:] - U[1,-3,:]
    
    U[2,0,:]  = 2.*U[2,1,:]  - U[2,2,:]
    U[2,-1,:] = 2.*U[2,-2,:] - U[2,-3,:]
    
    V = np.zeros( np.shape(U) )
    
    V[0,ii,:] = c * ( np.cos(th)*Dr(U[1,:,:]) - np.sin(th)/r*Dth(U[1,ii,:]) \
    + np.sin(th)*Dr(U[2,:,:]) + np.cos(th)/r*Dth(U[2,ii,:]) )
    # + HVr(U[0,:,:]) + HVth(U[0,ii,:])
    
    V[1,ii,:] = c * ( np.cos(th)*Dr(U[0,:,:]) - np.sin(th)/r*Dth(U[0,ii,:]) )
    # + HVr(U[1,:,:]) + HVth(U[1,ii,:])
    
    V[2,ii,:] = c * ( np.sin(th)*Dr(U[0,:,:]) + np.cos(th)/r*Dth(U[0,ii,:]) )
    # + HVr(U[2,:,:]) + HVth(U[2,ii,:])
    
    return V

###########################################################################