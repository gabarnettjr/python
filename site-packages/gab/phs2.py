import numpy as np
from scipy import spatial

###########################################################################

def getMN() :
    
    mn = np.array( 
    
    [ [0,0]
    
    , [1,0]
    , [0,1]
    
    , [2,0]
    , [1,1]
    , [0,2]
    
    , [3,0]
    , [2,1]
    , [1,2]
    , [0,3]
    
    , [4,0]
    , [3,1]
    , [2,2]
    , [1,3]
    , [0,4]
    
    , [5,0]
    , [4,1]
    , [3,2]
    , [2,3]
    , [1,4]
    , [0,5] ] )
    
    return mn

###########################################################################

#PHS RBF and its derivatives:

def phi( rad, x, y, rbfParam ) :
    z = ( x*x + y*y ) ** (rbfParam/2)
    z = z / rad**rbfParam
    return z

def phi_x( rad, x, y, rbfParam ) :
    z = rbfParam*x * ( x*x + y*y ) ** ((rbfParam-2)/2)
    z = z / rad**rbfParam
    return z

def phi_y( rad, x, y, rbfParam ) :
    z = rbfParam*y * ( x*x + y*y ) ** ((rbfParam-2)/2)
    z = z / rad**rbfParam
    return z

def phiHV( rad, x, y, rbfParam, K ) :
    z = np.arange( rbfParam-2*(K-1), rbfParam+2, 2 )
    z = np.prod( z**2 ) * ( x*x + y*y ) ** ((rbfParam-2*K)/2)
    z = z / rad**rbfParam
    return z

###########################################################################

#Given row-vectors x and y, where you know the values, and row
#vectors xE and yE, where you want to know the values,
#this function returns the index of the stencilSize nearest (x,y)
#points to each (xE,yE) point, shifted to the origin.

def getStencils( x, y, xE, yE, stencilSize ) :
    
    pts = np.transpose( np.vstack((x,y)) )
    tree = spatial.cKDTree(pts)
    ptsE = np.transpose( np.vstack((xE,yE)) )
    
    class stencils :
        pass
    
    stencils.idx = tree.query( ptsE, 1 )
    stencils.idx = tree.query( pts[stencils.idx[1]], stencilSize )
    stencils.rad = stencils.idx[0]
    stencils.h = np.sum( stencils.rad[:,1:5], axis=1 ) / 4
    stencils.h = np.transpose(np.tile( stencils.h, (stencilSize,1) ))
    stencils.rad = stencils.rad[:,stencilSize-1]
    stencils.rad = np.transpose( np.tile( stencils.rad, (stencilSize,1) ) )
    stencils.idx = stencils.idx[1]
    
    ##############
    
    #trying local Cartesian coordinate derivatives for annulus:
    
    X  = x[stencils.idx] . flatten()
    Y  = y[stencils.idx] . flatten()
    XC = np.transpose( np.tile( xE, (stencilSize,1) ) ) . flatten()
    YC = np.transpose( np.tile( yE, (stencilSize,1) ) ) . flatten()
    X1 = ( XC*Y - YC*X ) / np.sqrt( X**2. + Y**2. )
    X2 = ( X**2. + Y**2. - XC*X - YC*Y ) / np.sqrt( X**2. + Y**2. )
    
    dx1dx = -YC / np.sqrt( X**2. + Y**2. )
    dx1dy =  XC / np.sqrt( X**2. + Y**2. )
    ii = X1!=0.
    dx1dx[ii] = ( -YC[ii]*(XC[ii]*Y[ii]-YC[ii]*X[ii]) - X1[ii]**2.*X[ii] ) / ( X1[ii]*(X[ii]**2.+Y[ii]**2.) )
    dx1dy[ii] = (  XC[ii]*(XC[ii]*Y[ii]-YC[ii]*X[ii]) - X1[ii]**2.*Y[ii] ) / ( X1[ii]*(X[ii]**2.+Y[ii]**2.) )
    stencils.dx1dx = np.reshape( dx1dx, (len(xE),stencilSize) )
    stencils.dx1dy = np.reshape( dx1dy, (len(xE),stencilSize) )
    
    dx2dx = ( 2*X - XC ) / np.sqrt( X**2. + Y**2. )
    dx2dy = ( 2*Y - YC ) / np.sqrt( X**2. + Y**2. )
    ii = X2!=0
    dx2dx[ii] = ( (X[ii]**2.+Y[ii]**2.-XC[ii]*X[ii]-YC[ii]*Y[ii])*(2*X[ii]-XC[ii]) - X2[ii]**2.*X[ii] ) / ( X2[ii]*(X[ii]**2.+Y[ii]**2.) )
    dx2dy[ii] = ( (X[ii]**2.+Y[ii]**2.-XC[ii]*X[ii]-YC[ii]*Y[ii])*(2*Y[ii]-YC[ii]) - X2[ii]**2.*Y[ii] ) / ( X2[ii]*(X[ii]**2.+Y[ii]**2.) )
    stencils.dx2dx = np.reshape( dx2dx, (len(xE),stencilSize) )
    stencils.dx2dy = np.reshape( dx2dy, (len(xE),stencilSize) )
    
    ##############
    
    stencils.X = x[stencils.idx] - np.transpose( np.tile( xE, (stencilSize,1) ) )
    stencils.Y = y[stencils.idx] - np.transpose( np.tile( yE, (stencilSize,1) ) )
    
    stencils.nE = len(xE)
    stencils.size = stencilSize
    stencils.mn = getMN()
    
    return stencils

###########################################################################

#Writes each stencil in terms of orthogonal unit vectors e1 and e2
#instead of (1,0) and (0,1).  You might use this to get weights for
#the normal derivative along the bottom boundary, for example.

def rotateStencils( stencils, e1, e2 ) :
    
    if ( np.shape(e1)[0] != stencils.nE ) | ( np.shape(e2)[0] != stencils.nE ) :
        print("error")
        return
    
    e11 = np.transpose( np.tile( e1[:,0], (stencils.size,1) ) )
    e12 = np.transpose( np.tile( e1[:,1], (stencils.size,1) ) )
    X1 = e11*stencils.X + e12*stencils.Y
    e21 = np.transpose( np.tile( e2[:,0], (stencils.size,1) ) )
    e22 = np.transpose( np.tile( e2[:,1], (stencils.size,1) ) )
    stencils.Y = e21*stencils.X + e22*stencils.Y
    stencils.X = X1
    
    return stencils

###########################################################################

def getAmatrices( stencils, rbfParam, polyorder ) :
    
    class A :
        pass
    
    A.rbfParam = rbfParam
    A.numPoly = np.int( (polyorder+1)*(polyorder+2)/2 )
    A.matrices = np.zeros(( stencils.nE, stencils.size+A.numPoly, stencils.size+A.numPoly ))
    mn = stencils.mn[ 0:A.numPoly, : ]
    mn0 = np.tile( mn[:,0], (stencils.nE,1) )
    mn1 = np.tile( mn[:,1], (stencils.nE,1) )
    
    for i in range(stencils.size) :
        tmpX = np.transpose( np.tile( stencils.X[:,i], (stencils.size,1) ) )
        tmpY = np.transpose( np.tile( stencils.Y[:,i], (stencils.size,1) ) )
        A.matrices[ :, i, 0:stencils.size ] = phi( stencils.rad, tmpX-stencils.X, tmpY-stencils.Y, rbfParam )
        tmp = tmpX[:,0:A.numPoly]**mn0 * tmpY[:,0:A.numPoly]**mn1 / stencils.rad[:,0:A.numPoly]**(mn0+mn1)
        A.matrices[ :, i, stencils.size:stencils.size+A.numPoly ] = tmp
        A.matrices[ :, stencils.size:stencils.size+A.numPoly, i ] = tmp
    
    # A.cond = np.linalg.cond(A.matrices)
    
    return A

###########################################################################

def getWeights( stencils, A, op, K ) :
    
    b = np.zeros(( stencils.nE, stencils.size+A.numPoly, 1 ))
    
    if op == "i" :
        b[ :, 0:stencils.size, 0 ] = phi( stencils.rad, 0-stencils.X, 0-stencils.Y, A.rbfParam )
        b[ :, stencils.size, 0 ] = 1
    elif op == "1" :
        b[ :, 0:stencils.size, 0 ] = phi_x( stencils.rad, 0-stencils.X, 0-stencils.Y, A.rbfParam )
        b[ :, stencils.size+1, 0 ] = 1/stencils.rad[:,0]
    elif op == "2" :
        b[ :, 0:stencils.size, 0 ] = phi_y( stencils.rad, 0-stencils.X, 0-stencils.Y, A.rbfParam )
        b[ :, stencils.size+2, 0 ] = 1/stencils.rad[:,0]
    elif op == "hv" :
        b[ :, 0:stencils.size, 0 ] = phiHV( stencils.rad, 0-stencils.X, 0-stencils.Y, A.rbfParam, K )
        if ( K == 1 ) & ( A.numPoly > 3 ) :
            b[ :, stencils.size+3, 0 ] = 2/stencils.rad[:,0]**2
            b[ :, stencils.size+5, 0 ] = 2/stencils.rad[:,0]**2
        elif ( K == 2 ) & ( A.numPoly > 10 ) :
            b[ :, stencils.size+10, 0 ] = 24/stencils.rad[:,0]**4
            b[ :, stencils.size+12, 0 ] = 8/stencils.rad[:,0]**4
            b[ :, stencils.size+14, 0 ] = 24/stencils.rad[:,0]**4
    else :
        print("error")
        return
    
    W = np.linalg.solve( A.matrices, b )
    W = np.reshape( W[:,0:stencils.size,0], (stencils.nE,stencils.size) )
    
    return W

###########################################################################