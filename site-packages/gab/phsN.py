
import numpy as np
from scipy import spatial

###########################################################################

# NOTE: This package is not completed.  For higher than three dimensions,
# it is likely that all you want to do is find the nearest neighbors to
# a single point, and interpolate using those neighbors.  In such a case,
# the flow layed out below (finding stencils, finding A-matrices, etc.)
# is overkill, and it is easier just to evaluate the interpolant.

###########################################################################

def getMN(deg) :
    
    mn = np.zeros(deg)
    tmp = mn.copy()
    for d in range(deg):
        tmp[d] = 1
        mn = np.vstack(( mn, tmp ))
        tmp[d] = 0
    
    return mn

###########################################################################

# PHS RBF:

def phi( x, rbfParam ) :
    z = x[0]**2
    for d in range(1, len(x)):
        z = z + x[d]**2
    z = z ** (rbfParam/2)
    return z

###########################################################################

# Given points pts, where you know the values, and points ptsE, where you
# want to know the values, this function returns the index of the
# stencilSize nearest points in pts to each point in ptsE, origin-shifted.

def getStencils( pts, ptsE, stencilSize ) :
    
    tree = spatial.cKDTree(pts)
    
    class stencils :
        pass
    
    stencils.idx = tree.query( ptsE, stencilSize )
    stencils.rad = stencils.idx[0]
    stencils.idx = stencils.idx[1]
    
    stencils.PTS = np.zeros(( np.shape(ptsE,1), np.shape(ptsE,0), stencilSize ))
    for d in range(np.shape(ptsE,1)):
        stencils.PTS[d,:,:] = pts[:,d][stencils.idx] \
        - np.transpose( np.tile( ptsE[:,d], (stencilSize,1) ) )

    stencils.nE = np.shape(ptsE, 0)
    stencils.size = stencilSize
    stencils.mn = getMN( np.shape(ptsE, 1) )
    
    return stencils

###########################################################################

def getAmatrices( stencils, rbfParam, polyorder ) :
    
    class A :
        pass
    
    A.rbfParam = rbfParam
    A.numPoly = np.int( (polyorder+1)*(polyorder+2)/2 )
    A.matrices = np.zeros(( stencils.nE, stencils.size+A.numPoly, stencils.size+A.numPoly ))
    mn = stencils.mn[ 0:A.numPoly, : ]
    mn0 = np.tile( mn[:,0], (stencils.nE,1) )
    mn1 = np.tile( mn[:,1], (stencils.nE,1) )
    
    for i in range(stencils.size) :
        tmpX = np.transpose( np.tile( stencils.X[:,i], (stencils.size,1) ) )
        tmpY = np.transpose( np.tile( stencils.Y[:,i], (stencils.size,1) ) )
        A.matrices[ :, i, 0:stencils.size ] = phi( stencils.rad, tmpX-stencils.X, tmpY-stencils.Y, rbfParam )
        tmp = tmpX[:,0:A.numPoly]**mn0 * tmpY[:,0:A.numPoly]**mn1 / stencils.rad[:,0:A.numPoly]**(mn0+mn1)
        A.matrices[ :, i, stencils.size:stencils.size+A.numPoly ] = tmp
        A.matrices[ :, stencils.size:stencils.size+A.numPoly, i ] = tmp
    
    # A.cond = np.linalg.cond(A.matrices)
    
    return A

###########################################################################

def getWeights( stencils, A, op, K ) :
    
    b = np.zeros(( stencils.nE, stencils.size+A.numPoly, 1 ))
    
    if op == "i" :
        b[ :, 0:stencils.size, 0 ] = phi( stencils.rad, 0-stencils.X, 0-stencils.Y, A.rbfParam )
        b[ :, stencils.size, 0 ] = 1
    elif op == "1" :
        b[ :, 0:stencils.size, 0 ] = phi_x( stencils.rad, 0-stencils.X, 0-stencils.Y, A.rbfParam )
        b[ :, stencils.size+1, 0 ] = 1/stencils.rad[:,0]
    elif op == "2" :
        b[ :, 0:stencils.size, 0 ] = phi_y( stencils.rad, 0-stencils.X, 0-stencils.Y, A.rbfParam )
        b[ :, stencils.size+2, 0 ] = 1/stencils.rad[:,0]
    elif op == "hv" :
        b[ :, 0:stencils.size, 0 ] = phiHV( stencils.rad, 0-stencils.X, 0-stencils.Y, A.rbfParam, K )
        if ( K == 1 ) & ( A.numPoly > 3 ) :
            b[ :, stencils.size+3, 0 ] = 2/stencils.rad[:,0]**2
            b[ :, stencils.size+5, 0 ] = 2/stencils.rad[:,0]**2
        elif ( K == 2 ) & ( A.numPoly > 10 ) :
            b[ :, stencils.size+10, 0 ] = 24/stencils.rad[:,0]**4
            b[ :, stencils.size+12, 0 ] = 8/stencils.rad[:,0]**4
            b[ :, stencils.size+14, 0 ] = 24/stencils.rad[:,0]**4
    else :
        print("error")
        return
    
    W = np.linalg.solve( A.matrices, b )
    W = np.reshape( W[:,0:stencils.size,0], (stencils.nE,stencils.size) )
    
    return W

###########################################################################
