import numpy as np
import argparse
import matplotlib.pyplot as plt

###########################################################################

def parseInput() :
    
    parser = argparse.ArgumentParser \
    ( formatter_class = argparse.ArgumentDefaultsHelpFormatter )
    
    parser.add_argument("--verticalCoordinate", help="type of vertical \
    coordinate to use.  Please choose 'height' or 'pressure'" \
    , type=str, default="height")

    parser.add_argument("--topoType", help="choose the type of topography \
    function to use.  Choices are 'trig' or 'GA'." \
    , type=str, default="trig")

    parser.add_argument("--hf", help="height factor which determines \
    where the initial condition bubble is positioned vertically." \
    , type=np.float64, default=2.)

    parser.add_argument("--kx", help="horizontal squashing of IC" \
    , type=np.float64, default=1.)
    
    parser.add_argument("--ky", help="vertical squashing of IC" \
    , type=np.float64, default=1.)
    
    parser.add_argument("--halfWidth", help="half of the width of \
    the domain that you want to plot (in radians)." \
    , type=str, default="np.pi/3e3")
    
    parser.add_argument("--wavesOnly", help="use this if you want \
    to use the linearized system of equations" \
    , action="store_true")
    
    parser.add_argument("--saveArrays", help="use this if you want to \
    save arrays" \
    , action="store_true")
    
    parser.add_argument("--saveContours", help="use this if you want to \
    save contours" \
    , action="store_true")
    
    parser.add_argument("--plotFromSaved", help="use this to plot from \
    previous save" \
    , action="store_true")
    
    parser.add_argument("--dynamicColorbar", help="use this if you want \
    the colorbar to change as time progresses" \
    , action="store_true")
    
    parser.add_argument("--whatToPlot", help="choose between P, rho, T, \
    u, v, pi, theta, curl, div, and vMag" \
    , type=str,        default="P")
    
    parser.add_argument("--saveDel", help="time between prints.  " \
    + "Note: this is also the time between saveArrays, " \
    + "and the time between saveContours, if these are turned on."
    , type=np.int64,   default=100)
    
    parser.add_argument("--testCase", help="the only values that works \
    right now are 'bubble' and 'densityCurrent'" \
    , type=str,        default='bubble')
    
    parser.add_argument("--innerRadius", help="average inner radius of \
    deformed annulus" \
    , type=np.float64, default=6.371e6)
    
    parser.add_argument("--outerRadius", help="outer radius of deformed \
    annulus" \
    , type=np.float64, default=6.381e6)
    
    parser.add_argument("--tf", help="final simulation time in seconds" \
    , type=np.int64,   default=1000)
    
    parser.add_argument("--steepness", help="controls steepness of initial \
    Gaussian bell(s)" \
    , type=np.float64, default=7e-7)
    
    parser.add_argument("--ang1", help="angle telling where the initial" \
    + " temperature perturbation should be centered" \
    , type=str,        default="np.pi/2.")
    
    parser.add_argument("--ang2", help="angle telling where the second" \
    + " Gaussian bell should be centered" \
    , type=str,        default="")
    
    parser.add_argument("--ang3", help="angle telling where the third" \
    + " Gaussian bell should be centered" \
    , type=str,        default="")
    
    parser.add_argument("--amp", help="amplitude of trigonometric \
    topography function, or height of Gaussian topography function" \
    , type=np.int64,   default=1000)
    
    parser.add_argument("--frq", help="frequency of trigonometric \
    topography function" \
    , type=np.int64,   default=3001)
    
    parser.add_argument("--mlv", help="0:interfaces, 1:mid-levels" \
    , type=np.int64,   default=1)
    
    parser.add_argument("--phs", help="exponent in PHS RBF" \
    , type=np.int64,   default=5)
    
    parser.add_argument("--pol", help="polynomial degree" \
    , type=np.int64,   default=3)
    
    parser.add_argument("--stc", help="stencil size" \
    , type=np.int64,   default=7)
    
    parser.add_argument("--clusterType", help="type of angular clustering.  \
    Choose 'linear' or 'geometric' if you want clustering." \
    , type=str,        default='geometric')
    
    parser.add_argument("--clusterStrength", help="controls clustering of nodes in \
    the angular direction.  Given as a percentage." \
    , type=np.int64,   default=1)
    
    parser.add_argument("--rks", help="number (3 or 4) of Runge-Kutta \
    stages" \
    , type=np.int64,   default=3)
    
    parser.add_argument("--nlv", help="total number of radial levels" \
    , type=np.int64,   default=50)
    
    parser.add_argument("--dti", help="inverse of delta t (integer)" \
    , type=np.int64,   default=4)
    
    parser.add_argument("--verticallyLagrangian", help="use vertically \
    Lagrangian coordinate" \
    , action="store_true")

    parser.add_argument("--noRadialHV", help="use this if you want to \
    turn off the radial hyperviscosity (dissipation)" \
    , action="store_true")
    
    parser.add_argument("--noAngularHV", help="use this if you want to \
    turn off the angular hyperviscosity (dissipation)" \
    , action="store_true")
    
    parser.add_argument("--angularFD", help="use this if you want \
    conventional finite differences (FD8) in the angular direction" \
    , action="store_true")
    
    parser.add_argument("--plotNodes", help="use this if you want to just \
    plot the nodes and exit" \
    , action="store_true")
    
    parser.add_argument("--plotHeightCoord", help="use this if you want \
    to just plot the height coordinate transformation functions and exit" \
    , action="store_true")
    
    parser.add_argument("--plotRadii", help="use this if you want to just \
    plot the perturbed radii and exit" \
    , action="store_true")
    
    args = parser.parse_args()
    
    return args

###########################################################################

def getSavestring( wavesOnly \
, testCase, innerRadius, outerRadius, tf, saveDel, steepness, amp, frq \
, verticallyLagrangian, phs, pol, stc, clusterType, clusterStrength \
, rks, nlv, dti ) :
    
    if wavesOnly :
        saveString = 'waves'
    else :
        saveString = testCase
    
    saveString = saveString \
    + '_ri'   + '{0:1.0f}' . format(innerRadius) \
    + '_ro'   + '{0:1.0f}' . format(outerRadius) \
    + '_tf'   + '{0:1d}'   . format(np.int(tf)) \
    + '_sd'   + '{0:1d}'   . format(saveDel) \
    + '_stpn' + '{0:1.0e}' . format(steepness) \
    + '_amp'  + '{0:1d}'   . format(np.int(amp)) \
    + '_frq'  + '{0:1d}'   . format(np.int(frq))          #folder name
    
    if verticallyLagrangian :
        saveString = saveString + '/' + 'VL'
    else :
        saveString = saveString + '/' + 'VE'
    
    saveString = saveString \
    + '_phs' + '{0:1d}' . format(phs) \
    + '_pol' + '{0:1d}' . format(pol) \
    + '_stc' + '{0:1d}' . format(stc) \
    + '_'    + '{0:1s}' . format(clusterType) \
    + '_pct' + '{0:1d}' . format(clusterStrength) \
    + '_rks' + '{0:1d}' . format(rks) \
    + '_nlv' + '{0:1d}' . format(nlv) \
    + '_dti' + '{0:1d}' . format(dti) \
    + '/'                                                        #file name
    
    return saveString

###########################################################################

def getExnerPressureAndPotentialTemperatureFunctions( testCase \
, innerRadius, Cp, g, e, null ) :
    
    if ( testCase == "bubble" ) | ( testCase == "densityCurrent" ) :
        def exnerPressure( r ) :
            return 1. - g / Cp / 300. * ( r - innerRadius )
        def inverseExnerPressure( pi ) :
            return innerRadius + 300. * Cp * ( 1. - pi ) / g
        def potentialTemperature( r ) :
            return 300. * e
        def potentialTemperatureDerivative( r ) :
            return null
    elif ( testCase == "mountainWaves" ) | ( testCase == "igw" ) :
        theta0 = 300.
        N = .01
        def exnerPressure( r ) :
            return 1. + g**2/Cp/theta0/N**2 \
            * ( np.exp(-N**2/g*(r-innerRadius)) - 1. )
        def inverseExnerPressure( pi ) :
            return innerRadius - g/N**2. \
            * np.log( 1. + (pi-1.) * Cp * 300. * N**2 / g**2. )
        def potentialTemperature( r ) :
            return theta0 * np.exp( N**2/g * (r-innerRadius) )
        def potentialTemperatureDerivative( r ) :
            return theta0 * N**2/g * np.exp( N**2/g * (r-innerRadius) )
    else :
        raise ValueError("testCase should be 'bubble', 'densityCurrent', \
'mountainWaves', or 'igw'.")
    
    return exnerPressure, inverseExnerPressure \
    , potentialTemperature, potentialTemperatureDerivative

###########################################################################

def getRadiiOnPressureCoordinateLevels( nlv, nth, th \
, rSurf, exnerPressure, inverseExnerPressure \
, outerRadius, Po, Rd, Cp ) :
    
    piSurf = exnerPressure( rSurf(th) )
    piTop  = exnerPressure( outerRadius )
    
    pSurf = Po * piSurf ** (Cp/Rd)         #hydrostatic pressure at surface
    pTop  = Po * piTop  ** (Cp/Rd)             #hydrostatic pressure at top
    
    sTop = pTop / Po                          #value of s on upper boundary
    ds = ( 1. - sTop ) / ( nlv - 2 )
    s = np.linspace( sTop-ds/2., 1.+ds/2., nlv )
    s = np.flipud( s )
    ss = np.tile( s, (nth,1) ).T
    
    def A(s) :
        return ( 1. - s ) / ( 1. - sTop ) * sTop
    def B(s) :
        return ( s - sTop ) / ( 1. - sTop )
    
    p = A(ss) * Po + B(ss) * np.tile(pSurf,(nlv,1))
    
    pi = ( p / Po ) ** (Rd/Cp)
    
    rr = inverseExnerPressure( pi )
    
    # outerRadius = np.max( rr )
    
    return rr, s, ds

###########################################################################

def fastBackgroundStates( phi \
, potentialTemperature, exnerPressure, potentialTemperatureDerivative \
, g, innerRadius, Po, Cp, Rd ) :
    
    r = phi / g + innerRadius
    
    thetaBar = potentialTemperature( r )
    piBar = exnerPressure( r )
    dthetaBarDr = potentialTemperatureDerivative( r )
    
    Tbar = piBar * thetaBar
    Pbar = Po * piBar ** (Cp/Rd)
    rhoBar = Pbar / Rd / Tbar
    
    dpiBarDr = -g / Cp / thetaBar                    #hydrostatic condition
    dTbarDr = piBar * dthetaBarDr + thetaBar * dpiBarDr
    dPbarDr = Po * Cp/Rd * piBar**(Cp/Rd-1.) * dpiBarDr
    drhoBarDr = ( dPbarDr - Rd*rhoBar*dTbarDr ) / ( Rd * Tbar )
    
    return Pbar, rhoBar, Tbar, drhoBarDr, dTbarDr

###########################################################################

def getInitialConditions( testCase, nlv, nth, initialCondition \
, xx, yy, kx, ky, rr, thth, innerRadius, ang1, Cp, Cv, Rd, g, Po ) :
    
    #Variables are in this order: u,v,T,rho,phi,P.
    U = np.zeros(( 6, nlv, nth ))
    
    #Hydrostatic background states and initial theta perturbation:
    if ( testCase == 'bubble' ) | ( testCase == "densityCurrent" ) :
        thetaBar = 300. * np.ones(( nlv, nth ))
        dthetaBarDr = np.zeros(( nlv, nth ))
        if testCase == "bubble" :
            thetaPrime = 2.*( initialCondition(xx,yy,kx,ky) - 1. )
        elif testCase == "densityCurrent" :
            thetaPrime = -20.*( initialCondition(xx,yy,kx,ky) - 1. )
        else :
            thetaPrime = np.zeros(( nlv, nth ))
        piBar = 1. - g / Cp / thetaBar * ( rr - innerRadius )
    elif ( testCase == "mountainWaves" ) | ( testCase == "igw" ) :
        N = .01
        theta0 = 300.
        thetaBar = theta0 * np.exp( N**2/g * (rr-innerRadius) )
        dthetaBarDr = theta0 * N**2/g * np.exp( N**2/g * (rr-innerRadius) )
        piBar = 1. + g**2/Cp/theta0/N**2 * ( np.exp(-N**2/g*(rr-innerRadius)) - 1. )
        thetaC = .01
        hC = 10000.
        aC = 5000.
        xC = -50000.
        if testCase == "mountainWaves" :
            thetaPrime = np.zeros(( nlv, nth ))
        elif testCase == "igw" :
            ind1 = ( thth > ang1 ) & ( thth < ang1 + np.pi )
            ind2 = ( thth > ang1+np.pi )
            ell = np.zeros( np.shape(thth) )
            ell[ind1] = rr[ind1] * (  ang1 - thth[ind1] )
            ell[ind2] = rr[ind2] * (  (ang1+2.*np.pi) - thth[ind2] )
            thetaPrime = thetaC * np.sin(np.pi*(rr-innerRadius)/hC) \
            / ( 1. + ((ell-xC)/aC)**2. )
        else :
            raise ValueError("expecting 'mountainWaves' or 'igw' here")
    else :
        raise ValueError("Use 'bubble', 'densityCurrent', \
'mountainWaves', or 'igw'")
    
    piPrime = np.zeros(( nlv, nth ))
    Tbar = piBar * thetaBar
    Tprime = ( piBar + piPrime ) * ( thetaBar + thetaPrime ) - Tbar
    Pbar = Po * piBar ** (Cp/Rd)
    Pprime = Po * ( piBar + piPrime ) ** (Cp/Rd) - Pbar
    rhoBar = Pbar / Rd / Tbar
    rhoPrime = ( Pbar + Pprime ) / Rd / ( Tbar + Tprime ) - rhoBar
    phiBar = g * ( rr - innerRadius )
    
    #Assignment of initial conditions:
    if ( testCase == "mountainWaves" ) | ( testCase == "igw" ) :
        U[0,:,:] =  20. * np.sin(thth)
        U[1,:,:] = -20. * np.cos(thth)
    U[2,:,:] = Tprime
    U[3,:,:] = rhoPrime
    U[4,:,:] = phiBar
    
    #Radial derivatives of hydrostatic background states:
    #For derivation, please see "Background States" section of
    #https://www.overleaf.com/read/jpddcpggwyhh
    dpiBarDr = -g / Cp / thetaBar
    dTbarDr = piBar * dthetaBarDr + thetaBar * dpiBarDr
    dPbarDr = Po * Cp/Rd * piBar**(Cp/Rd-1.) * dpiBarDr
    drhoBarDr = ( dPbarDr - Rd*rhoBar*dTbarDr ) / ( Rd * Tbar )
    
    return U, thetaBar, piBar, Tbar, Pbar, rhoBar, phiBar \
    , dTbarDr, drhoBarDr

###########################################################################

def verticalRemap( U, z, Z, nLev, V ) : #used only in vertically Lagrangian
    """
    Interpolate columns of U from z to Z
    nLev is the number of interior levels of U
    """
    
    z = np.tile( z, (np.shape(U)[0],1,1) )
    Z = np.tile( Z, (np.shape(U)[0],1,1) )
    # V = np.zeros( np.shape(U) )
    # #linear on bottom:
    # z0 = z[:,0,:]
    # z1 = z[:,1,:]
    # ZZ = Z[:,0,:]
    # V[:,0,:] = \
    #   ( ZZ - z1 ) * U[:,0,:] / ( z0 - z1 ) \
    # + ( ZZ - z0 ) * U[:,1,:] / ( z1 - z0 )
    # #linear on interior:
    # z0 = z[:,0:nLev+0,:]
    # z1 = z[:,2:nLev+2,:]
    # ZZ = Z[:,1:nLev+1,:]
    # V[:,1:nLev+1,:] = \
    #   ( ZZ - z1 ) * U[:,0:nLev+0,:] / ( z0 - z1 ) \
    # + ( ZZ - z0 ) * U[:,2:nLev+2,:] / ( z1 - z0 )
    # #linear on top:
    # z0 = z[:,-2,:]
    # z1 = z[:,-1,:]
    # ZZ = Z[:,-1,:]
    # V[:,-1,:] = \
    #   ( ZZ - z1 ) * U[:,-2,:] / ( z0 - z1 ) \
    # + ( ZZ - z0 ) * U[:,-1,:] / ( z1 - z0 )
    #quadratic on bottom:
    z0 = z[:,0,:]
    z1 = z[:,1,:]
    z2 = z[:,2,:]
    ZZ = Z[:,0,:]
    V[:,0,:] = \
      ( ZZ - z1 ) * ( ZZ - z2 ) * U[:,0,:] / ( z0 - z1 ) / ( z0 - z2 ) \
    + ( ZZ - z0 ) * ( ZZ - z2 ) * U[:,1,:] / ( z1 - z0 ) / ( z1 - z2 ) \
    + ( ZZ - z0 ) * ( ZZ - z1 ) * U[:,2,:] / ( z2 - z0 ) / ( z2 - z1 )
    #quadratic on interior:
    z0 = z[:,0:nLev+0,:]
    z1 = z[:,1:nLev+1,:]
    z2 = z[:,2:nLev+2,:]
    ZZ = Z[:,1:nLev+1,:]
    V[:,1:nLev+1,:] = \
      ( ZZ - z1 ) * ( ZZ - z2 ) * U[:,0:nLev+0,:] / ( z0 - z1 ) / ( z0 - z2 ) \
    + ( ZZ - z0 ) * ( ZZ - z2 ) * U[:,1:nLev+1,:] / ( z1 - z0 ) / ( z1 - z2 ) \
    + ( ZZ - z0 ) * ( ZZ - z1 ) * U[:,2:nLev+2,:] / ( z2 - z0 ) / ( z2 - z1 )
    #quadratic on top:
    z0 = z[:,nLev-1,:]
    z1 = z[:,nLev+0,:]
    z2 = z[:,nLev+1,:]
    ZZ = Z[:,nLev+1,:]
    V[:,nLev+1,:] = \
      ( ZZ - z1 ) * ( ZZ - z2 ) * U[:,nLev-1,:] / ( z0 - z1 ) / ( z0 - z2 ) \
    + ( ZZ - z0 ) * ( ZZ - z2 ) * U[:,nLev+0,:] / ( z1 - z0 ) / ( z1 - z2 ) \
    + ( ZZ - z0 ) * ( ZZ - z1 ) * U[:,nLev+1,:] / ( z2 - z0 ) / ( z2 - z1 )
    return V
    #############################
    # #VERY SLOW PHS re-map (to verify fast quadratic one above):
    # V = np.zeros( np.shape(U) )
    # pages = np.shape(U)[0]
    # for j in range( nCol ) :
    #     W = phs1.getDM( x=z[:,j], X=Z[:,j], m=0 \
    #     , phsDegree=phs, polyDegree=pol, stencilSize=stc )
    #     for i in range(pages) :
    #         V[i,:,j] = W.dot( U[i,:,j] )
    # return V

###########################################################################

#Use this if (u,v,T,rho) are all stored at layer midpoints (default):

def setGhostNodesMidLevels( U \
, NxBot, NyBot, NxTop, NyTop \
, TxBot, TyBot, TxTop, TyTop \
, fastBackgroundStates, e, null \
, someFactor, bottomFactor, topFactor \
, stcB, Wlam, Rd, cosTh, sinTh \
, wIinner, wEinner, wDinner, wHinner \
, wIouter, wEouter, wDouter, wHouter \
, innerRadius, outerRadius, rB, rT, g ) :
    
    #Enforce phi = g*(rB-innerRadius) on bottom boundary:
    RHS = g * ( rB - innerRadius )
    U[4,0,:] = ( RHS - wIinner[1:stcB].dot(U[4,1:stcB,:]) ) / wIinner[0]
    
    #Enforce phi = g*(outerRadius-innerRadius) on top boundary:
    RHS = g * ( outerRadius - innerRadius )
    U[4,-1,:] = ( RHS - wIouter[1:stcB].dot(U[4,-2:-stcB-1:-1,:]) ) / wIouter[0]
    
    #Get background states on possibly changing geopotential levels:
    Pbar, rhoBar, Tbar, drhoBarDr, dTbarDr \
    = fastBackgroundStates( U[4,:,:] )
    
    #################################
    
    #Use equation of state (P=rho*Rd*T) to get pressure on interior nodes:
    U[5,1:-1,:] = ( rhoBar[1:-1,:] + U[3,1:-1,:] ) * Rd \
    * ( Tbar[1:-1,:] + U[2,1:-1,:] ) - Pbar[1:-1,:]
    
    #################################
    
    #Inner boundary:
    
    phi = wIinner.dot( U[4,0:stcB,:] )
    dphidlam = Wlam.dot( phi.T ).T
    dphids = wDinner.dot( U[4,0:stcB,:] )
    dsdx = g / dphids * ( cosTh + dphidlam/(phi+g*innerRadius)*sinTh )
    dsdy = g / dphids * ( sinTh - dphidlam/(phi+g*innerRadius)*cosTh )
    denominator = dsdx * NxBot[0,:] + dsdy * NyBot[0,:]
    dthdx = -g * sinTh / ( phi + g*innerRadius )
    dthdy =  g * cosTh / ( phi + g*innerRadius )
    RHS = wHinner.dot( U[5,1:stcB+1,:] )          #extrap P to bottom bndry
    RHS = - Wlam.dot(RHS.T).T * ( dthdx*NxBot[0,:] + dthdy*NyBot[0,:] )
    rho = wHinner.dot( U[3,1:stcB+1,:] )        #extrap rho to bottom bndry
    RHS = RHS - g * (cosTh*NxBot[0,:]+sinTh*NyBot[0,:]) * rho
    
    # tmp = ( phi + g*innerRadius ) ** 2.
    # someFactor = dphidlam * dphids / ( tmp + dphidlam**2. )
    # bottomFactor = - tmp * dphids / ( tmp + dphidlam**2. )
    
    # #Enforce dP/dN=-rho*gDotN on inner boundary:
    # #For derivation, please see "Pressure Boundary Condition" section of
    # #https://www.overleaf.com/read/jpddcpggwyhh
    # RHS = wHinner.dot( U[5,1:stcB+1,:] )          #extrap P to bottom bndry
    # RHS = Wlam.dot(RHS.T).T#someFactor*dP/dlam on bottom bndry
    # rho = wHinner.dot( U[3,1:stcB+1,:] )        #extrap rho to bottom bndry
    # RHS = RHS + bottomFactor * rho                  #full RHS of Neumann BC
    U[5,0,:] = ( RHS - wDinner[1:stcB].dot(U[5,1:stcB,:]) ) / wDinner[0]
    
    #Get uN and uT near bottom boundary:
    uN = U[0,1:stcB,:]   * NxBot + U[1,1:stcB,:]   * NyBot
    uT = U[0,1:stcB+1,:] * TxBot + U[1,1:stcB+1,:] * TyBot
    
    #Extrapolate uT to inner ghost nodes:
    uT = wEinner.dot( uT )
    
    #Enforce uN=0 on inner boundary:
    uN = - wIinner[1:stcB].dot(uN) / wIinner[0]
    
    #Combine uT and uN on inner ghost nodes to get u and v there:
    U[0,0,:] = uT*TxBot[0,:] + uN*NxBot[0,:]
    U[1,0,:] = uT*TyBot[0,:] + uN*NyBot[0,:]
    
    #Extrapolate T to bottom ghost nodes:
    U[2,0,:] = wEinner.dot( U[2,1:stcB+1,:] )
    
    #Extrapolate rho to bottom ghost nodes:
    U[3,0,:] = ( U[5,0,:] + Pbar[0,:] ) / Rd \
    / ( U[2,0,:] + Tbar[0,:] ) - rhoBar[0,:]
    # U[3,0,:] = wEinner.dot( U[3,1:stcB+1,:] )

    #################################
    
    #Outer boundary:
    
    phi = wIouter.dot( U[4,-1:-stcB-1:-1,:] )
    dphidlam = Wlam.dot( phi.T ).T
    dphids = wDouter.dot( U[4,-1:-stcB-1:-1,:] )
    dsdx = g / dphids * ( cosTh + dphidlam/(phi+g*innerRadius)*sinTh )
    dsdy = g / dphids * ( sinTh - dphidlam/(phi+g*innerRadius)*cosTh )
    denominator = dsdx * NxTop[0,:] + dsdy * NyTop[0,:]
    dthdx = -g * sinTh / ( phi + g*innerRadius )
    dthdy =  g * cosTh / ( phi + g*innerRadius )
    RHS = wHouter.dot( U[5,-2:-stcB-2:-1,:] )        #extrap P to top bndry
    RHS = - Wlam.dot(RHS.T).T * ( dthdx*NxTop[0,:] + dthdy*NyTop[0,:] )
    rho = wHouter.dot( U[3,-2:-stcB-2:-1,:] )      #extrap rho to bottom bndry
    RHS = RHS - g * (cosTh*NxTop[0,:]+sinTh*NyTop[0,:]) * rho
    
    # #Enforce dP/dN=-rho*gDotN on outer boundary:
    # rho = wHouter.dot( U[3,-2:-stcB-2:-1,:] )      #extrap rho to top bndry
    # RHS = topFactor * rho                           #full RHS of Neumann BC
    U[5,-1,:] = ( RHS - wDouter[1:stcB].dot( U[5,-2:-(stcB+1):-1,:] ) ) / wDouter[0]
    
    #Get uN and uT near top boundary:
    uN = U[0,-2:-(stcB+1):-1,:] * NxTop + U[1,-2:-(stcB+1):-1,:] * NyTop
    uT = U[0,-2:-(stcB+2):-1,:] * TxTop + U[1,-2:-(stcB+2):-1,:] * TyTop
    
    #Extrapolate uT to outer ghost nodes:
    uT = wEouter.dot( uT )
    
    #Enforce uN=0 on outer boundary:
    uN = - wIouter[1:stcB].dot(uN) / wIouter[0]
    
    #Combine uT and uN on outer ghost nodes to get u and v on outer ghost nodes:
    U[0,-1,:] = uT*TxTop[0,:] + uN*NxTop[0,:]
    U[1,-1,:] = uT*TyTop[0,:] + uN*NyTop[0,:]
    
    #Extrapolate T to outer ghost nodes:
    U[2,-1,:] = wEouter.dot( U[2,-2:-(stcB+2):-1,:] )
    
    #Extrapolate rho to outer ghost nodes:
    U[3,-1,:] = ( U[5,-1,:] + Pbar[-1,:] ) / Rd \
    / ( U[2,-1,:] + Tbar[-1,:] ) - rhoBar[-1,:]
    # U[3,-1,:] = wEouter.dot( U[3,-2:-(stcB+2):-1,:] )
    
    return U, Pbar, rhoBar, Tbar, drhoBarDr, dTbarDr

###########################################################################

def odefunFast( t, U, dUdt \
, setGhostNodes, Ds, Dlam, HV \
, drdx, drdy \
, phiBar, sDot \
, Rd, Cv, g, innerRadius \
, verticallyLagrangian, verticalCoordinate ) :
    
    #Set ghost node values and get background states on correct levels:
    U, Pbar, rhoBar, Tbar, drhoBarDr, dTbarDr = setGhostNodes( U )
    
    dthdx = -g * drdy / ( U[4,:,:] + g*innerRadius )
    dthdy =  g * drdx / ( U[4,:,:] + g*innerRadius )
    
    uDotGradTh = U[0,:,:] * dthdx + U[1,:,:] * dthdy
    uDotGradR  = U[0,:,:] * drdx  + U[1,:,:] * drdy
    rhoInv = 1. / ( rhoBar + U[3,:,:] )
    
    dudlam   = Dlam( U[0,:,:] )
    duds     = Ds(   U[0,:,:] )
    dvdlam   = Dlam( U[1,:,:] )
    dvds     = Ds(   U[1,:,:] )
    dphidlam = Dlam( U[4,:,:] )
    dphids   = Ds(   U[4,:,:] )
    dPdlam   = Dlam( U[5,:,:] )
    dPds     = Ds(   U[5,:,:] )
    
    dsdx = g / dphids * ( drdx \
    + dphidlam / ( U[4,:,:] + g*innerRadius ) * drdy )
    
    dsdy = g / dphids * ( drdy \
    - dphidlam / ( U[4,:,:] + g*innerRadius ) * drdx )
    
    uDotGradS = U[0,:,:] * dsdx + U[1,:,:] * dsdy
    
    if not verticallyLagrangian :
        if verticalCoordinate == "height" :
            sDot = uDotGradS
        else :
            raise ValueError("The definition of sDot in the Eulerian \
pressure coordinate is complicated, and requires \
integration.  It has not yet been implemented.")
    
    divU = duds*dsdx + dudlam*dthdx + dvds*dsdy + dvdlam*dthdy
    
    dUdt[0,1:-1,:] = ( -uDotGradTh * dudlam - sDot * duds \
    - rhoInv * ( dPds*dsdx + dPdlam*dthdx \
    + U[3,:,:] * g * drdx ) ) [1:-1,:] \
    + HV( U[0,:,:] )
    
    dUdt[1,1:-1,:] = ( -uDotGradTh * dvdlam - sDot * dvds \
    - rhoInv * ( dPds*dsdy + dPdlam*dthdy \
    + U[3,:,:] * g * drdy ) ) [1:-1,:] \
    + HV( U[1,:,:] )
    
    dUdt[2,1:-1,:] = ( -uDotGradTh * Dlam(U[2,:,:]) - sDot * Ds(U[2,:,:]) \
    - uDotGradR * dTbarDr - Rd/Cv * ( Tbar + U[2,:,:] ) * divU ) [1:-1,:] \
    + HV( U[2,:,:] )
    
    dUdt[3,1:-1,:] = ( -uDotGradTh * Dlam(U[3,:,:]) - sDot * Ds(U[3,:,:]) \
    - uDotGradR * drhoBarDr - ( rhoBar + U[3,:,:] ) * divU ) [1:-1,:] \
    + HV( U[3,:,:] )
    
    dUdt[4,1:-1,:] = ( ( uDotGradS - sDot ) * dphids ) [1:-1,:] \
    + HV( U[4,:,:] - phiBar )
    
    return dUdt

###########################################################################

def odefunEuler( t, U, dUdt \
, setGhostNodes, Dx, Dy, HV \
, drdx, drdy \
, Tbar, rhoBar, dTbarDr, drhoBarDr, Rd, Cv, g ) :
    
    #Get P everywhere, and set ghost node values for all other variables:
    U = setGhostNodes(U)[0]
    
    #Things that will be used more than once:
    rhoInv = 1. / ( rhoBar + U[3,:,:] )
    buoyancy = U[3,:,:] * rhoInv * g
    uDotGradR = U[0,:,:] * drdx + U[1,:,:] * drdy
    dudx = Dx(U[0,:,:])
    dvdy = Dy(U[1,:,:])
    divU = dudx + dvdy
    
    dUdt[0,1:-1,:] = ( -U[0,:,:]*dudx - U[1,:,:]*Dy(U[0,:,:]) \
    - rhoInv * Dx(U[5,:,:]) - buoyancy * drdx ) [1:-1,:] \
    + HV(U[0,:,:])                                                   #du/dt
    
    dUdt[1,1:-1,:] = ( -U[0,:,:]*Dx(U[1,:,:]) - U[1,:,:]*dvdy \
    - rhoInv * Dy(U[5,:,:]) - buoyancy * drdy ) [1:-1,:] \
    + HV(U[1,:,:])                                                   #dv/dt
    
    dUdt[2,1:-1,:] = ( -U[0,:,:]*Dx(U[2,:,:]) - U[1,:,:]*Dy(U[2,:,:]) \
    - uDotGradR * dTbarDr - Rd/Cv * (Tbar+U[2,:,:]) * divU ) [1:-1,:] \
    + HV(U[2,:,:])                                                   #dT/dt
    
    dUdt[3,1:-1,:] = ( -U[0,:,:]*Dx(U[3,:,:]) - U[1,:,:]*Dy(U[3,:,:]) \
    - uDotGradR * drhoBarDr - 1./rhoInv * divU ) [1:-1,:] \
    + HV(U[3,:,:])                                                 #drho/dt
    
    return dUdt

###########################################################################

def odefunWaves( t, U, dUdt \
, setGhostNodes, Dx, Dy, HV \
, drdxAll, drdyAll \
, Tbar, rhoBar, dTbarDr, drhoBarDr, Rd, Cv, g ) :
    
    U = setGhostNodes(U)
    
    uDotGradR = U[0,:,:] * drdxAll + U[1,:,:] * drdyAll
    divU = Dx(U[0,:,:]) + Dy(U[1,:,:])
    
    dUdt[0,1:-1,:] = ( - 1. / rhoBar * Dx(U[4,:,:]) \
    - U[3,:,:] / rhoBar * g * drdxAll ) [1:-1,:] \
    + HV(U[0,:,:])
    
    dUdt[1,1:-1,:] = ( - 1. / rhoBar * Dy(U[4,:,:]) \
    - U[3,:,:] / rhoBar * g * drdyAll ) [1:-1,:] \
    + HV(U[1,:,:])
    
    dUdt[2,1:-1,:] = ( -uDotGradR * dTbarDr \
    - Rd/Cv * Tbar * divU ) [1:-1,:] \
    + HV(U[2,:,:])
    
    dUdt[3,1:-1,:] = ( -uDotGradR * drhoBarDr \
    - rhoBar * divU ) [1:-1,:] \
    + HV(U[3,:,:])
    
    return dUdt

###########################################################################


def plotSomething( U, t \
, testCase, Dx, Dy \
, whatToPlot, xx, yy, thth, th \
, Rd, Po, Cp, xB, yB, xT, yT, innerRadius, outerRadius, fig \
, dynamicColorbar, ang1, halfWidth, g \
, Tbar, rhoBar, thetaBar, Pbar, piBar, phiBar ) :
    
    if whatToPlot == "P" :
        tmp = U[5,:,:]
        cvec = np.arange( -72.5, 37.5, 5 )
    elif whatToPlot == "pi" :
        tmp = ( (U[5,:,:]+Pbar) / Po ) ** (Rd/Cp) - piBar
        cvec = np.arange(-37e-5, 25e-5, 2.e-5 )
    elif whatToPlot == "u" :
        tmp = U[0,:,:]
        cvec = np.arange( -8.5, 9.5, 1. )
    elif whatToPlot == "v" :
        tmp = U[1,:,:]
        cvec = np.arange( -8.5, 12.5, 1 )
    elif whatToPlot == "curl" :
        tmp = Dx(U[1,:,:]) - Dy(U[0,:,:])
        cvec = np.arange( -.0525, .0525+.005, .005 )
    elif whatToPlot == "div" :
        tmp = Dx(U[0,:,:]) + Dy(U[1,:,:])
        cvec = np.arange( -8.5e-4, 12.5e-4, 1e-4 )
    elif whatToPlot == "rho" :
        tmp = U[3,:,:]
        cvec = np.arange( -35.5e-4, 5.5e-4, 1e-4 )
    elif whatToPlot == "T" :
        tmp = U[2,:,:]
        cvec = np.arange( -.15, 1.85, .1 )
    elif whatToPlot == "vMag" :
        tmp = np.sqrt( U[0,:,:]**2. + U[1,:,:]**2. )
        cvec = np.arange( -.25, 13.5, .5 )
    elif whatToPlot == "theta" :
        tmp = (U[2,:,:]+Tbar) / ((U[5,:,:]+Pbar)/Po)**(Rd/Cp) - thetaBar
        cvec = np.arange( -.15, 2.25, .1 )
    elif whatToPlot == "phi" :
        tmp = U[4,:,:] - phiBar
        cvec = np.arange( -31, 13, 2 )
    else :
        raise ValueError("Invalid field to plot.  \
Choose P, u, v, curl, div, rho, T, or vMag.")
    
    if dynamicColorbar :
        cvec = 20       #overwrite vector cvec with number (20) of contours
    
    rr = U[4,:,:] / g + innerRadius
    xx = rr * np.cos(thth)
    yy = rr * np.sin(thth)
    
    xx = np.vstack(( xx.T, xx[:,0] )).T
    yy = np.vstack(( yy.T, yy[:,0] )).T
    th = np.hstack(( th, th[0]+2.*np.pi ))
    tmp = np.vstack(( tmp.T, tmp[:,0] )).T
    xB = np.hstack(( xB, xB[0] ))
    yB = np.hstack(( yB, yB[0] ))
    xT = np.hstack(( xT, xT[0] ))
    yT = np.hstack(( yT, yT[0] ))
    
    ind1 = ( th > ang1+2*np.pi-halfWidth )
    ind2 =  ( th > ang1 ) & ( th < ang1+halfWidth )
    xx = np.hstack(( xx[:,ind1], xx[:,ind2] ))
    yy = np.hstack(( yy[:,ind1], yy[:,ind2] ))
    tmp = np.hstack(( tmp[:,ind1], tmp[:,ind2] ))
    xB = np.hstack(( xB[ind1], xB[ind2] ))
    yB = np.hstack(( yB[ind1], yB[ind2] ))
    xT = np.hstack(( xT[ind1], xT[ind2] ))
    yT = np.hstack(( yT[ind1], yT[ind2] ))
    
    plt.contourf( xx, yy, tmp, cvec )        #contour on computational mesh
    # plt.plot( xx.flatten(), yy.flatten(), 'r.', markersize=2 )
    plt.plot( xB, yB, 'r-', xT, yT, 'r-' )
    
    plt.axis('image')
    if ( testCase == "igw" ) | ( testCase == "densityCurrent" ) :
        cp = plt.colorbar(orientation='horizontal')
    else :
        cb = plt.colorbar(orientation='vertical')
    
    fig.savefig( '{0:04d}'.format(np.int(np.round(t)+1e-12)) \
    + '.png', bbox_inches = 'tight' )                 #save figure as a png
    
    plt.clf()

###########################################################################
