import sys
import numpy as np

sys.path.append( '../site-packages' )
from gab import phs1

###########################################################################

#Get number of angular levels so that the angular spacing and radial
#spacing are nearly equal along the inner circle:

def getNth( innerRadius, outerRadius, nr ):
    
    nth = np.int(np.round( 2*np.pi * innerRadius * (nr-2)/(outerRadius-innerRadius) ))
    
    # nth = np.int( nth / 2. )
    
    return nth

###########################################################################

def fastAngles( innerRadius, outerRadius, nlv, center, style, pct ) :
    
    th0 = center
    # th1 = np.array([th0])
    # th2 = np.array([th0])
    th1 = np.zeros(( 10000 ))
    th2 = np.zeros(( 10000 ))
    th1[0] = center
    th2[0] = center
    
    d0 = ( outerRadius - innerRadius ) / ( nlv - 2 )
    d = d0
    
    k = 1
    while np.abs(th1[k-1]-th0) < np.pi :
        th1[k] = th1[k-1] + d/innerRadius
        th2[k] = th2[k-1] - d/innerRadius
        if style == "geometric" :
            d = ( 1. + pct ) * d
        elif style == "linear" :
            d = d + pct*d0
        else :
            raise ValueError("set style='linear' or style='geometric'")
        k = k + 1
    
    if style == "geometric" :
        d = d / ( 1. + pct )
    else :
        d = d - pct*d0
    
    th1 = th1[0:k-1]
    th2 = np.flipud( th2[1:k-1] ) + 2.*np.pi
    x1 = innerRadius*np.cos(th1[-1])
    y1 = innerRadius*np.sin(th1[-1])
    x2 = innerRadius*np.cos(th2[0])
    y2 = innerRadius*np.sin(th2[0])
    dis = np.sqrt( (x2-x1)**2. + (y2-y1)**2. )
    # dis = innerRadius * ( th2[0] - th1[-1] )
    if dis < d :
        th = np.hstack(( th1[0:-1], center+np.pi, th2[1:] ))
    elif dis > 1.5*d :
        th = np.hstack(( th1, center+np.pi, th2 ))
    else :
        th = np.hstack(( th1, th2 ))
    
    return th

###########################################################################

def getAnglesAndNumlevels( innerRadius, outerRadius \
, numSlices, style, center, nMin, increment ) :
    
    delTh = 2.*np.pi / numSlices
    angle = center - np.pi - delTh/2.
    
    th = np.linspace( angle, angle+delTh, nMin )
    angle = angle + delTh
    n = nMin + increment
    if style == "quadratic" :
        increment = increment + 1
    
    for i in range( int(numSlices/2) ) :
        tmp = np.linspace( angle, angle+delTh, n )
        th = np.hstack(( th, tmp[1:] ))
        angle = angle + delTh
        n = n + increment
        if style == "quadratic" :
            increment = increment + 1
    
    if style == "quadratic" :
        increment = increment - 1
        n = n - increment
        increment = increment - 1
        n = n - increment
    else :
        n = n - 2*increment
    
    for i in range( int(numSlices/2) - 1 ) :
        tmp = np.linspace( angle, angle+delTh, n )
        th = np.hstack(( th, tmp[1:] ))
        angle = angle + delTh
        n = n - increment
        if style == "quadratic" :
            n = n + 1
            increment = increment - 1
    
    th = th[0:-1]
    ell = len(th)
    x1 = innerRadius * np.cos( th[np.int(ell/2)] )
    y1 = innerRadius * np.sin( th[np.int(ell/2)] )
    x2 = innerRadius * np.cos( th[np.int(ell/2)+1] )
    y2 = innerRadius * np.sin( th[np.int(ell/2)+1] )
    d = np.sqrt( (x2-x1)**2. + (y2-y1)**2. )
    numLevels = np.int(np.round( (outerRadius-innerRadius) / d ) ) + 2
    
    return th, numLevels

###########################################################################

def getClusteredAngles( innerRadius=1, outerRadius=2 \
, nlv=14, style="linear", center=np.pi/2, nMin=2, increment=1 ) :
    """
    set style="linear" for a linear clustering of nodes toward center
    set style="quadratic" for a quadratic clustering of nodes toward center
    """
    numSlices = 2
    numLevels = 0
    
    while numLevels < nlv :
        th, numLevels = getAnglesAndNumlevels( innerRadius, outerRadius \
        , numSlices, style, center, nMin, increment  )
        numSlices = numSlices + 2
    
    th, numLevels = getAnglesAndNumlevels( innerRadius, outerRadius \
    , numSlices-4, style, center, nMin, increment )
    
    return th

###########################################################################

#Get the function that defines the irregular inner boundary.
#amp and frq control the amplitude and frequency of the boundary curve.

def getTopoFunc( rBot, rTop, amp, frq ) :
    
    def rSurf( th ) :
        return rBot + amp*np.cos(frq*th)
    
    def rSurfPrime( th ) :
        phs = 9
        pol = 7
        stc = 17
        if len(np.shape(th)) == 2 :
            tmp = th[0,:]
        elif len(np.shape(th)) == 1 :
            tmp = th
        else :
            raise ValueError("th should have either 1 or 2 dimensions.")
        W = phs1.getPeriodicDM( period=2*np.pi, x=tmp, X=tmp, m=1 \
        , phsDegree=phs, polyDegree=pol, stencilSize=stc )
        return np.transpose( W.dot( np.transpose(rSurf(th)) ) )
        # return -amp*frq*np.sin(frq*th)
    
    return rSurf, rSurfPrime

###########################################################################

def getHeightCoordinate( rBot, rTop, rSurf, rSurfPrime ) :
    
    def s( r, th ) :
        return ( r - rSurf(th) ) / ( rTop - rSurf(th) ) * ( rTop - rBot ) + rBot
    
    def dsdth( r, th ) :
        return rSurfPrime(th) * ( r - rTop ) * ( rTop - rBot ) / ( rTop - rSurf(th) )**2.
    
    def dsdr( r, th ) :
        return ( rTop - rBot ) / ( rTop - rSurf(th) )
    
    return s, dsdth, dsdr

###########################################################################

#thth and ss define a mesh on an annulus, and this returns radii in the
#untransformed space.

def getRadii( thth, ss, rBot, rTop, rSurf ) :
    
    rr = (ss-rBot) / (rTop-rBot) * (rTop-rSurf(thth)) + rSurf(thth)
    
    return rr

###########################################################################

def getTangentsAndNormals( th, stc, rSurf, dsdr, dsdth ) :
    
    NxTop = np.tile( np.cos(th), (stc-1,1) )
    NyTop = np.tile( np.sin(th), (stc-1,1) )
    
    TxTop = np.tile( -np.sin(th), (stc,1) )
    TyTop = np.tile(  np.cos(th), (stc,1) )
    
    rBot     = rSurf(th)
    dsdrBot  = dsdr( rBot, th )
    dsdthBot = dsdth( rBot, th )
    
    dsdxBot = np.cos(th) * dsdrBot - np.sin(th)/rBot * dsdthBot
    dsdyBot = np.sin(th) * dsdrBot + np.cos(th)/rBot * dsdthBot
    tmp = np.sqrt( dsdxBot**2. + dsdyBot**2. )
    NxBot = dsdxBot / tmp
    NyBot = dsdyBot / tmp
    
    # #factor needed to enforce Neumann BC for P:
    # alpha = NxBot * np.sin(th) - NyBot * np.cos(th)
    # beta  = NxBot * np.cos(th) + NyBot * np.sin(th)
    # someFactor = alpha / ( beta*rBot*dsdrBot - alpha*dsdthBot )
    
    #same factor, but after some algebraic simplification:
    #Detailed derivation: https://www.overleaf.com/read/twxqpctrcmwz
    normGradS2 = dsdrBot**2. + (dsdthBot/rBot)**2.
    someFactor = -dsdthBot / rBot**2. / normGradS2
    
    normgradsBot = np.sqrt( normGradS2 )
    normgradsTop = np.abs( dsdrBot )
    
    TxBot = np.tile( -NyBot, (stc,1) )
    TyBot = np.tile(  NxBot, (stc,1) )
    
    NxBot = np.tile( NxBot, (stc-1,1) )
    NyBot = np.tile( NyBot, (stc-1,1) )
    
    return NxBot, NyBot, NxTop, NyTop \
    , TxBot, TyBot, TxTop, TyTop, someFactor \
    , normgradsBot, normgradsTop

###########################################################################
