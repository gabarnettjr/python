import numpy as np

###########################################################################

#Get number of angular levels so that the angular spacing and radial
#spacing are nearly equal along the inner circle, and the number of angular
#levels is odd (for periodic PS):

def getNth( innerRadius, outerRadius, nr ):
    
    nth = np.int(np.round( 2*np.pi * innerRadius * (nr-2)/(outerRadius-innerRadius) ))
    
    if np.mod( nth, 2 ) == 0 :
        nth = nth + 1
    
    return nth

###########################################################################

#Get the function that defines the irregular inner boundary.
#amp and frq control the amplitude and frequency of the boundary curve.

def getTopoFunc( rBot, rTop, amp, frq ) :
    
    amp = amp * ( rTop - rBot )
    
    def rSurf( th ) :
        return rBot + amp*np.cos(frq*th)
    
    def rSurfPrime( th ) :
        return -amp*frq*np.sin(frq*th)
    
    return rSurf, rSurfPrime

###########################################################################

def getHeightCoordinate( rBot, rTop, amp, frq ) :
    
    rSurf, rSurfPrime = getTopoFunc( rBot, rTop, amp, frq )
    
    def s( r, th ) :
        return ( r - rSurf(th) ) / ( rTop - rSurf(th) ) * ( rTop - rBot ) + rBot
    
    def dsdth( r, th ) :
        return rSurfPrime(th) * ( r - rTop ) * ( rTop - rBot ) / ( rTop - rSurf(th) )**2.
    
    def dsdr( r, th ) :
        return ( rTop - rBot ) / ( rTop - rSurf(th) )
    
    return rSurf, rSurfPrime, s, dsdth, dsdr

###########################################################################

#thth and ss define a mesh on an annulus, and this returns radii in the
#untransformed space.

def getRadii( thth, ss, rBot, rTop, rSurf ) :
    
    rr = (ss-rBot) / (rTop-rBot) * (rTop-rSurf(thth)) + rSurf(thth)
    
    return rr

###########################################################################

def getTangentsAndNormals( th, stc, rSurf, dsdr, dsdth ) :
    
    NxTop = np.tile( np.cos(th), (stc-1,1) )
    NyTop = np.tile( np.sin(th), (stc-1,1) )

    TxTop = np.tile( -np.sin(th), (stc,1) )
    TyTop = np.tile(  np.cos(th), (stc,1) )

    rBot     = rSurf(th)
    dsdrBot  = dsdr( rBot, th )
    dsdthBot = dsdth( rBot, th )

    NxBot = np.cos(th) * dsdrBot - np.sin(th)/rBot * dsdthBot
    NyBot = np.sin(th) * dsdrBot + np.cos(th)/rBot * dsdthBot
    tmp = np.sqrt( NxBot**2. + NyBot**2. )
    NxBot = NxBot / tmp
    NyBot = NyBot / tmp

    alpha = NxBot * np.sin(th) - NyBot * np.cos(th)
    beta  = NxBot * np.cos(th) + NyBot * np.sin(th)

    TxBot = np.tile( -NyBot, (stc,1) )
    TyBot = np.tile(  NxBot, (stc,1) )

    NxBot = np.tile( NxBot, (stc-1,1) )
    NyBot = np.tile( NyBot, (stc-1,1) )

    someFactor = alpha / ( beta*rBot*dsdrBot - alpha*dsdthBot )
    
    return NxBot, NyBot, NxTop, NyTop \
    , TxBot, TyBot, TxTop, TyTop, someFactor

###########################################################################