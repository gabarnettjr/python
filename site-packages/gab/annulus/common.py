import sys
import numpy as np

sys.path.append( '../site-packages' )
from gab import phs1

###########################################################################

#Get number of angular levels so that the angular spacing and radial
#spacing are nearly equal along the inner circle, and the number of angular
#levels is odd (for periodic PS):

def getNth( innerRadius, outerRadius, nr ):
    
    nth = np.int(np.round( 2*np.pi * innerRadius * (nr-2)/(outerRadius-innerRadius) ))
    
    if np.mod( nth, 2 ) == 0 :
        nth = nth + 1
    
    return nth

###########################################################################

#Get the function that defines the irregular inner boundary.
#amp and frq control the amplitude and frequency of the boundary curve.

def getTopoFunc( rBot, rTop, amp, frq ) :
    
    # amp = amp * ( rTop - rBot )
    
    def rSurf( th ) :
        return rBot + amp*np.cos(frq*th)
    
    def rSurfPrime( th ) :
        phsA = 11
        polA = 9
        stcA = 31
        if len(np.shape(th)) == 2 :
            tmp = th[0,:]
        elif len(np.shape(th)) == 1 :
            tmp = th
        else :
            sys.exit("\nError: th should have either 1 or 2 dimensions.\n")
        W = phs1.getPeriodicDM( period=2*np.pi, x=tmp, X=tmp, m=1 \
        , phsDegree=phsA, polyDegree=polA, stencilSize=stcA )
        return np.transpose( W.dot( np.transpose(rSurf(th)) ) )
        # return -amp*frq*np.sin(frq*th)
    
    return rSurf, rSurfPrime

###########################################################################

def getHeightCoordinate( rBot, rTop, rSurf, rSurfPrime ) :
    
    def s( r, th ) :
        return ( r - rSurf(th) ) / ( rTop - rSurf(th) ) * ( rTop - rBot ) + rBot
    
    def dsdth( r, th ) :
        return rSurfPrime(th) * ( r - rTop ) * ( rTop - rBot ) / ( rTop - rSurf(th) )**2.
    
    def dsdr( r, th ) :
        return ( rTop - rBot ) / ( rTop - rSurf(th) )
    
    return s, dsdth, dsdr

###########################################################################

#thth and ss define a mesh on an annulus, and this returns radii in the
#untransformed space.

def getRadii( thth, ss, rBot, rTop, rSurf ) :
    
    rr = (ss-rBot) / (rTop-rBot) * (rTop-rSurf(thth)) + rSurf(thth)
    
    return rr

###########################################################################

def getTangentsAndNormals( th, stc, rSurf, dsdr, dsdth ) :
    
    NxTop = np.tile( np.cos(th), (stc-1,1) )
    NyTop = np.tile( np.sin(th), (stc-1,1) )

    TxTop = np.tile( -np.sin(th), (stc,1) )
    TyTop = np.tile(  np.cos(th), (stc,1) )

    rBot     = rSurf(th)
    dsdrBot  = dsdr( rBot, th )
    dsdthBot = dsdth( rBot, th )

    NxBot = np.cos(th) * dsdrBot - np.sin(th)/rBot * dsdthBot
    NyBot = np.sin(th) * dsdrBot + np.cos(th)/rBot * dsdthBot
    tmp = np.sqrt( NxBot**2. + NyBot**2. )
    NxBot = NxBot / tmp
    NyBot = NyBot / tmp

    # alpha = NxBot * np.sin(th) - NyBot * np.cos(th)
    # beta  = NxBot * np.cos(th) + NyBot * np.sin(th)

    TxBot = np.tile( -NyBot, (stc,1) )
    TyBot = np.tile(  NxBot, (stc,1) )

    NxBot = np.tile( NxBot, (stc-1,1) )
    NyBot = np.tile( NyBot, (stc-1,1) )

    # someFactor = alpha / ( beta*rBot*dsdrBot - alpha*dsdthBot )
    
    # someFactor = -dsdthBot / ( (rBot*dsdrBot)**2. + 1. )
    
    normGradS2 = dsdrBot**2. + (1./rBot*dsdthBot)**2.
    someFactor = -dsdthBot / rBot**2. / normGradS2
    
    return NxBot, NyBot, NxTop, NyTop \
    , TxBot, TyBot, TxTop, TyTop, someFactor

###########################################################################