import numpy as np

###########################################################################

#Get number of angular levels so that the angular spacing and radial
#spacing are nearly equal along the inner circle, and the number of angular
#levels is odd (for periodic PS):

def getNth( innerRadius, outerRadius, nr ):
    
    nth = np.int(np.round( 2*np.pi * innerRadius * (nr-2)/(outerRadius-innerRadius) ))
    
    if np.mod( nth, 2 ) == 0 :
        nth = nth + 1
    
    return nth

###########################################################################

#Get the function that defines the irregular inner boundary.
#amp and frq control the amplitude and frequency of the boundary curve.

def getTopoFunc( rBot, rTop, amp, frq ) :
    
    amp = amp * ( rTop - rBot )
    
    def rSurf( th ) :
        return rBot + amp*np.cos(frq*th)
    
    def rSurfPrime( th ) :
        return -amp*frq*np.sin(frq*th)
    
    return rSurf, rSurfPrime

###########################################################################

def getHeightCoordinate( rBot, rTop, amp, frq ) :
    
    rSurf, rSurfPrime = getTopoFunc( rBot, rTop, amp, frq )
    
    def s( r, th ) :
        return ( r - rSurf(th) ) / ( rTop - rSurf(th) ) * ( rTop - rBot ) + rBot
    
    def dsdth( r, th ) :
        return rSurfPrime(th) * ( r - rTop ) * ( rTop - rBot ) / ( rTop - rSurf(th) )**2.
    
    def dsdr( r, th ) :
        return ( rTop - rBot ) / ( rTop - rSurf(th) )
    
    return rSurf, rSurfPrime, s, dsdth, dsdr

###########################################################################

#thth and ss define a mesh on an annulus, and this returns radii in the
#untransformed space.

def getRadii( thth, ss, rBot, rTop, rSurf ) :
    
    rr = (ss-rBot) / (rTop-rBot) * (rTop-rSurf(thth)) + rSurf(thth)
    
    return rr

###########################################################################

def neumannBC( r, th, dsdr, dsdth \
, dfdx, dfdy ) :
    
    dsdx = np.cos(th)*dsdr - np.sin(th)/r*dsdth
    dsdy = np.sin(th)*dsdr + np.cos(th)/r*dsdth
    
    normGradS = np.sqrt( dsdx**2. + dsdy**2. )
    Nx = dsdx / normGradS
    Ny = dsdy / normGradS
    
    alpha = Nx*np.sin(th) - Ny*np.cos(th)
    beta  = Nx*np.cos(th) + Ny*np.sin(th)
    
    G = dfdx*Nx + dfdy*Ny
    
    return alpha, beta, G

###########################################################################