import sys
import numpy as np

sys.path.append( '../site-packages' )
from gab import phs1

###########################################################################

#Get number of angular levels so that the angular spacing and radial
#spacing are nearly equal along the inner circle:

def getNth( innerRadius, outerRadius, nr ):
    
    nth = np.int(np.round( 2*np.pi * innerRadius * (nr-2)/(outerRadius-innerRadius) ))
    
    # nth = np.int( nth / 2. )
    
    return nth

###########################################################################

def getClusteredAngles( numSlices \
, style="linear", center=np.pi/2, nMin=3, increment=1 ) :
    """
    set style="linear" for a linear clustering of nodes toward center
    set style="quadratic" for a quadratic clustering of nodes toward center
    """
    if np.mod( numSlices, 2 ) != 0 :
        raise ValueError("numSlices must be an even integer.")
    
    delTh = 2.*np.pi / numSlices
    angle = center + np.pi - delTh/2.
    
    th = np.linspace( angle, angle+delTh, nMin )
    angle = angle + delTh
    n = nMin + increment
    if style == "quadratic" :
        increment = increment + 1
    
    for i in range( int( numSlices / 2 ) ) :
        # print("n={0:1d}, inc={1:1d}".format(n,increment))
        tmp = np.linspace( angle, angle+delTh, n )
        th = np.hstack(( th, tmp[1:] ))
        angle = angle + delTh
        n = n + increment
        if style == "quadratic" :
            increment = increment + 1
    
    if style == "quadratic" :
        increment = increment - 1
        n = n - increment
        increment = increment - 1
        n = n - increment
    else :
        n = n - 2*increment
    
    for i in range( int( numSlices / 2 ) - 1 ) :
        # print("n={0:1d}, inc={1:1d}".format(n,increment))
        tmp = np.linspace( angle, angle+delTh, n )
        th = np.hstack(( th, tmp[1:] ))
        angle = angle + delTh
        n = n - increment
        if style == "quadratic" :
            n = n + 1
            increment = increment - 1
    
    return th[0:-1]
    

###########################################################################

#Get the function that defines the irregular inner boundary.
#amp and frq control the amplitude and frequency of the boundary curve.

def getTopoFunc( rBot, rTop, amp, frq ) :
    
    def rSurf( th ) :
        return rBot + amp*np.cos(frq*th)
    
    def rSurfPrime( th ) :
        phs = 9
        pol = 7
        stc = 17
        if len(np.shape(th)) == 2 :
            tmp = th[0,:]
        elif len(np.shape(th)) == 1 :
            tmp = th
        else :
            raise ValueError("th should have either 1 or 2 dimensions.")
        W = phs1.getPeriodicDM( period=2*np.pi, x=tmp, X=tmp, m=1 \
        , phsDegree=phs, polyDegree=pol, stencilSize=stc )
        return np.transpose( W.dot( np.transpose(rSurf(th)) ) )
        # return -amp*frq*np.sin(frq*th)
    
    return rSurf, rSurfPrime

###########################################################################

def getHeightCoordinate( rBot, rTop, rSurf, rSurfPrime ) :
    
    def s( r, th ) :
        return ( r - rSurf(th) ) / ( rTop - rSurf(th) ) * ( rTop - rBot ) + rBot
    
    def dsdth( r, th ) :
        return rSurfPrime(th) * ( r - rTop ) * ( rTop - rBot ) / ( rTop - rSurf(th) )**2.
    
    def dsdr( r, th ) :
        return ( rTop - rBot ) / ( rTop - rSurf(th) )
    
    return s, dsdth, dsdr

###########################################################################

#thth and ss define a mesh on an annulus, and this returns radii in the
#untransformed space.

def getRadii( thth, ss, rBot, rTop, rSurf ) :
    
    rr = (ss-rBot) / (rTop-rBot) * (rTop-rSurf(thth)) + rSurf(thth)
    
    return rr

###########################################################################

def getTangentsAndNormals( th, stc, rSurf, dsdr, dsdth ) :
    
    NxTop = np.tile( np.cos(th), (stc-1,1) )
    NyTop = np.tile( np.sin(th), (stc-1,1) )
    
    TxTop = np.tile( -np.sin(th), (stc,1) )
    TyTop = np.tile(  np.cos(th), (stc,1) )
    
    rBot     = rSurf(th)
    dsdrBot  = dsdr( rBot, th )
    dsdthBot = dsdth( rBot, th )
    
    dsdxBot = np.cos(th) * dsdrBot - np.sin(th)/rBot * dsdthBot
    dsdyBot = np.sin(th) * dsdrBot + np.cos(th)/rBot * dsdthBot
    tmp = np.sqrt( dsdxBot**2. + dsdyBot**2. )
    NxBot = dsdxBot / tmp
    NyBot = dsdyBot / tmp
    
    # #factor needed to enforce Neumann BC for P:
    # alpha = NxBot * np.sin(th) - NyBot * np.cos(th)
    # beta  = NxBot * np.cos(th) + NyBot * np.sin(th)
    # someFactor = alpha / ( beta*rBot*dsdrBot - alpha*dsdthBot )
    
    #same factor, but after some algebraic simplification:
    #Detailed derivation: https://www.overleaf.com/read/twxqpctrcmwz
    normGradS2 = dsdrBot**2. + (1./rBot*dsdthBot)**2.
    someFactor = -dsdthBot / rBot**2. / normGradS2
    
    normgradsBot = np.sqrt( normGradS2 )
    normgradsTop = dsdrBot
    
    TxBot = np.tile( -NyBot, (stc,1) )
    TyBot = np.tile(  NxBot, (stc,1) )
    
    NxBot = np.tile( NxBot, (stc-1,1) )
    NyBot = np.tile( NyBot, (stc-1,1) )
    
    return NxBot, NyBot, NxTop, NyTop \
    , TxBot, TyBot, TxTop, TyTop, someFactor \
    , normgradsBot, normgradsTop

###########################################################################
