import sys
import numpy as np

sys.path.append( '../site-packages' )
from gab import phs1

###########################################################################

#Get number of angular levels so that the angular spacing and radial
#spacing are nearly equal along the inner circle:

def getNth( innerRadius, outerRadius, nr ):
    
    nth = np.int(np.round( 2*np.pi * innerRadius * (nr-2)/(outerRadius-innerRadius) ))
    
    # nth = np.int( nth / 2. )
    
    return nth

###########################################################################

def fastAngles( innerRadius, outerRadius, nlv \
, center, style, clusterStrength ) :
    """
    This function distributes angles which will be used in a mesh on
    an annulus.  Where the angles are most concentrated, the angular
    and radial distance to the nearest neighbor should be about equal.
    
    innerRadius and outerRadius define the annulus, and determine how close
    the angles should be to one another when they are clustered the most.
    
    nlv is the total number of vertical levels, including the two ghost
    levels.
    
    center is the central angle, where nodes will be concentrated.
    
    style should be either "linear" or "geometric".  In the linear case,
    the distance between nodes steadily increases, always by the same
    ammount.  In the geometric case, the distance between nodes is
    multiplied by (1+clusterStrength/100) as you move away from center.
    
    clusterStrength determines the strength of the clustering.  For linear
    clustering, the distance between nodes is steadily increased by
    clusterStrength*delta, where delta is the smallest distance between
    nodes.  In the geometric case, the next node is placed a distance
    (1+clusterStrength/100)*delta from the current node, where delta is
    the distance between the current node and the previous node.
    """    
    th0 = center
    th1 = np.zeros(( 10000 ))
    th2 = np.zeros(( 10000 ))
    th1[0] = center
    th2[0] = center
    
    d0 = ( outerRadius - innerRadius ) / ( nlv - 2 )
    d = d0
    
    k = 1
    while np.abs( th1[k-1] - th0 ) < np.pi :
        th1[k] = th1[k-1] + d/innerRadius
        th2[k] = th2[k-1] - d/innerRadius
        if style == "geometric" :
            d = ( 1. + clusterStrength ) * d
        elif style == "linear" :
            d = d + clusterStrength*d0
        else :
            raise ValueError("set style='linear' or style='geometric'")
        k = k + 1
    
    if style == "geometric" :
        d = d / ( 1. + clusterStrength )
    else :
        d = d - clusterStrength*d0
    
    th1 = th1[0:k-1]
    th2 = np.flipud( th2[1:k-1] ) + 2.*np.pi
    # x1 = innerRadius*np.cos(th1[-1])
    # y1 = innerRadius*np.sin(th1[-1])
    # x2 = innerRadius*np.cos(th2[0])
    # y2 = innerRadius*np.sin(th2[0])
    # dis = np.sqrt( (x2-x1)**2. + (y2-y1)**2. )
    dis = innerRadius * ( th2[0] - th1[-1] )
    if dis < d :
        th = np.hstack(( th1[0:-1], center+np.pi, th2[1:] ))
    elif dis > 1.5*d :
        th = np.hstack(( th1, center+np.pi, th2 ))
    else :
        th = np.hstack(( th1, th2 ))
    
    return th

###########################################################################

#Get the function that defines the irregular inner boundary.
#amp controls the height of the topography in all cases.
#frq controls the frequency if topoType='trig'.
#k controls how steep the curve is if topoType='GA'.

def getTopoFunc( rBot, rTop, topoType, amp, frq, k, ang1 ) :
    
    if topoType == "trig" :
        
        def rSurf( th ) :
            return rBot + amp*np.cos(frq*th)
        
    elif topoType == "GA" :
        
        def rSurf( th ) :
            x = rBot * np.cos(th)
            y = rBot * np.sin(th)
            xc = rBot * np.cos(ang1)
            yc = rBot * np.sin(ang1)
            return rBot + amp * np.exp( -k*( (x-xc)**2. + (y-yc)**2. ) ) \
            * np.cos( frq * th ) ** 2.
        
    else :
        
        raise ValueError( "Choose topoType='trig' or topoType='GA'." )
    
    def rSurfPrime( th ) :
        #Accurate approximation matrix W for approximating rSurfPrime(th):
        phs = 9
        pol = 7
        stc = 17
        if len(np.shape(th)) == 2 :
            tmp = th[0,:].copy()
        elif len(np.shape(th)) == 1 :
            tmp = th.copy()
        else :
            raise ValueError("th should have either 1 or 2 dimensions.")
        W = phs1.getPeriodicDM( period=2*np.pi, x=tmp, X=tmp, m=1 \
        , phsDegree=phs, polyDegree=pol, stencilSize=stc )
        return W.dot( rSurf(th).T ).T
    
    return rSurf, rSurfPrime

###########################################################################

def getHeightCoordinate( rBot, rTop, rSurf, rSurfPrime ) :
    
    def s( r, th ) :
        return ( r - rSurf(th) ) / ( rTop - rSurf(th) ) * ( rTop - rBot ) \
        + rBot
    
    def dsdth( r, th ) :
        return rSurfPrime(th) * ( r - rTop ) * ( rTop - rBot ) \
        / ( rTop - rSurf(th) )**2.
    
    def dsdr( r, th ) :
        return ( rTop - rBot ) / ( rTop - rSurf(th) )
    
    return s, dsdth, dsdr

###########################################################################

#thth and ss define a mesh on an annulus, and this returns radii in the
#untransformed space.

def getRadiiOnHeightCoordinateLevels( thth, ss, rBot, rTop, rSurf ) :
    
    rr = (ss-rBot) / (rTop-rBot) * (rTop-rSurf(thth)) + rSurf(thth)
    
    return rr

###########################################################################

def getTangentsAndNormals( th, stc, rSurf, dsdr, dsdth, g ) :
    
    NxTop = np.tile( np.cos(th), (stc-1,1) )
    NyTop = np.tile( np.sin(th), (stc-1,1) )
    
    TxTop = np.tile( -np.sin(th), (stc,1) )
    TyTop = np.tile(  np.cos(th), (stc,1) )
    
    rBot     = rSurf(th)
    dsdrBot  = dsdr( rBot, th )
    dsdthBot = dsdth( rBot, th )
    
    dsdxBot = np.cos(th) * dsdrBot - np.sin(th)/rBot * dsdthBot
    dsdyBot = np.sin(th) * dsdrBot + np.cos(th)/rBot * dsdthBot
    tmp = np.sqrt( dsdxBot**2. + dsdyBot**2. )
    NxBot = dsdxBot / tmp
    NyBot = dsdyBot / tmp
    
    # #factor needed to enforce Neumann BC for P:
    # alpha = NxBot * np.sin(th) - NyBot * np.cos(th)
    # beta  = NxBot * np.cos(th) + NyBot * np.sin(th)
    # someFactor = alpha / ( beta*rBot*dsdrBot - alpha*dsdthBot )
    
    #same factor, but after some algebraic simplification:
    #Detailed derivation: https://www.overleaf.com/read/twxqpctrcmwz
    normGradS2 = dsdrBot**2. + (dsdthBot/rBot)**2.
    someFactor = -dsdthBot / rBot**2. / normGradS2
    
    normgradsBot = np.sqrt( normGradS2 )
    normgradsTop = np.abs( dsdrBot )
    
    bottomFactor = -g * dsdrBot / normgradsBot**2.
    topFactor    = -g * dsdrBot / normgradsTop**2.         #dsdrBot=dsdrTop
    
    TxBot = np.tile( -NyBot, (stc,1) )
    TyBot = np.tile(  NxBot, (stc,1) )
    
    NxBot = np.tile( NxBot, (stc-1,1) )
    NyBot = np.tile( NyBot, (stc-1,1) )
    
    return NxBot, NyBot, NxTop, NyTop \
    , TxBot, TyBot, TxTop, TyTop \
    , someFactor, bottomFactor, topFactor

###########################################################################
