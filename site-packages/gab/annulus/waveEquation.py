import numpy as np

###########################################################################

def getSavestring( c, innerRadius, outerRadius, tf, saveDel, exp, amp, frq \
, mlv, phs, pol, stc, ptb, rkStages, ns, dt ) :
    
    saveString                                  \
    = 'c'    + '{0:1.3f}' . format(c)           \
    + '_ri'  + '{0:1.0f}' . format(innerRadius) \
    + '_ro'  + '{0:1.0f}' . format(outerRadius) \
    + '_tf'  + '{0:1d}'   . format(np.int(tf))  \
    + '_sd'  + '{0:1d}'   . format(saveDel)     \
    + '_exp' + '{0:1d}'   . format(np.int(exp)) \
    + '_amp' + '{0:1.2f}' . format(amp)         \
    + '_frq' + '{0:1d}'   . format(frq)                        #folder name

    saveString = saveString + '/'                    \
    + 'mlv'   + '{0:1d}'  . format(mlv)              \
    + '_phs'   + '{0:1d}' . format(phs)              \
    + '_pol'   + '{0:1d}' . format(pol)              \
    + '_stc'   + '{0:1d}' . format(stc)              \
    + '_ptb'   + '{0:1d}' . format(np.int(ptb*100.)) \
    + '_rk'    + '{0:1d}' . format(rkStages)         \
    + '_ns'    + '{0:1d}' . format(ns)               \
    + '_dtinv' + '{0:1d}' . format(np.int(1./dt))    \
    + '/'                                                        #file name
    
    return saveString

###########################################################################

#Use this if P, u, and v are all stored at layer midpoints:

def setGhostNodesMidLevels( U \
, NxBot, NyBot, NxTop, NyTop \
, TxBot, TyBot, TxTop, TyTop \
, someFactor, stcB \
, Wlam, wIinner, wEinner, wDinner, wIouter, wEouter, wDouter ) :
    
    #Enforce dP/dN=0 on inner boundary:
    RHS = np.sum( wIinner*U[0,0:stcB,:], axis=0 )
    RHS = someFactor * ( RHS @ Wlam )
    U[0,0,:]  = ( RHS - np.sum(wDinner[1:stcB,:]*U[0,1:stcB,:],axis=0) ) / wDinner[0,:]
    
    #Get uN and uT near bottom boundary:
    uN = U[1,1:stcB,:]   * NxBot + U[2,1:stcB,:]   * NyBot
    uT = U[1,1:stcB+1,:] * TxBot + U[2,1:stcB+1,:] * TyBot
    
    #Extrapolate uT to inner ghost nodes:
    uT = np.sum( wEinner * uT, axis=0 )
    
    #Enforce uN=0 on inner boundary:
    uN = - np.sum( wIinner[1:stcB,:] * uN, axis=0 ) / wIinner[0,:]
    
    #Combine uT and uN on inner ghost nodes to get u and v on inner ghost nodes:
    U[1,0,:] = uT*TxBot[0,:] + uN*NxBot[0,:]
    U[2,0,:] = uT*TyBot[0,:] + uN*NyBot[0,:]
    
    #################################
    
    #Enforce dP/dN=0 on outer boundary:
    U[0,-1,:] = - np.sum(wDouter[1:stcB,:]*U[0,-2:-(stcB+1):-1,:],axis=0) / wDouter[0,:]
    
    #Get uN and uT near top boundary:
    uN = U[1,-2:-(stcB+1):-1,:] * NxTop + U[2,-2:-(stcB+1):-1,:] * NyTop
    uT = U[1,-2:-(stcB+2):-1,:] * TxTop + U[2,-2:-(stcB+2):-1,:] * TyTop
    
    #Extrapolate uT to outer ghost nodes:
    uT = np.sum( wEouter * uT, axis=0 )
    
    #Enforce uN=0 on outer boundary:
    uN = - np.sum( wIouter[1:stcB,:] * uN, axis=0 ) / wIouter[0,:]
    
    #Combine uT and uN on outer ghost nodes to get u and v on outer ghost nodes:
    U[1,-1,:] = uT*TxTop[0,:] + uN*NxTop[0,:]
    U[2,-1,:] = uT*TyTop[0,:] + uN*NyTop[0,:]
    
    return U

###########################################################################

#Use this if P, u, and v are all stored at layer interfaces:

def setGhostNodesInterfaces( U \
, TxBot, TyBot, TxTop, TyTop \
, someFactor, stcB \
, Wlam, wEinner, wDinner, wEouter, wDouter ) :
    
    #Enforce dP/dN=0 on inner boundary:
    RHS = someFactor * ( U[0,1,:] @ Wlam )
    U[0,0,:] = ( RHS - np.sum(wDinner[1:stcB,:]*U[0,1:stcB,:],axis=0) ) / wDinner[0,:]
    
    #set uN=0 on bottom boundary:
    uT = U[1,1,:]*TxBot + U[2,1,:]*TyBot
    U[1,1,:] = uT*TxBot
    U[2,1,:] = uT*TyBot
    
    #extrapolate u and v to bottom ghost nodes:
    U[1,0,:] = np.sum( wEinner * U[1,1:stcB+1,:], axis=0 )
    U[2,0,:] = np.sum( wEinner * U[2,1:stcB+1,:], axis=0 )
    
    #################################
    
    #Enforce dP/dN=0 on outer boundary:
    U[0,-1,:] = - np.sum(wDouter[1:stcB,:]*U[0,-2:-(stcB+1):-1,:],axis=0) / wDouter[0,:]
    
    #set uN=0 on top boundary:
    uT = U[1,-2,:]*TxTop + U[2,-2,:]*TyTop
    U[1,-2,:] = uT*TxTop
    U[2,-2,:] = uT*TyTop
    
    #extrapolate u and v to top ghost nodes:
    U[1,-1,:] = np.sum( wEinner * U[1,-2:-(stcB+2):-1,:], axis=0 )
    U[2,-1,:] = np.sum( wEinner * U[2,-2:-(stcB+2):-1,:], axis=0 )
    
    return U

###########################################################################

def odefun( t, U \
, setGhostNodes, Ds, Dlam, HV \
, Po, rhoInv, dsdth, dsdr \
, cosTh, sinTh, cosThOverR, sinThOverR ) :
    
    U = setGhostNodes( U )
    
    V = np.zeros( np.shape(U) )
    
    u_s   = Ds( U[1,:,:] )
    v_s   = Ds( U[2,:,:] )
    
    V[0,1:-1,:] = -Po *                                                \
    ( cosTh*(dsdr*u_s) - sinThOverR * ( Dlam(U[1,:,:]) + dsdth*u_s )   \
    + sinTh*(dsdr*v_s) + cosThOverR * ( Dlam(U[2,:,:]) + dsdth*v_s ) ) \
    + HV( U[0,:,:] )
    
    P_r  = Ds( U[0,:,:] )
    P_th = Dlam( U[0,:,:] ) + dsdth * P_r
    P_r  = dsdr * P_r
    
    V[1,1:-1,:] = -rhoInv *                 \
    ( cosTh * P_r - sinThOverR * P_th ) \
    + HV( U[1,:,:] )
    
    V[2,1:-1,:] = -rhoInv *                 \
    ( sinTh * P_r + cosThOverR * P_th ) \
    + HV( U[2,:,:] )
    
    return V

###########################################################################

def odefunCartesian( t, U   \
, setGhostNodes, Dx, Dy, HV \
, Po, rhoInv ) :
    
    U = setGhostNodes( U )
    
    V = np.zeros( np.shape(U) )
    
    V[0,1:-1,:] = -Po * ( Dx( U[1,:,:] ) + Dy( U[2,:,:] ) ) \
    + HV( U[0,:,:] )
    
    V[1,1:-1,:] = -rhoInv * Dx( U[0,:,:] ) \
    + HV( U[1,:,:] )
    
    V[2,1:-1,:] = -rhoInv * Dy( U[0,:,:] ) \
    + HV( U[2,:,:] )
    
    return V

###########################################################################