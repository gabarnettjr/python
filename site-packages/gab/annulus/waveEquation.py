import numpy as np
import argparse
import matplotlib.pyplot as plt

###########################################################################

def parseInput() :
    
    parser = argparse.ArgumentParser \
    ( formatter_class = argparse.ArgumentDefaultsHelpFormatter )
    
    parser.add_argument("--innerRadius", help="average inner radius of deformed annulus" \
    , type=np.float64, default=1.)
    
    parser.add_argument("--outerRadius", help="outer radius of deformed annulus" \
    , type=np.float64, default=2.)
    
    parser.add_argument("--c", help="wave-speed" \
    , type=np.float64, default=.02)
    
    parser.add_argument("--tf", help="final simulation time in seconds" \
    , type=np.float64, default=200.)
    
    parser.add_argument("--exp", help="controls steepness of initial Gaussian bell(s)" \
    , type=np.float64, default=100.)
    
    parser.add_argument("--ang1", help="angle telling where the first" \
    + " Gaussian bell should be centered" \
    , type=str, default="17./18.*np.pi")

    parser.add_argument("--ang2", help="angle telling where the second" \
    + " Gaussian bell should be centered" \
    , type=str, default="")
    
    parser.add_argument("--ang3", help="angle telling where the third" \
    + " Gaussian bell should be centered" \
    , type=str, default="")
    
    parser.add_argument("--amp", help="amplitude of trigonometric topography function" \
    , type=np.float64, default=.10)
    
    parser.add_argument("--frq", help="frequency of trigonometric topography function" \
    , type=np.int64,   default=7)
    
    parser.add_argument("--saveDel", help="time between prints.  " \
    + "Note: this is also the time between saveArrays, " \
    + "and the time between saveContours, if these are turned on."
    , type=np.int64,   default=10)
    
    parser.add_argument("--saveArrays", help="use this if you want to save arrays" \
    , action="store_true")
    
    parser.add_argument("--saveContours", help="use this if you want to save contours" \
    , action="store_true")
    
    parser.add_argument("--plotFromSaved", help="use this to plot from previous save" \
    , action="store_true")
    
    parser.add_argument("--whatToPlot", help="choose between P, u, v, curl, div, rho, and vMag" \
    , default="P")
    
    parser.add_argument("--dynamicColorbar", help="use this if you want the" \
    + " colorbar to change as time progresses" \
    , action="store_true")
    
    parser.add_argument("--mlv", help="0:interfaces, 1:mid-levels" \
    , type=np.int64,   default=1)
    
    parser.add_argument("--phs", help="exponent in PHS RBF" \
    , type=np.int64,   default=5)
    
    parser.add_argument("--pol", help="polynomial degree" \
    , type=np.int64,   default=3)
    
    parser.add_argument("--stc", help="stencil size" \
    , type=np.int64,   default=7)
    
    parser.add_argument("--ptb", help="random node perturbation percentage" \
    , type=np.int64,   default=0)
    
    parser.add_argument("--rks", help="number (3 or 4) of Runge-Kutta stages" \
    , type=np.int64,   default=3)
    
    parser.add_argument("--nlv", help="total number of radial levels" \
    , type=np.int64,   default=50)
    
    parser.add_argument("--dti", help="inverse of delta t (integer)" \
    , type=np.int64,   default=4)
    
    parser.add_argument("--noRadialHV", help="use this if you want to" \
    + " turn off the radial hyperviscosity (dissipation)"
    , action="store_true")
    
    parser.add_argument("--noAngularHV", help="use this if you want to" \
    + " turn off the angular hyperviscosity (dissipation)" \
    , action="store_true")
    
    parser.add_argument("--angularFD", help="use this if you want conventional" \
    + " finite differences in the angular direction" \
    , action="store_true")

    parser.add_argument("--plotNodes", help="use this if you want to just" \
    + " plot the nodes and exit" \
    , action="store_true")

    parser.add_argument("--plotHeightCoord", help="use this if you want" \
    + " to just plot the height coordinate transformation functions and exit" \
    , action="store_true")

    parser.add_argument("--plotRadii", help="use this if you want to just" \
    + " plot the perturbed radii and exit" \
    , action="store_true")
    
    parser.add_argument("--noInterp", help="use this if you don't want to" \
    + " interpolate to a regular mesh before plotting" \
    , action="store_true")
    
    args = parser.parse_args()
    
    return args

###########################################################################

def getSavestring( c, innerRadius, outerRadius, tf, saveDel, exp, amp, frq \
, mlv, phs, pol, stc, ptb, rks, nlv, dti ) :
    
    saveString                                  \
    = 'c'    + '{0:1.3f}' . format(c)           \
    + '_ri'  + '{0:1.0f}' . format(innerRadius) \
    + '_ro'  + '{0:1.0f}' . format(outerRadius) \
    + '_tf'  + '{0:1d}'   . format(np.int(tf))  \
    + '_sd'  + '{0:1d}'   . format(saveDel)     \
    + '_exp' + '{0:1d}'   . format(np.int(exp)) \
    + '_amp' + '{0:1.2f}' . format(amp)         \
    + '_frq' + '{0:1d}'   . format(frq)                        #folder name

    saveString = saveString + '/'     \
    + 'mlv'  + '{0:1d}' . format(mlv) \
    + '_phs' + '{0:1d}' . format(phs) \
    + '_pol' + '{0:1d}' . format(pol) \
    + '_stc' + '{0:1d}' . format(stc) \
    + '_ptb' + '{0:1d}' . format(ptb) \
    + '_rks' + '{0:1d}' . format(rks) \
    + '_nlv' + '{0:1d}' . format(nlv) \
    + '_dti' + '{0:1d}' . format(dti) \
    + '/'                                                        #file name
    
    return saveString

###########################################################################

#Use this if P, u, and v are all stored at layer midpoints (default):

def setGhostNodesMidLevels( U \
, NxBot, NyBot, NxTop, NyTop \
, TxBot, TyBot, TxTop, TyTop \
, someFactor, stcB, Wlam \
, wIinner, wEinner, wDinner, wHinner, wIouter, wEouter, wDouter ) :
    
    #Enforce dP/dN=0 on inner boundary:
    RHS = wHinner.dot( U[0,1:stcB+1,:] )          #extrap P to bottom bndry
    RHS = someFactor * Wlam.dot(RHS.T).T#someFactor*dP/dlam on bottom bndry
    U[0,0,:]  = ( RHS - wDinner[1:stcB].dot(U[0,1:stcB,:]) ) / wDinner[0]
    
    #Get uN and uT near bottom boundary:
    uN = U[1,1:stcB,:]   * NxBot + U[2,1:stcB,:]   * NyBot
    uT = U[1,1:stcB+1,:] * TxBot + U[2,1:stcB+1,:] * TyBot
    
    #Extrapolate uT to inner ghost nodes:
    uT = wEinner.dot( uT )
    
    #Enforce uN=0 on inner boundary:
    uN = - wIinner[1:stcB].dot(uN) / wIinner[0]
    
    #Combine uT and uN on inner ghost nodes to get u and v there:
    U[1,0,:] = uT*TxBot[0,:] + uN*NxBot[0,:]
    U[2,0,:] = uT*TyBot[0,:] + uN*NyBot[0,:]
    
    #################################
    
    #Enforce dP/dN=0 on outer boundary:
    U[0,-1,:] = - wDouter[1:stcB].dot( U[0,-2:-(stcB+1):-1,:] ) / wDouter[0]
    
    #Get uN and uT near top boundary:
    uN = U[1,-2:-(stcB+1):-1,:] * NxTop + U[2,-2:-(stcB+1):-1,:] * NyTop
    uT = U[1,-2:-(stcB+2):-1,:] * TxTop + U[2,-2:-(stcB+2):-1,:] * TyTop
    
    #Extrapolate uT to outer ghost nodes:
    uT = wEouter.dot( uT )
    
    #Enforce uN=0 on outer boundary:
    uN = - wIouter[1:stcB].dot(uN) / wIouter[0]
    
    #Combine uT and uN on outer ghost nodes to get u and v on outer ghost nodes:
    U[1,-1,:] = uT*TxTop[0,:] + uN*NxTop[0,:]
    U[2,-1,:] = uT*TyTop[0,:] + uN*NyTop[0,:]
    
    return U

###########################################################################

#Use this if P, u, and v are all stored at layer interfaces:

def setGhostNodesInterfaces( U \
, TxBot, TyBot, TxTop, TyTop \
, someFactor, stcB, Wlam \
, wEinner, wDinner, wEouter, wDouter ) :
    
    #Enforce dP/dN=0 on inner boundary:
    RHS = someFactor * Wlam.dot(U[0,1,:].T).T
    U[0,0,:] = ( RHS - wDinner[1:stcB].dot( U[0,1:stcB,:] ) ) / wDinner[0]
    
    #set uN=0 on bottom boundary:
    uT = U[1,1,:]*TxBot + U[2,1,:]*TyBot
    U[1,1,:] = uT*TxBot
    U[2,1,:] = uT*TyBot
    
    #extrapolate u and v to bottom ghost nodes:
    U[1,0,:] = wEinner.dot( U[1,1:stcB+1,:] )
    U[2,0,:] = wEinner.dot( U[2,1:stcB+1,:] )
    
    #################################
    
    #Enforce dP/dN=0 on outer boundary:
    U[0,-1,:] = - wDouter[1:stcB].dot( U[0,-2:-(stcB+1):-1,:] ) / wDouter[0]
    
    #set uN=0 on top boundary:
    uT = U[1,-2,:]*TxTop + U[2,-2,:]*TyTop
    U[1,-2,:] = uT*TxTop
    U[2,-2,:] = uT*TyTop
    
    #extrapolate u and v to top ghost nodes:
    U[1,-1,:] = wEinner.dot( U[1,-2:-(stcB+2):-1,:] )
    U[2,-1,:] = wEinner.dot( U[2,-2:-(stcB+2):-1,:] )
    
    return U

###########################################################################

def odefun( t, U \
, setGhostNodes, Ds, Dlam, HV \
, Po, rhoInv, dsdth, dsdr \
, cosTh, sinTh, cosThOverR, sinThOverR ) :
    
    U = setGhostNodes(U)
    
    V = np.zeros( np.shape(U) )
    
    V[0,1:-1,:] = -Po *                            \
    ( (cosTh*dsdr-sinThOverR*dsdth) * Ds(U[1,:,:]) \
    + (sinTh*dsdr+cosThOverR*dsdth) * Ds(U[2,:,:]) \
    - sinThOverR * Dlam(U[1,:,:])                  \
    + cosThOverR * Dlam(U[2,:,:]) ) [1:-1,:]       \
    + HV(U[0,:,:])
    
    # u_s   = Ds( U[1,:,:] )
    # v_s   = Ds( U[2,:,:] )
    # V[0,1:-1,:] = -Po *                                                         \
    # ( cosTh*(u_s*dsdr) - sinThOverR * ( Dlam(U[1,:,:]) + u_s*dsdth )            \
    # + sinTh*(v_s*dsdr) + cosThOverR * ( Dlam(U[2,:,:]) + v_s*dsdth ) ) [1:-1,:] \
    # + HV( U[0,:,:] )
    
    P_r  = Ds(U[0,:,:])
    P_th = Dlam(U[0,:,:]) + P_r * dsdth
    P_r  = P_r * dsdr
    
    V[1,1:-1,:] = -rhoInv *                      \
    ( cosTh * P_r - sinThOverR * P_th ) [1:-1,:] \
    + HV(U[1,:,:])
    
    V[2,1:-1,:] = -rhoInv *                      \
    ( sinTh * P_r + cosThOverR * P_th ) [1:-1,:] \
    + HV(U[2,:,:])
    
    return V

###########################################################################

def odefunCartesian( t, U   \
, setGhostNodes, Dx, Dy, HV \
, Po, rhoInv ) :
    
    U = setGhostNodes(U)
    
    V = np.zeros( np.shape(U) )
    
    V[0,1:-1,:] = -Po * ( Dx(U[1,:,:]) + Dy(U[2,:,:]) ) [1:-1,:] \
    + HV( U[0,:,:] )
    
    V[1,1:-1,:] = -rhoInv * Dx(U[0,:,:])[1:-1,:] \
    + HV( U[1,:,:] )
    
    V[2,1:-1,:] = -rhoInv * Dy(U[0,:,:])[1:-1,:] \
    + HV( U[2,:,:] )
    
    return V

###########################################################################

def plotSomething( U, t \
, Dx, Dy \
, whatToPlot, xx, yy, xx0, yy0, Wradial, Wangular \
, c, xB, yB, xT, yT, outerRadius, fig \
, dynamicColorbar, noInterp ) :
    
    if whatToPlot == "P" :
        tmp = U[0,:,:]
        cvec = np.arange( 1.-.15, 1.+.17, .02 )
    elif whatToPlot == "u" :
        tmp = U[1,:,:]
        cvec = np.linspace( -c/10., c/10., 20 )
    elif whatToPlot == "v" :
        tmp = U[2,:,:]
        cvec = np.linspace( -c/10., c/10., 20 )
    elif whatToPlot == "curl" :
        tmp = Dx(U[2,:,:]) - Dy(U[1,:,:])
        cvec = np.arange( -.00205, .00205+.0001, .0001 )
    elif whatToPlot == "div" :
        tmp = Dx(U[1,:,:]) + Dy(U[2,:,:])
        cvec = np.linspace( -c, c, 20 )
    elif whatToPlot == "rho" :
        tmp = U[0,:,:] / c**2.
        cvec = np.arange( 1.-.15, 1.+.17, .02 ) / c**2.
    elif whatToPlot == "vMag" :
        tmp = np.sqrt( U[1,:,:]**2. + U[2,:,:]**2. )
        cvec = np.linspace( -c/10., c/10., 20 )
    else :
        raise ValueError("Invalid thing to plot.  Choose P, u, v, curl, div, rho, or vMag.")
    
    if dynamicColorbar :
        #overwrite vector cvec with number (20) of contours:
        cvec = 20
    
    if noInterp :
        plt.contourf( xx, yy, tmp, cvec )    #contour on computational mesh
    else :
        tmp = Wradial.dot(tmp)                        #radial interpolation
        tmp = Wangular.dot(tmp.T).T                  #angular interpolation
        plt.contourf( xx0, yy0, tmp, cvec )        #contour on regular mesh
    
    plt.plot( xB, yB, "k-", xT, yT, "k-" )                   #plot boundary
    plt.axis('equal')
    tmp = outerRadius + .2
    plt.axis([-tmp,tmp,-tmp,tmp])
    plt.colorbar()
    
    fig.savefig( '{0:04d}'.format(np.int(np.round(t)+1e-12)) \
    + '.png', bbox_inches = 'tight' )                 #save figure as a png
    
    plt.clf()

###########################################################################
