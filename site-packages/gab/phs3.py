import numpy as np
from scipy import spatial

def getMN() :
    
    mn = np.array( 
    
    [ [0,0,0]
    
    , [1,0,0]
    , [0,1,0]
    , [0,0,1]
    
    , [2,0,0]
    , [1,1,0]
    , [1,0,1]
    , [0,2,0]
    , [0,1,1]
    , [0,0,2]
    
    , [3,0,0]
    , [2,1,0]
    , [2,0,1]
    , [1,2,0]
    , [1,1,1]
    , [1,0,2]
    , [0,3,0]
    , [0,2,1]
    , [0,1,2]
    , [0,0,3]
    
    , [4,0,0]
    , [3,1,0]
    , [3,0,1]
    , [2,2,0]
    , [2,1,1]
    , [2,0,2]
    , [1,3,0]
    , [1,2,1]
    , [1,1,2]
    , [1,0,3]
    , [0,4,0]
    , [0,3,1]
    , [0,2,2]
    , [0,1,3]
    , [0,0,4] ] )
    
    return mn

def phi( rad, x, y, z, rbfParam ) :
    f = ( x*x + y*y + z*z ) ** (rbfParam/2)
    f = f / rad**rbfParam
    return f

def phi_x( rad, x, y, z, rbfParam ) :
    f = rbfParam*x * ( x*x + y*y + z*z ) ** ((rbfParam-2)/2)
    f = f / rad**rbfParam
    return f

def phi_y( rad, x, y, z, rbfParam ) :
    f = rbfParam*y * ( x*x + y*y + z*z ) ** ((rbfParam-2)/2)
    f = f / rad**rbfParam
    return f

def phi_z( rad, x, y, z, rbfParam ) :
    f = rbfParam*z * ( x*x + y*y + z*z ) ** ((rbfParam-2)/2)
    f = f / rad**rbfParam
    return f

def phiHV( rad, x, y, z, rbfParam, K ) :
    f = np.arange( rbfParam-2*(K-1), rbfParam+2 )
    f = np.prod(f) * ( x*x + y*y + z*z ) ** ((rbfParam-2*K)/2)
    f = f / rad**rbfParam
    return f

def getStencils( x, y, z, xE, yE, zE, stencilSize ) :
    #given row-vectors x, y, and z, where you know the values, and row
    #vectors xE, yE, and zE, where you want to know the values,
    #this function returns the index of the stencilSize nearest (x,y,z)
    #points to each (xE,yE,zE) point, shifted to the origin.
    pts = np.transpose( np.vstack((x,y,z)) )
    tree = spatial.cKDTree(pts)
    ptsE = np.transpose( np.vstack((xE,yE,zE)) )
    class struct :
        pass
    stencils = struct
    stencils.idx = tree.query( ptsE, 1 )
    stencils.idx = tree.query( pts[stencils.idx[1]], stencilSize )
    stencils.rad = stencils.idx[0]
    stencils.rad = stencils.rad[:,stencilSize-1]
    stencils.rad = np.transpose( np.tile( stencils.rad, (stencilSize,1) ) )
    stencils.idx = stencils.idx[1]
    stencils.X = x[stencils.idx] - np.transpose( np.tile( xE, (stencilSize,1) ) )
    stencils.Y = y[stencils.idx] - np.transpose( np.tile( yE, (stencilSize,1) ) )
    stencils.Z = z[stencils.idx] - np.transpose( np.tile( zE, (stencilSize,1) ) )
    stencils.nE = len(xE)
    stencils.size = stencilSize
    stencils.mn = getMN()
    return stencils

def rotateStencils( stencils, e1, e2, e3 ) :
    #writes each stencil in terms of orthogonal unit vectors e1, e2, and e3
    #instead of (1,0,0), (0,1,0), and (0,0,1).  You might use this to get weights for
    #the normal derivative along the bottom boundary, for example.
    if ( np.shape(e1)[0] != stencils.nE ) | ( np.shape(e2)[0] != stencils.nE ) | ( np.shape(e3)[0] != stencils.nE ) :
        print("error")
        return
    #first new coordinate:
    e11 = np.transpose( np.tile( e1[:,0], (stencils.size,1) ) )
    e12 = np.transpose( np.tile( e1[:,1], (stencils.size,1) ) )
    e13 = np.transpose( np.tile( e1[:,2], (stencils.size,1) ) )
    X1 = e11*stencils.X + e12*stencils.Y + e13*stencils.Z
    #second new coordinate:
    e21 = np.transpose( np.tile( e2[:,0], (stencils.size,1) ) )
    e22 = np.transpose( np.tile( e2[:,1], (stencils.size,1) ) )
    e23 = np.transpose( np.tile( e2[:,2], (stencils.size,1) ) )
    X2 = e21*stencils.X + e22*stencils.Y + e23*stencils.Z
    #third new coordinate:
    e31 = np.transpose( np.tile( e3[:,0], (stencils.size,1) ) )
    e32 = np.transpose( np.tile( e3[:,1], (stencils.size,1) ) )
    e33 = np.transpose( np.tile( e3[:,2], (stencils.size,1) ) )
    X3 = e31*stencils.X + e32*stencils.Y + e33*stencils.Z
    #set output:
    stencils.X = X1
    stencils.Y = X2
    stencils.Z = X3
    return stencils

def getAmatrices( stencils, rbfParam, polyorder ) :
    class struct :
        pass
    A = struct
    A.rbfParam = rbfParam
    A.numPoly = np.int( (polyorder+1)*(polyorder+2)*(polyorder+3)/6 )
    A.matrices = np.zeros(( stencils.nE, stencils.size+A.numPoly, stencils.size+A.numPoly ))
    mn = stencils.mn[ 0:A.numPoly, : ]
    mn0 = np.tile( mn[:,0], (stencils.nE,1) )
    mn1 = np.tile( mn[:,1], (stencils.nE,1) )
    mn2 = np.tile( mn[:,2], (stencils.nE,1) )
    for i in range(stencils.size) :
        tmpX = np.transpose( np.tile( stencils.X[:,i], (stencils.size,1) ) )
        tmpY = np.transpose( np.tile( stencils.Y[:,i], (stencils.size,1) ) )
        tmpZ = np.transpose( np.tile( stencils.Z[:,i], (stencils.size,1) ) )
        A.matrices[ :, i, 0:stencils.size ] = phi( stencils.rad, tmpX-stencils.X, tmpY-stencils.Y, tmpZ-stencils.Z, rbfParam )
        tmp = tmpX[:,0:A.numPoly]**mn0 * tmpY[:,0:A.numPoly]**mn1 * tmpZ[:,0:A.numPoly]**mn2 \
        / stencils.rad[:,0:A.numPoly]**(mn0+mn1+mn2)
        A.matrices[ :, i, stencils.size:stencils.size+A.numPoly ] = tmp
        A.matrices[ :, stencils.size:stencils.size+A.numPoly, i ] = tmp
    return A

def getWeights( stencils, A, op, K ) :
    b = np.zeros(( stencils.nE, stencils.size+A.numPoly, 1 ))
    if op == "i" :
        b[ :, 0:stencils.size, 0 ] = phi( stencils.rad, 0-stencils.X, 0-stencils.Y, 0-stencils.Z, A.rbfParam )
        b[ :, stencils.size, 0 ] = 1
    elif op == "1" :
        b[ :, 0:stencils.size, 0 ] = phi_x( stencils.rad, 0-stencils.X, 0-stencils.Y, 0-stencils.Z, A.rbfParam )
        b[ :, stencils.size+1, 0 ] = 1/stencils.rad[:,0]
    elif op == "2" :
        b[ :, 0:stencils.size, 0 ] = phi_y( stencils.rad, 0-stencils.X, 0-stencils.Y, 0-stencils.Z, A.rbfParam )
        b[ :, stencils.size+2, 0 ] = 1/stencils.rad[:,0]
    elif op == "3" :
        b[ :, 0:stencils.size, 0 ] = phi_z( stencils.rad, 0-stencils.X, 0-stencils.Y, 0-stencils.Z, A.rbfParam )
        b[ :, stencils.size+3, 0 ] = 1/stencils.rad[:,0]
    elif op == "hv" :
        b[ :, 0:stencils.size, 0 ] = phiHV( stencils.rad, 0-stencils.X, 0-stencils.Y, 0-stencils.Z, A.rbfParam, K )
        if ( K == 1 ) & ( A.numPoly > 4 ) :
            b[ :, stencils.size+4, 0 ] = 2/stencils.rad[:,0]**2
            b[ :, stencils.size+7, 0 ] = 2/stencils.rad[:,0]**2
            b[ :, stencils.size+9, 0 ] = 2/stencils.rad[:,0]**2
    else :
        print("error")
        return
    W = np.linalg.solve( A.matrices, b )
    W = np.reshape( W[:,0:stencils.size,0], (stencils.nE,stencils.size) )
    return W