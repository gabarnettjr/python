import numpy as np

###########################################################################

#Get number of angular levels so that the angular spacing and radial
#spacing are nearly equal along the inner circle, and the number of angular
#levels is odd (for periodic PS):

def getNth( innerRadius, outerRadius, nr ):
    
    nth = np.int(np.round( 2*np.pi * innerRadius * (nr-2)/(outerRadius-innerRadius) ))
    
    if np.mod( nth, 2 ) == 0 :
        nth = nth + 1
    
    return nth

###########################################################################

def getTopoFunc( innerRadius, amp ) :

    k = 5*innerRadius
    
    def rSurf( th ) :
        return innerRadius + amp*np.cos(k*th)
    
    def rSurfPrime( th ) :
        return -amp*k*np.sin(k*th)
    
    return rSurf, rSurfPrime

###########################################################################

def getHeightCoordinate( rTop, rBot, amp ) :
    
    rSurf, rSurfPrime = getTopoFunc( rBot, amp )
    
    def s( r, th ) :
        return ( r - rSurf(th) ) / ( rTop - rSurf(th) ) * ( rTop - rBot ) + rBot
    
    def dsdth( r, th ) :
        return rSurfPrime(th) * ( r - rTop ) * ( rTop - rBot ) / ( rTop - rSurf(th) )**2.
    
    def dsdr( r, th ) :
        return ( rTop - rBot ) / ( rTop - rSurf(th) )
    
    return rSurf, dsdth, dsdr

###########################################################################

#thth and ss define a mesh on an annulus, and this returns radii in the
#untransformed space.

def getRadii( thth, ss, rBot, rTop, rSurf ) :
    
    rr = (ss-rBot) / (rTop-rBot) * (rTop-rSurf(thth)) + rSurf(thth)
    
    return rr

###########################################################################

def setGhostNodes( U \
, rhoB, rhoT, wIinner, wEinner, wIouter, wEouter, stc ) :
    
    for i in range( 1, stc ) :
        rhoB = rhoB - wIinner[i]*U[0,i,:]
        rhoT = rhoT - wIouter[i]*U[0,-i-1,:]
    U[0,0,:]  = rhoB / wIinner[0]
    U[0,-1,:] = rhoT / wIouter[0]
    
    rhoB = 0.
    rhoT = 0.
    for i in range( 0, stc ) :
        rhoB = rhoB + wEinner[i]*U[1,i+1,:]
        rhoT = rhoT + wEouter[i]*U[1,-i-2,:]
    U[1,0,:]  = rhoB
    U[1,-1,:] = rhoT
    
    rhoB = 0.
    rhoT = 0.
    for i in range( 0, stc ) :
        rhoB = rhoB + wEinner[i]*U[2,i+1,:]
        rhoT = rhoT + wEouter[i]*U[2,-i-2,:]
    U[2,0,:]  = rhoB
    U[2,-1,:] = rhoT
    
    return U

###########################################################################

def setGhostNodesNoLoop( U \
, rhoB, rhoT, wIinner, wEinner, wIouter, wEouter, stc ) :
    
    #Enforce rho=0 on inner and outer boundaries:
    U[0,0,:]  = ( rhoB - np.sum(wIinner[1:stc,:]*U[0,1:stc,:],axis=0) ) / wIinner[0,:]
    U[0,-1,:] = ( rhoT - np.sum(wIouter[1:stc,:]*U[0,-2:-(stc+1):-1,:],axis=0) ) / wIouter[0,:]
    
    #Extrapolate u to inner and outer ghost nodes:
    U[1,0,:]  = np.sum( wEinner * U[1,1:stc+1,:], axis=0 )
    U[1,-1,:] = np.sum( wEouter * U[1,-2:-(stc+2):-1,:], axis=0 )
    
    #Extrapolate v to inner and outer ghost nodes:
    U[2,0,:]  = np.sum( wEinner * U[2,1:stc+1,:], axis=0 )
    U[2,-1,:] = np.sum( wEouter * U[2,-2:-(stc+2):-1,:], axis=0 )
    
    return U

###########################################################################

def odefun( t, U \
, setGhostNodes, Ds, Dth, HVs, HVth \
, th, r, c \
, dsdth, dsdr ) :
    
    U = setGhostNodes( U )
    
    V = np.zeros( np.shape(U) )
    
    u_s   = Ds( U[1,:,:] )
    v_s   = Ds( U[2,:,:] )
    
    V[0,1:-1,:] = c *                                                           \
    ( np.cos(th)*(dsdr*u_s) - np.sin(th)/r * ( Dth(U[1,1:-1,:]) + dsdth*u_s )   \
    + np.sin(th)*(dsdr*v_s) + np.cos(th)/r * ( Dth(U[2,1:-1,:]) + dsdth*v_s ) ) \
    + HVs( U[0,:,:] ) + HVth( U[0,1:-1,:] )
    
    rho_r  = Ds( U[0,:,:] )
    rho_th = Dth( U[0,1:-1,:] ) + dsdth * rho_r
    rho_r  = dsdr * rho_r
    
    V[1,1:-1,:] = c *                              \
    ( np.cos(th) * rho_r - np.sin(th)/r * rho_th ) \
    + HVs( U[1,:,:] ) + HVth( U[1,1:-1,:] )
    
    V[2,1:-1,:] = c *                              \
    ( np.sin(th) * rho_r + np.cos(th)/r * rho_th ) \
    + HVs( U[2,:,:] ) + HVth( U[2,1:-1,:] )
    
    return V

###########################################################################

def odefunCartesian( t, U \
, setGhostNodes, Dx, Dy, HV, c ) :
    
    U = setGhostNodes( U )
    
    V = np.zeros( np.shape(U) )
    
    V[0,1:-1,:] = c * ( Dx( U[1,:,:] ) + Dy( U[2,:,:] ) ) \
    + HV( U[0,:,:] )
    
    V[1,1:-1,:] = c * Dx( U[0,:,:] ) \
    + HV( U[1,:,:] )
    
    V[2,1:-1,:] = c * Dy( U[0,:,:] ) \
    + HV( U[2,:,:] )
    
    return V

###########################################################################