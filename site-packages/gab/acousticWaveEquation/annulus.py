import numpy as np

###########################################################################

#Get number of angular levels so that the angular spacing and radial
#spacing are nearly equal along the inner circle, and the number of angular
#levels is odd (for periodic PS):

def getNth( innerRadius, outerRadius, nr ):
    
    nth = np.int(np.round( 2*np.pi * innerRadius * (nr-2)/(outerRadius-innerRadius) ))
    
    if np.mod( nth, 2 ) == 0 :
        nth = nth + 1
    
    return nth

###########################################################################

def getTopoFunc( innerRadius, outerRadius, amp ) :

    k = 9
    
    amp = amp * ( outerRadius - innerRadius )
    
    def rSurf( th ) :
        return innerRadius + amp*np.cos(k*th)
    
    def rSurfPrime( th ) :
        return -amp*k*np.sin(k*th)
    
    return rSurf, rSurfPrime

###########################################################################

def getHeightCoordinate( rTop, rBot, amp ) :
    
    rSurf, rSurfPrime = getTopoFunc( rBot, rTop, amp )
    
    def s( r, th ) :
        return ( r - rSurf(th) ) / ( rTop - rSurf(th) ) * ( rTop - rBot ) + rBot
    
    def dsdth( r, th ) :
        return rSurfPrime(th) * ( r - rTop ) * ( rTop - rBot ) / ( rTop - rSurf(th) )**2.
    
    def dsdr( r, th ) :
        return ( rTop - rBot ) / ( rTop - rSurf(th) )
    
    return rSurf, dsdth, dsdr

###########################################################################

#thth and ss define a mesh on an annulus, and this returns radii in the
#untransformed space.

def getRadii( thth, ss, rBot, rTop, rSurf ) :
    
    rr = (ss-rBot) / (rTop-rBot) * (rTop-rSurf(thth)) + rSurf(thth)
    
    return rr

###########################################################################

def setGhostNodes1D( U \
, rhoB, rhoT, wIinner, wEinner, wIouter, wEouter, stc ) :
    
    #Enforce rho=0 on inner and outer boundaries:
    U[0,0,:]  = ( rhoB - np.sum(wIinner[1:stc,:]*U[0,1:stc,:],axis=0) ) / wIinner[0,:]
    U[0,-1,:] = ( rhoT - np.sum(wIouter[1:stc,:]*U[0,-2:-(stc+1):-1,:],axis=0) ) / wIouter[0,:]
    
    #Extrapolate u to inner and outer ghost nodes:
    U[1,0,:]  = np.sum( wEinner * U[1,1:stc+1,:], axis=0 )
    U[1,-1,:] = np.sum( wEouter * U[1,-2:-(stc+2):-1,:], axis=0 )
    
    #Extrapolate v to inner and outer ghost nodes:
    U[2,0,:]  = np.sum( wEinner * U[2,1:stc+1,:], axis=0 )
    U[2,-1,:] = np.sum( wEouter * U[2,-2:-(stc+2):-1,:], axis=0 )
    
    return U

###########################################################################

def setGhostNodes2D( U \
, rhoB, rhoT, wIbot, wEbot, wItop, wEtop \
, stencilsIbot, stencilsEbot, stencilsItop, stencilsEtop ) :
    
    
    
    return U

###########################################################################

def odefun( t, U \
, setGhostNodes, Ds, Dlam, HV \
, c, dsdth, dsdr \
, cosTh, sinTh, cosThOverR, sinThOverR ) :
    
    U = setGhostNodes( U )
    
    V = np.zeros( np.shape(U) )
    
    u_s   = Ds( U[1,:,:] )
    v_s   = Ds( U[2,:,:] )
    
    V[0,1:-1,:] = c *                                                  \
    ( cosTh*(dsdr*u_s) - sinThOverR * ( Dlam(U[1,:,:]) + dsdth*u_s )   \
    + sinTh*(dsdr*v_s) + cosThOverR * ( Dlam(U[2,:,:]) + dsdth*v_s ) ) \
    + HV( U[0,:,:] )
    
    rho_r  = Ds( U[0,:,:] )
    rho_th = Dlam( U[0,:,:] ) + dsdth * rho_r
    rho_r  = dsdr * rho_r
    
    V[1,1:-1,:] = c *                       \
    ( cosTh * rho_r - sinThOverR * rho_th ) \
    + HV( U[1,:,:] )
    
    V[2,1:-1,:] = c *                       \
    ( sinTh * rho_r + cosThOverR * rho_th ) \
    + HV( U[2,:,:] )
    
    return V

###########################################################################

def odefunCartesian( t, U   \
, setGhostNodes, Dx, Dy, HV \
, c ) :
    
    U = setGhostNodes( U )
    
    V = np.zeros( np.shape(U) )
    
    V[0,1:-1,:] = c * ( Dx( U[1,:,:] ) + Dy( U[2,:,:] ) ) \
    + HV( U[0,:,:] )
    
    V[1,1:-1,:] = c * Dx( U[0,:,:] ) \
    + HV( U[1,:,:] )
    
    V[2,1:-1,:] = c * Dy( U[0,:,:] ) \
    + HV( U[2,:,:] )
    
    return V

###########################################################################