import numpy as np

###########################################################################

# def getMainIndex( FDr, FDth, nr, nth ) :
    
    # tmp = np.int(np.round( FDr/2 ))
    # ii = np.arange( tmp, nr-tmp )
    
    # tmp = np.int(np.round( FDth/2 ))
    # jj = np.arange( tmp, nth-tmp )
    
    # return ii, jj

###########################################################################

# def getFDweights( derivative, FD ) :
    
    # if derivative == 1 :
        # if FD == 2 :
            # w = np.array([ [ -1./2., 0., 1./2. ] ])
        # elif FD == 4 :
            # w = np.array([ [ -1./4.,  -5./6.,  3./2., -1./2.,  1./12. ] \
                         # , [  1./12., -2./3.,  0.,     2./3., -1./12. ] \
                         # , [ -1./12.,  1./2., -3./2.,  5./6.,  1./4.  ] ])
        # elif FD == 6 :
            # w = np.array([ [ -1./6.,  -77./60., 5./2., -5./3.,  5./6., -1./4.,   1./30. ] \
                         # , [  1./30., -2./5.,  -7./12., 4./3., -1./2.,  2./15., -1./60. ] \
                         # , [ -1./60.,  3./20., -3./4.,  0.,     3./4., -3./20.,  1./60. ] \
                         # , [  1./60., -2./15.,  1./2., -4./3.,  7./12., 2./5.,  -1./30. ] \
                         # , [ -1./30.,  1./4.,  -5./6.,  5./3., -5./2.,  77./60., 1./6.  ] ])
        # elif FD == 8 :
            # w = np.array([ [ 1./280., -4./105., 1./5., -4./5., 0., 4./5., -1./5., 4./105., -1./280. ] \
                         # , [ 1./280., -4./105., 1./5., -4./5., 0., 4./5., -1./5., 4./105., -1./280. ] \
                         # , [ 1./280., -4./105., 1./5., -4./5., 0., 4./5., -1./5., 4./105., -1./280. ] \
                         # , [ 1./280., -4./105., 1./5., -4./5., 0., 4./5., -1./5., 4./105., -1./280. ] \
                         # , [ 1./280., -4./105., 1./5., -4./5., 0., 4./5., -1./5., 4./105., -1./280. ] \
                         # , [ 1./280., -4./105., 1./5., -4./5., 0., 4./5., -1./5., 4./105., -1./280. ] \
                         # , [ 1./280., -4./105., 1./5., -4./5., 0., 4./5., -1./5., 4./105., -1./280. ] ])
        # else :
            # sys.exit("\nError: FD should be 2, 4, 6, or 8.\n")
    # elif derivative == 2 :
        # if FD == 2 :
            # w = np.array([ [ 1., -2., 1. ] ])
        # else :
            # sys.exit("\nError: FD should be 2 for this.\n")
    # elif derivative == 4 :
        # if FD == 4 :
            # w = np.array([ [ 1., -4., 6., -4., 1. ] \
                         # , [ 1., -4., 6., -4., 1. ] \
                         # , [ 1., -4., 6., -4., 1. ] ])
        # else :
            # sys.exit("\nError: FD should be 4 for this.\n")
    # elif derivative == 6 :
        # if FD == 6 :
            # w = np.array([ [ 1., -6., 15., -20., 15., -6., 1. ] \
                         # , [ 1., -6., 15., -20., 15., -6., 1. ] \
                         # , [ 1., -6., 15., -20., 15., -6., 1. ] \
                         # , [ 1., -6., 15., -20., 15., -6., 1. ] \
                         # , [ 1., -6., 15., -20., 15., -6., 1. ] ])
        # else :
            # sys.exit("\nError: FD should be 6 for this.\n")
    # elif derivative == 8 :
        # if FD == 8 :
            # w = np.array([ [ 1., -8., 28., -56., 70., -56., 28., -8., 1. ] \
                         # , [ 1., -8., 28., -56., 70., -56., 28., -8., 1. ] \
                         # , [ 1., -8., 28., -56., 70., -56., 28., -8., 1. ] \
                         # , [ 1., -8., 28., -56., 70., -56., 28., -8., 1. ] \
                         # , [ 1., -8., 28., -56., 70., -56., 28., -8., 1. ] \
                         # , [ 1., -8., 28., -56., 70., -56., 28., -8., 1. ] \
                         # , [ 1., -8., 28., -56., 70., -56., 28., -8., 1. ] ])
        # else :
            # sys.exit("\nError: FD should be 8 for this.\n")
    # else :
        # sys.exit("\nError: derivative should be 1, 2, 4, 6, or 8.\n")
    
    # return w

###########################################################################

# def getInterpExtrapWeights( FDr ) :
    
    # if FDr == 2 :
        # wI = np.array([ 1./2., 1./2. ])
        # wE = np.array([ 2.,   -1     ])
    # elif FDr == 4 :
        # wI = np.array([ 5./16., 15./16., -5./16., 1./16. ])
        # wE = np.array([ 4.,    -6.,       4.,    -1.     ])
        # # wI = np.array([ 35./128., 35./32., -35./64., 7./32., -5./128. ])
        # # wE = np.array([ 5.,      -10.,      10.,    -5.,      1.      ])
    # else :
        # sys.exit("\nError: FDr should be 2 or 4.\n")
    
    # return wI, wE

###########################################################################

#Apply FD operator in radial direction (r):

# def Lr( U, FD, ii, w, dr ) :
    
    # if FD == 2 :
        # U = w[0,0]*U[ii-1,:] + w[0,1]*U[ii,:] + w[0,2]*U[ii+1,:]
        # return U/dr
    # elif FD == 4 :
        # V = np.zeros(( np.shape(U)[0]-2, np.shape(U)[1] ))
        # V[0,:]    = w[0,0]*U[0,:]    + w[0,1]*U[1,:]    + w[0,2]*U[2,:]  \
                  # + w[0,3]*U[3,:]    + w[0,4]*U[4,:]
        # V[1:-1,:] = w[1,0]*U[ii-2,:] + w[1,1]*U[ii-1,:] + w[1,2]*U[ii,:] \
                  # + w[1,3]*U[ii+1,:] + w[1,4]*U[ii+2,:]
        # V[-1,:]   = w[2,0]*U[-5,:]   + w[2,1]*U[-4,:]   + w[2,2]*U[-3,:] \
                  # + w[2,3]*U[-2,:]   + w[2,4]*U[-1,:]
        # return V/dr
    # else :
        # sys.exit("\nInput FD should be 2 or 4.\n")

###########################################################################

#Apply FD operator in angular direction (th):

# def Lth( U, FD, jj, w, dth ) :
    
    # V = np.zeros( np.shape(U) )
    
    # if FD == 2 :
        # V[:,0]  = w[0]*U[:,-1]   + w[1]*U[:,0]  + w[2]*U[:,1]
        # V[:,jj] = w[0]*U[:,jj-1] + w[1]*U[:,jj] + w[2]*U[:,jj+1]
        # V[:,-1] = w[0]*U[:,-2]   + w[1]*U[:,-1] + w[2]*U[:,0]
    # elif FD == 4 :
        # V[:,0]  = w[0]*U[:,-2]   + w[1]*U[:,-1]    + w[2]*U[:,0]  \
                # + w[3]*U[:,1]    + w[4]*U[:,2]
        # V[:,1]  = w[0]*U[:,-1]   + w[1]*U[:,0]     + w[2]*U[:,1]  \
                # + w[3]*U[:,2]    + w[4]*U[:,3]
        # V[:,jj] = w[0]*U[:,jj-2] + w[1]*U[:,jj-1]  + w[2]*U[:,jj] \
                # + w[3]*U[:,jj+1] + w[4]*U[:,jj+2]
        # V[:,-2] = w[0]*U[:,-4]   + w[1]*U[:,-3]    + w[2]*U[:,-2] \
                # + w[3]*U[:,-1]   + w[4]*U[:,0]
        # V[:,-1] = w[0]*U[:,-3]   + w[1]*U[:,-2]    + w[2]*U[:,-1] \
                # + w[3]*U[:,0]    + w[4]*U[:,1]
    # elif FD == 6 :
        # V[:,0]  = w[0]*U[:,-3]   + w[1]*U[:,-2]   + w[2]*U[:,-1]   \
                # + w[3]*U[:,0]                                      \
                # + w[4]*U[:,1]    + w[5]*U[:,2]    + w[6]*U[:,3]
        # V[:,1]  = w[0]*U[:,-2]   + w[1]*U[:,-1]   + w[2]*U[:,0]    \
                # + w[3]*U[:,1]                                      \
                # + w[4]*U[:,2]    + w[5]*U[:,3]    + w[6]*U[:,4]
        # V[:,2]  = w[0]*U[:,-1]   + w[1]*U[:,0]    + w[2]*U[:,1]    \
                # + w[3]*U[:,2]                                      \
                # + w[4]*U[:,3]    + w[5]*U[:,4]    + w[6]*U[:,5]
        # V[:,jj] = w[0]*U[:,jj-3] + w[1]*U[:,jj-2] + w[2]*U[:,jj-1] \
                # + w[3]*U[:,jj]                                     \
                # + w[4]*U[:,jj+1] + w[5]*U[:,jj+2] + w[6]*U[:,jj+3]
        # V[:,-3] = w[0]*U[:,-6]   + w[1]*U[:,-5]   + w[2]*U[:,-4]   \
                # + w[3]*U[:,-3]                                     \
                # + w[4]*U[:,-2]   + w[5]*U[:,-1]   + w[6]*U[:,0]
        # V[:,-2] = w[0]*U[:,-5]   + w[1]*U[:,-4]   + w[2]*U[:,-3]   \
                # + w[3]*U[:,-2]                                     \
                # + w[4]*U[:,-1]   + w[5]*U[:,0]    + w[6]*U[:,1]
        # V[:,-1] = w[0]*U[:,-4]   + w[1]*U[:,-3]   + w[2]*U[:,-2]   \
                # + w[3]*U[:,-1]                                     \
                # + w[4]*U[:,0]    + w[5]*U[:,1]    + w[6]*U[:,2]
    # elif FD == 8 :
        # V[:,0]  = w[0]*U[:,-4]   + w[1]*U[:,-3]   + w[2]*U[:,-2]   \
                # + w[3]*U[:,-1]   + w[4]*U[:,0]    + w[5]*U[:,1]    \
                # + w[6]*U[:,2]    + w[7]*U[:,3]    + w[8]*U[:,4]
        # V[:,1]  = w[0]*U[:,-3]   + w[1]*U[:,-2]   + w[2]*U[:,-1]   \
                # + w[3]*U[:,0]    + w[4]*U[:,1]    + w[5]*U[:,2]    \
                # + w[6]*U[:,3]    + w[7]*U[:,4]    + w[8]*U[:,5]
        # V[:,2]  = w[0]*U[:,-2]   + w[1]*U[:,-1]   + w[2]*U[:,0]    \
                # + w[3]*U[:,1]    + w[4]*U[:,2]    + w[5]*U[:,3]    \
                # + w[6]*U[:,4]    + w[7]*U[:,5]    + w[8]*U[:,6]
        # V[:,3]  = w[0]*U[:,-1]   + w[1]*U[:,0]    + w[2]*U[:,1]    \
                # + w[3]*U[:,2]    + w[4]*U[:,3]    + w[5]*U[:,4]    \
                # + w[6]*U[:,5]    + w[7]*U[:,6]    + w[8]*U[:,7]
        # V[:,jj] = w[0]*U[:,jj-4] + w[1]*U[:,jj-3] + w[2]*U[:,jj-2] \
                # + w[3]*U[:,jj-1] + w[4]*U[:,jj]   + w[5]*U[:,jj+1] \
                # + w[6]*U[:,jj+2] + w[7]*U[:,jj+3] + w[8]*U[:,jj+4]
        # V[:,-4] = w[0]*U[:,-8]   + w[1]*U[:,-7]   + w[2]*U[:,-6]   \
                # + w[3]*U[:,-5]   + w[4]*U[:,-4]   + w[5]*U[:,-3]   \
                # + w[6]*U[:,-2]   + w[7]*U[:,-1]   + w[8]*U[:,0]
        # V[:,-3] = w[0]*U[:,-7]   + w[1]*U[:,-6]   + w[2]*U[:,-5]   \
                # + w[3]*U[:,-4]   + w[4]*U[:,-3]   + w[5]*U[:,-2]   \
                # + w[6]*U[:,-1]   + w[7]*U[:,0]    + w[8]*U[:,1]
        # V[:,-2] = w[0]*U[:,-6]   + w[1]*U[:,-5]   + w[2]*U[:,-4]   \
                # + w[3]*U[:,-3]   + w[4]*U[:,-2]   + w[5]*U[:,-1]   \
                # + w[6]*U[:,0]    + w[7]*U[:,1]    + w[8]*U[:,2]
        # V[:,-1] = w[0]*U[:,-5]   + w[1]*U[:,-4]   + w[2]*U[:,-3]   \
                # + w[3]*U[:,-2]   + w[4]*U[:,-1]   + w[5]*U[:,0]    \
                # + w[6]*U[:,1]    + w[7]*U[:,2]    + w[8]*U[:,3]
    # else :
        # sys.exit("\nInput FD should be 2, 4, 6, or 8.\n")
    
    # return V / dth

###########################################################################

def setGhostNodes( U \
, rhoB, rhoT, wI, wE ) :
      
    tmpB = rhoB
    tmpT = rhoT
    for i in np.arange(1,len(wI)) :
        tmpB = tmpB - wI[i]*U[0,i,:]
        tmpT = tmpT - wI[i]*U[0,-i-1,:]
    U[0,0,:] = tmpB / wI[0]
    U[0,-1,:] = tmpT / wI[0]
    
    tmpB = 0.
    tmpT = 0.
    for i in np.arange(0,len(wE)) :
        tmpB = tmpB + wE[i]*U[1,i+1,:]
        tmpT = tmpT + wE[i]*U[1,-i-2,:]
    U[1,0,:]  = tmpB
    U[1,-1,:] = tmpT
    
    tmpB = 0.
    tmpT = 0.
    for i in np.arange(0,len(wE)) :
        tmpB = tmpB + wE[i]*U[2,i+1,:]
        tmpT = tmpT + wE[i]*U[2,-i-2,:]
    U[2,0,:]  = tmpB
    U[2,-1,:] = tmpT
    
    return U

###########################################################################

def odefun( t, U \
, setGhostNodes, Dr, Dth, HVr, HVth \
, th, r, c ) :
    
    U = setGhostNodes( U )
    
    V = np.zeros( np.shape(U) )
    
    V[0,1:-1,:] = c *                                           \
    ( np.cos(th)*Dr(U[1,:,:]) - np.sin(th)/r*Dth(U[1,1:-1,:])   \
    + np.sin(th)*Dr(U[2,:,:]) + np.cos(th)/r*Dth(U[2,1:-1,:]) ) \
    + HVr(U[0,:,:])
    
    rho_r  = Dr( U[0,:,:] )
    rho_th = Dth( U[0,1:-1,:] )
    
    V[1,1:-1,:] = c *                          \
    ( np.cos(th)*rho_r - np.sin(th)/r*rho_th ) \
    + HVr(U[1,:,:])
    
    V[2,1:-1,:] = c *                          \
    ( np.sin(th)*rho_r + np.cos(th)/r*rho_th ) \
    + HVr(U[2,:,:])
    
    return V

###########################################################################