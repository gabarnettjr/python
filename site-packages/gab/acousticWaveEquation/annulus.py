import numpy as np

###########################################################################

#Get number of angular levels so that the angular spacing and radial
#spacing are nearly equal along the inner circle, and the number of angular
#levels is odd (for periodic PS):

def getNth( innerRadius, outerRadius, nr ):
    
    nth = np.int(np.round( 2*np.pi * innerRadius * (nr-2)/(outerRadius-innerRadius) ))
    
    if np.mod( nth, 2 ) == 0 :
        nth = nth + 1
    
    return nth

###########################################################################

def getTopoFunc( innerRadius ) :

    k = 5*innerRadius
    amp = .05
    
    def rSurf( th ) :
        return innerRadius + amp*np.sin(k*th)
    
    def rSurfPrime( th ) :
        return amp*k*np.cos(k*th)
    
    return rSurf, rSurfPrime

###########################################################################

def getHeightCoordinate( rTop, rBot ) :
    
    rSurf, rSurfPrime = getTopoFunc( rBot )
    
    def s( r, th ) :
        return ( r - rSurf(th) ) / ( rTop - rSurf(th) ) * ( rTop - rBot ) + rBot
    
    def dsdth( r, th ) :
        return rSurfPrime(th) * ( r - rTop ) * ( rTop - rBot ) / ( rTop - rSurf(th) )**2.
    
    def dsdr( r, th ) :
        return ( rTop - rBot ) / ( rTop - rSurf(th) )
    
    return rSurf, dsdth, dsdr

###########################################################################

#thth and ss define a mesh on an annulus, and it returns radii in the
#untransformed space.

def getRadii( thth, ss, rBot, rTop, rSurf ) :
    
    rr = (ss-rBot) / (rTop-rBot) * (rTop-rSurf(thth)) + rSurf(thth)
    
    return rr

###########################################################################

def setGhostNodes( U \
, rhoB, rhoT, wIinner, wEinner, wIouter, wEouter, stc ) :
    
    for i in range( 1, stc ) :
        rhoB = rhoB - wIinner[i]*U[0,i,:]
        rhoT = rhoT - wIouter[i]*U[0,-i-1,:]
    U[0,0,:]  = rhoB / wIinner[0]
    U[0,-1,:] = rhoT / wIouter[0]
    
    rhoB = 0.
    rhoT = 0.
    for i in range( 0, stc ) :
        rhoB = rhoB + wEinner[i]*U[1,i+1,:]
        rhoT = rhoT + wEouter[i]*U[1,-i-2,:]
    U[1,0,:]  = rhoB
    U[1,-1,:] = rhoT
    
    rhoB = 0.
    rhoT = 0.
    for i in range( 0, stc ) :
        rhoB = rhoB + wEinner[i]*U[2,i+1,:]
        rhoT = rhoT + wEouter[i]*U[2,-i-2,:]
    U[2,0,:]  = rhoB
    U[2,-1,:] = rhoT
    
    return U

###########################################################################

def odefun( t, U \
, setGhostNodes, Ds, Dth, HVs, HVth \
, th, r, c \
, dsdth, dsdr ) :
    
    U = setGhostNodes( U )
    
    V = np.zeros( np.shape(U) )
    
    u_s   = Ds( U[1,:,:] )
    v_s   = Ds( U[2,:,:] )
    
    V[0,1:-1,:] = c *                                                           \
    ( np.cos(th)*(dsdr*u_s) - np.sin(th)/r * ( Dth(U[1,1:-1,:]) + dsdth*u_s )   \
    + np.sin(th)*(dsdr*v_s) + np.cos(th)/r * ( Dth(U[2,1:-1,:]) + dsdth*v_s ) ) \
    + HVs( U[0,:,:] ) + HVth( U[0,1:-1,:] )
    
    rho_r  = Ds( U[0,:,:] )
    rho_th = Dth( U[0,1:-1,:] ) + dsdth * rho_r
    rho_r  = dsdr * rho_r
    
    V[1,1:-1,:] = c *                              \
    ( np.cos(th) * rho_r - np.sin(th)/r * rho_th ) \
    + HVs( U[1,:,:] ) + HVth( U[1,1:-1,:] )
    
    V[2,1:-1,:] = c *                              \
    ( np.sin(th) * rho_r + np.cos(th)/r * rho_th ) \
    + HVs( U[2,:,:] ) + HVth( U[2,1:-1,:] )
    
    return V

###########################################################################