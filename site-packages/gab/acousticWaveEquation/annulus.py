import sys
import numpy as np

###########################################################################

def getMainIndex( FDr, FDth, nr, nth ) :
    
    if FDr == 2 :
        ii = np.arange( 1, nr-1 )
    elif FDr == 4 :
        ii = np.arange( 2, nr-2 )
    else :
        sys.exit("\nError: FDr should be 2 or 4.\n")
    
    if FDth == 2 :
        jj = np.arange( 1, nth-1 )
    elif FDth == 4 :
        jj = np.arange( 2, nth-2 )
    elif FDth == 6 :
        jj = np.arange( 3, nth-3 )
    else :
        sys.exit("\nError: FDth should be 2 or 4 or 6.\n")
    
    return ii, jj

###########################################################################

def getFDweights( derivative, FD ) :
    
    if derivative == 1 :
        if FD == 2 :
            w = np.array([ [ -1./2., 0., 1./2. ] ])
        elif FD == 4 :
            w = np.array([ [ -1./4.,  -5./6.,  3./2., -1./2.,  1./12. ] \
                         , [  1./12., -2./3.,  0.,     2./3., -1./12. ] \
                         , [ -1./12.,  1./2., -3./2.,  5./6.,  1./4.  ] ])
        elif FD == 6 :
            w = np.array([ [ -1./6.,  -77./60., 5./2., -5./3.,  5./6., -1./4.,   1./30. ] \
                         , [  1./30., -2./5.,  -7./12., 4./3., -1./2.,  2./15., -1./60. ] \
                         , [ -1./60.,  3./20., -3./4.,  0.,     3./4., -3./20.,  1./60. ] \
                         , [  1./60., -2./15.,  1./2., -4./3.,  7./12., 2./5.,  -1./30. ] \
                         , [ -1./30.,  1./4.,  -5./6.,  5./3., -5./2.,  77./60., 1./6.  ] ])
        else :
            sys.exit("\nError: FD should be 2 or 4 or 6.\n")
    elif derivative == 2 :
        if FD == 2 :
            w = np.array([ [ 1., -2., 1. ] ])
        else :
            sys.exit("\nError: FD should be 2 for this.\n")
    elif derivative == 4 :
        if FD == 4 :
            w = np.array([ [ 1., -4., 6., -4., 1. ] \
                         , [ 1., -4., 6., -4., 1. ] \
                         , [ 1., -4., 6., -4., 1. ] ])
        else :
            sys.exit("\nError: FD should be 4 for this.\n")
    elif derivative == 6 :
        if FD == 6 :
            w = np.array([ [ 1., -6., 15., -20., 15., -6., 1. ] \
                         , [ 1., -6., 15., -20., 15., -6., 1. ] \
                         , [ 1., -6., 15., -20., 15., -6., 1. ] \
                         , [ 1., -6., 15., -20., 15., -6., 1. ] \
                         , [ 1., -6., 15., -20., 15., -6., 1. ] ])
        else :
            sys.exit("\nError: FD should be 6 for this.\n")
    else :
        sys.exit("\nError: derivative should be 1, 2, 4, or 6.\n")
    
    return w

###########################################################################

def getInterpExtrapWeights( FDr ) :
    
    if FDr == 2 :
        wI = np.array([ 1./2., 1./2. ])
        wE = np.array([ 2.,   -1     ])
    elif FDr == 4 :
        wI = np.array([ 5./16., 15./16., -5./16., 1./16. ])
        wE = np.array([ 4.,    -6.,       4.,    -1.     ])
        # wI = np.array([ 35./128., 35./32., -35./64., 7./32., -5./128. ])
        # wE = np.array([ 5.,      -10.,      10.,    -5.,      1.      ])
    else :
        sys.exit("\nError: FDr should be 2 or 4.\n")
    
    return wI, wE

###########################################################################

#Apply FD operator in radial direction (r):

def Lr( U, FD, ii, w, dr ) :
    
    if FD == 2 :
        U = w[0,0]*U[ii-1,:] + w[0,1]*U[ii,:] + w[0,2]*U[ii+1,:]
        return U/dr
    elif FD == 4 :
        V = np.zeros(( np.shape(U)[0]-2, np.shape(U)[1] ))
        V[0,:]    = w[0,0]*U[0,:]    + w[0,1]*U[1,:]    + w[0,2]*U[2,:]  \
                  + w[0,3]*U[3,:]    + w[0,4]*U[4,:]
        V[1:-1,:] = w[1,0]*U[ii-2,:] + w[1,1]*U[ii-1,:] + w[1,2]*U[ii,:] \
                  + w[1,3]*U[ii+1,:] + w[1,4]*U[ii+2,:]
        V[-1,:]   = w[2,0]*U[-5,:]   + w[2,1]*U[-4,:]   + w[2,2]*U[-3,:] \
                  + w[2,3]*U[-2,:]   + w[2,4]*U[-1,:]
        return V/dr
    else :
        sys.exit("\nInput FD should be 2 or 4.\n")

###########################################################################

#Apply FD operator in angular direction (th):

def Lth( U, FD, jj, w, dth ) :
    
    V = np.zeros( np.shape(U) )
    
    if FD == 2 :
        V[:,0]  = w[0]*U[:,-1]   + w[1]*U[:,0]  + w[2]*U[:,1]
        V[:,jj] = w[0]*U[:,jj-1] + w[1]*U[:,jj] + w[2]*U[:,jj+1]
        V[:,-1] = w[0]*U[:,-2]   + w[1]*U[:,-1] + w[2]*U[:,0]
    elif FD == 4 :
        V[:,0]  = w[0]*U[:,-2]   + w[1]*U[:,-1]    + w[2]*U[:,0]  \
                + w[3]*U[:,1]    + w[4]*U[:,2]
        V[:,1]  = w[0]*U[:,-1]   + w[1]*U[:,0]     + w[2]*U[:,1]  \
                + w[3]*U[:,2]    + w[4]*U[:,3]
        V[:,jj] = w[0]*U[:,jj-2] + w[1]*U[:,jj-1]  + w[2]*U[:,jj] \
                + w[3]*U[:,jj+1] + w[4]*U[:,jj+2]
        V[:,-2] = w[0]*U[:,-4]   + w[1]*U[:,-3]    + w[2]*U[:,-2] \
                + w[3]*U[:,-1]   + w[4]*U[:,0]
        V[:,-1] = w[0]*U[:,-3]   + w[1]*U[:,-2]    + w[2]*U[:,-1] \
                + w[3]*U[:,0]    + w[4]*U[:,1]
    elif FD == 6 :
        V[:,0]  = w[0]*U[:,-3]   + w[1]*U[:,-2]   + w[2]*U[:,-1]   \
                + w[3]*U[:,0]                                      \
                + w[4]*U[:,1]    + w[5]*U[:,2]    + w[6]*U[:,3]
        V[:,1]  = w[0]*U[:,-2]   + w[1]*U[:,-1]   + w[2]*U[:,0]    \
                + w[3]*U[:,1]                                      \
                + w[4]*U[:,2]    + w[5]*U[:,3]    + w[6]*U[:,4]
        V[:,2]  = w[0]*U[:,-1]   + w[1]*U[:,0]    + w[2]*U[:,1]    \
                + w[3]*U[:,2]                                      \
                + w[4]*U[:,3]    + w[5]*U[:,4]    + w[6]*U[:,5]
        V[:,jj] = w[0]*U[:,jj-3] + w[1]*U[:,jj-2] + w[2]*U[:,jj-1] \
                + w[3]*U[:,jj]                                     \
                + w[4]*U[:,jj+1] + w[5]*U[:,jj+2] + w[6]*U[:,jj+3]
        V[:,-3] = w[0]*U[:,-6]   + w[1]*U[:,-5]   + w[2]*U[:,-4]   \
                + w[3]*U[:,-3]                                     \
                + w[4]*U[:,-2]   + w[5]*U[:,-1]   + w[6]*U[:,0]
        V[:,-2] = w[0]*U[:,-5]   + w[1]*U[:,-4]   + w[2]*U[:,-3]   \
                + w[3]*U[:,-2]                                     \
                + w[4]*U[:,-1]   + w[5]*U[:,0]    + w[6]*U[:,1]
        V[:,-1] = w[0]*U[:,-4]   + w[1]*U[:,-3]   + w[2]*U[:,-2]   \
                + w[3]*U[:,-1]                                     \
                + w[4]*U[:,0]    + w[5]*U[:,1]    + w[6]*U[:,2]
    else :
        sys.exit("\nInput FD should be 2 or 4 or 6.\n")
    
    return V / dth

###########################################################################

def setGhostNodes( U \
, rhoB, rhoT, FDr, wI, wE ) :
    
    if FDr == 2 :
    
        U[0,0,:]  = 2*rhoB - U[0,1,:]
        U[0,-1,:] = 2*rhoT - U[0,-2,:]
        
        U[1,0,:]  = 2.*U[1,1,:]  - U[1,2,:]
        U[1,-1,:] = 2.*U[1,-2,:] - U[1,-3,:]
        
        U[2,0,:]  = 2.*U[2,1,:]  - U[2,2,:]
        U[2,-1,:] = 2.*U[2,-2,:] - U[2,-3,:]
    
    elif FDr == 4 :
        
        U[0,0,:]  = ( rhoB - wI[1]*U[0,1,:] - wI[2]*U[0,2,:] - wI[3]*U[0,3,:] ) / wI[0]
        U[0,-1,:] = ( rhoT - wI[1]*U[0,-2,:] - wI[2]*U[0,-3,:] - wI[3]*U[0,-4,:] ) / wI[0]
        
        U[1,0,:]  = wE[0]*U[1,1,:]  + wE[1]*U[1,2,:]  + wE[2]*U[1,3,:]  + wE[3]*U[1,4,:]
        U[1,-1,:] = wE[0]*U[1,-2,:] + wE[1]*U[1,-3,:] + wE[2]*U[1,-4,:] + wE[3]*U[1,-5,:]
        
        U[2,0,:]  = wE[0]*U[2,1,:]  + wE[1]*U[2,2,:]  + wE[2]*U[2,3,:]  + wE[3]*U[2,4,:]
        U[2,-1,:] = wE[0]*U[2,-2,:] + wE[1]*U[2,-3,:] + wE[2]*U[2,-4,:] + wE[3]*U[2,-5,:]
        
        # U[0,0,:]  = ( rhoB - wI[1]*U[0,1,:] - wI[2]*U[0,2,:] - wI[3]*U[0,3,:] - wI[4]*U[0,4,:] ) / wI[0]
        # U[0,-1,:] = ( rhoT - wI[1]*U[0,-2,:] - wI[2]*U[0,-3,:] - wI[3]*U[0,-4,:] - wI[4]*U[0,-5,:] ) / wI[0]
        
        # U[1,0,:]  = wE[0]*U[1,1,:]  + wE[1]*U[1,2,:]  + wE[2]*U[1,3,:]  + wE[3]*U[1,4,:]  + wE[4]*U[1,5,:]
        # U[1,-1,:] = wE[0]*U[1,-2,:] + wE[1]*U[1,-3,:] + wE[2]*U[1,-4,:] + wE[3]*U[1,-5,:] + wE[4]*U[1,-6,:]
        
        # U[2,0,:]  = wE[0]*U[2,1,:]  + wE[1]*U[2,2,:]  + wE[2]*U[2,3,:]  + wE[3]*U[2,4,:]  + wE[4]*U[2,5,:]
        # U[2,-1,:] = wE[0]*U[2,-2,:] + wE[1]*U[2,-3,:] + wE[2]*U[2,-4,:] + wE[3]*U[2,-5,:] + wE[4]*U[2,-6,:]
        
    else :
        
        sys.exit("\nError: FDr should be 2 or 4.\n")
    
    return U

###########################################################################

def odefun( t, U \
, setGhostNodes, Dr, Dth, HVr, HVth \
, th, r, c ) :
    
    U = setGhostNodes( U )
    
    V = np.zeros( np.shape(U) )
    
    V[0,1:-1,:] = c * \
    ( np.cos(th)*Dr(U[1,:,:]) - np.sin(th)/r*Dth(U[1,1:-1,:]) \
    + np.sin(th)*Dr(U[2,:,:]) + np.cos(th)/r*Dth(U[2,1:-1,:]) )
    # + HVr(U[0,:,:]) + HVth(U[0,1:-1,:])
    
    V[1,1:-1,:] = c * \
    ( np.cos(th)*Dr(U[0,:,:]) - np.sin(th)/r*Dth(U[0,1:-1,:]) )
    # + HVr(U[1,:,:]) + HVth(U[1,1:-1,:])
    
    V[2,1:-1,:] = c * \
    ( np.sin(th)*Dr(U[0,:,:]) + np.cos(th)/r*Dth(U[0,1:-1,:]) )
    # + HVr(U[2,:,:]) + HVth(U[2,1:-1,:])
    
    return V

###########################################################################