import sys
import numpy as np
import matplotlib.pyplot as plt
from gab import phs2
from scipy import spatial
import time

###########################################################################

def getConstants() :
    
    Cp = 1004.
    Cv = 717.
    Rd = Cp - Cv
    g = 9.81
    Po = 10.**5.
    
    return Cp, Cv, Rd, g, Po

###########################################################################

def getSpaceDomain( testCase, dx, ds, FD ) :
    
    if testCase == "bubble" :
        xLeft = 0.
        xRight = 10000.
        zTop = 10000.
        kap = 10.
        def zSurf(xTilde) :
            # return 1000. * np.exp( -(kap*(xTilde-6000.)/(xRight-xLeft))**2 )
            return 500. * ( 1. + np.sin( 2.*np.pi*xTilde / 5000. ) )
            # return np.zeros( np.shape(xTilde) )
        def zSurfPrime(xTilde) :
            # return -2. * ( kap*(xTilde-6000.)/(xRight-xLeft) ) * kap/(xRight-xLeft) * zSurf(xTilde)
            return np.pi/5. * np.cos( 2.*np.pi*xTilde / 5000. )
            # return np.zeros( np.shape(xTilde) )
    elif testCase == "igw" :
        xLeft = 0.
        xRight = 300000.
        zTop = 10000.
        def zSurf(xTilde) :
            return np.zeros( np.shape(xTilde) )
        def zSurfPrime(xTilde) :
            return np.zeros( np.shape(xTilde) )
    elif testCase == "densityCurrent" :
        xLeft = -25600.
        xRight = 25600.
        zTop = 6400.
        def zSurf(xTilde) :
            return np.zeros( np.shape(xTilde) )
        def zSurfPrime(xTilde) :
            return np.zeros( np.shape(xTilde) )
    elif testCase == "doubleDensityCurrent" :
        xLeft = -6400.
        xRight = 6400.
        zTop = 6400.
        def zSurf(xTilde) :
            return 1000. * np.exp( -(16.*(xTilde-1000.)/(xRight-xLeft))**2. )
            # return np.zeros( np.shape(xTilde) )
        def zSurfPrime(xTilde) :
            return -2. * 16.*(xTilde-1000.)/(xRight-xLeft) *  16./(xRight-xLeft) * zSurf(xTilde)
            # return np.zeros( np.shape(xTilde) )
    elif testCase == "movingDensityCurrent" :
        xLeft = -18000.
        xRight = 18000.
        zTop = 6400.
        def zSurf(xTilde) :
            return np.zeros( np.shape(xTilde) )
        def zSurfPrime(xTilde) :
            return np.zeros( np.shape(xTilde) )
    else :
        sys.exit( "\nError: Invalid test case string.\n" )
    
    nLev = np.int( np.round( zTop / ds ) )
    nCol = np.int( np.round( (xRight-xLeft) / dx ) )
    
    x = np.linspace( xLeft+dx/2.-(FD/2.)*dx, xRight-dx/2.+(FD/2.)*dx, nCol+FD )
    zs = zSurf(x)
    dz = ( zTop - zs ) / zTop * ds
    z = np.zeros(( nLev+2, nCol+FD ))
    z[0,:] = zs - dz/2
    for i in np.arange(1,nLev+1) :
        z[i,:] = zs + dz/2 + (i-1)*dz
    z[nLev+1,:] = zTop + dz/2.
    x = np.tile( x, (nLev+2,1) )
    
    return xLeft, xRight, nLev, nCol, zTop, zSurf, zSurfPrime, x, z

###########################################################################

def getTimeDomain( testCase, dx, ds ) :
    
    maxVel = 40.
    
    if testCase == "bubble" :
        tf = 1500.
    elif testCase == "igw" :
        tf = 3000.
    elif testCase == "densityCurrent" :
        tf = 900.
    elif testCase == "doubleDensityCurrent" :
        tf = 900.
    elif testCase == "movingDensityCurrent" :
        tf = 900.
    else :
        sys.exit( "\nError: Invalid testCase string.\n" )
    
    dx = min(dx,ds)
    dt = dx / 16 / maxVel
    dt = 1. / np.round(1./dt)
    nTimesteps = np.int( np.round(tf/dt) + 1e-12 )
    dt = tf / nTimesteps
    
    dtEul = dt / 10.
    
    return tf, dt, dtEul, nTimesteps

###########################################################################

#Scale-preserving and terrain-following height coordinate transformation.
#zBottom is assumed to be zero, and zTop is a positive length in meters.
#zSurf and zSurfPrime are functions of x
#s, dsdx, and dsdz are functions of original variables xTilde and zTilde.

def getHeightCoordinate( zTop, zSurf, zSurfPrime ) :
    
    def s( xTilde, zTilde ) :
        return ( zTilde - zSurf(xTilde) ) / ( zTop - zSurf(xTilde) ) * zTop
    
    def dsdx( xTilde, zTilde ) :
        return ( zTilde - zTop ) * zSurfPrime(xTilde) / ( zTop - zSurf(xTilde) )**2. * zTop
    
    def dsdz( xTilde, zTilde ) :
        return zTop / ( zTop - zSurf(xTilde) )
    
    return s, dsdx, dsdz

###########################################################################

#Get unit tangent and normal vectors on bottom boundary:

def getTanNorm( zSurfPrime, x ) :
    
    Tz = zSurfPrime( x )
    Tx = np.ones( np.shape(Tz) )
    normT = np.sqrt( Tx**2 + Tz**2 )
    Tx = Tx / normT
    Tz = Tz / normT
    Nx = -Tz
    Nz = Tx
    
    return Tx, Tz, Nx, Nz

###########################################################################

def getInitialConditions( testCase, formulation \
, nLev, nCol, FD, x, z \
, Cp, Cv, Rd, g, Po \
, dsdz ) :
    
    U = np.zeros(( 4, nLev+2, nCol+FD ))
    
    if testCase == "bubble" :
        thetaBar = 300. * np.ones(( nLev+2, nCol+FD ))
        piBar = 1. - g / Cp / thetaBar * z
        R = 1500.
        xc = 5000.
        zc = 3000.
        r = np.sqrt( (x-xc)**2 + (z-zc)**2 )
        ind = r < R
        thetaPrime0 = np. zeros( np.shape(r) )
        thetaPrime0[ind] = 2. * ( 1. - r[ind]/R )
        piPrime0 = 0.
        U[0,:,:] = np.zeros(( nLev+2, nCol+FD ))
    elif testCase == "igw" :
        N = .01
        theta0 = 300.
        thetaBar = theta0 * np.exp( (N**2/g) * z )
        piBar = 1. + g**2. / Cp / theta0 / N**2. * ( np.exp(-N**2./g*z) - 1. )
        thetaC = .01
        hC = 10000.
        aC = 5000.
        xC = 100000.
        thetaPrime0 = thetaC * np.sin( np.pi*z/hC ) / ( 1. + ((x-xC)/aC)**2 )
        piPrime0 = 0.
        U[0,:,:] = 20. * np.ones( np.shape(thetaPrime0) )
    elif testCase == "densityCurrent" :
        thetaBar = 300. * np.ones(( nLev+2, nCol+FD ))
        piBar = 1. - g / Cp / thetaBar * z
        xc = 0.
        zc = 3000.
        xr = 4000.
        zr = 2000.
        rTilde = np.sqrt( ((x-xc)/xr)**2 + ((z-zc)/zr)**2 )
        Tprime0 = np.zeros( np.shape(thetaBar) )
        ind = rTilde <= 1
        Tprime0[ind] = -15./2. * ( 1. + np.cos(np.pi*rTilde[ind]) )
        thetaPrime0 = Tprime0 / piBar
        piPrime0 = 0.
        U[0,:,:] = np.zeros( np.shape(thetaBar) )
    elif testCase == "doubleDensityCurrent" :
        thetaBar = 300. * np.ones(( nLev+2, nCol+FD ))
        piBar = 1. - g / Cp / thetaBar * z
        xc1 = -6400.
        xc2 = 6400.
        zc = 3000.
        xr = 4000.
        zr = 2000.
        rTilde1 = np.sqrt( ((x-xc1)/xr)**2 + ((z-zc)/zr)**2 )
        rTilde2 = np.sqrt( ((x-xc2)/xr)**2 + ((z-zc)/zr)**2 )
        Tprime0 = np.zeros( np.shape(thetaBar) )
        ind1 = rTilde1 <= 1
        ind2 = rTilde2 <= 1
        Tprime0[ind1] = -15./2. * ( 1. + np.cos(np.pi*rTilde1[ind1]) )
        Tprime0[ind2] = -15./2. * ( 1. + np.cos(np.pi*rTilde2[ind2]) )
        thetaPrime0 = Tprime0 / piBar
        piPrime0 = 0.
        U[0,:,:] = np.zeros( np.shape(thetaBar) )
    elif testCase == "movingDensityCurrent" :
        thetaBar = 300. * np.ones(( nLev+2, nCol+FD ))
        piBar = 1. - g / Cp / thetaBar * z
        xc = 0.
        zc = 3000.
        xr = 4000.
        zr = 2000.
        rTilde = np.sqrt( ((x-xc)/xr)**2 + ((z-zc)/zr)**2 )
        Tprime0 = np.zeros( np.shape(thetaBar) )
        ind = rTilde <= 1
        Tprime0[ind] = -15./2. * ( 1. + np.cos(np.pi*rTilde[ind]) )
        thetaPrime0 = Tprime0 / piBar
        piPrime0 = 0.
        U[0,:,:] = 20. * np.ones( np.shape(thetaBar) )
    else :
        sys.exit("\nError: Invalid test case string.\n")
    
    U[1,:,:] = np.zeros( np.shape(thetaBar) )
    U[2,:,:] = thetaBar + thetaPrime0
    
    if formulation == "exner" :
        U[3,:,:] = piBar + piPrime0
    elif formulation == "hydrostaticPressure" :
        U[3,:,:] = -g / Rd / U[2,:,:] / dsdz(x,z) * Po * (piBar+piPrime0)**(Cv/Rd)
        dpidsBar = -g / Rd / thetaBar / dsdz(x,z) * Po * piBar**(Cv/Rd)
        sys.exit( "\nError: This formulation isn't really working yet.  Use exner.\n" )
    else :
        sys.exit( "\nError: Invalid formulation string.\n" )
    
    return U, thetaBar, piBar

###########################################################################

def getIndexes( X, Z, xLeft, xRight, zSurf, zTop, FD, nLev, nCol ) :
    
    x = X.flatten()
    z = Z.flatten()
    
    pts = np.transpose( np.vstack((x,z)) )
    tree = spatial.cKDTree( pts )
    
    class ind :
        pass
    
    ind.m = (x>xLeft) & (x<xRight) & (z>zSurf(x)) & (z<zTop)
    
    ind.gl = (x<xLeft)
    ind.r  = tree.query( np.transpose( np.vstack(( x[ind.gl]+(xRight-xLeft), z[ind.gl] )) ), 1 )
    ind.r  = ind.r[1]
    
    ind.gr = (x>xRight)
    ind.l  = tree.query( np.transpose( np.vstack(( x[ind.gr]-(xRight-xLeft), z[ind.gr] )) ), 1 )
    ind.l  = ind.l[1]
    
    FDo2 = np.int(FD/2)
    
    ind.gb = tree.query( np.transpose( np.vstack(( X[0,FDo2:nCol+FDo2], Z[0,FDo2:nCol+FDo2] )) ), 1 )
    ind.gb = ind.gb[1]
    
    ind.b = tree.query( np.transpose( np.vstack(( X[1,FDo2:nCol+FDo2], Z[1,FDo2:nCol+FDo2] )) ), 1 )
    ind.b = ind.b[1]
    
    ind.gt = tree.query( np.transpose( np.vstack(( X[nLev+1,FDo2:nCol+FDo2], Z[nLev+1,FDo2:nCol+FDo2] )) ), 1 )
    ind.gt = ind.gt[1]
    
    ind.t = tree.query( np.transpose( np.vstack(( X[nLev,FDo2:nCol+FDo2], Z[nLev,FDo2:nCol+FDo2] )) ), 1 )
    ind.t = ind.t[1]
    
    return ind

###########################################################################

def plotNodes( x, z, ind, testCase ) :
    
    x = x.flatten()
    z = z.flatten()

    ms = 12

    plt.plot( x, z, ".", color="black" )
    plt.plot( x[ind.m],  z[ind.m],  "o", color="black",  fillstyle="none", markersize=10 )
    plt.plot( x[ind.gl], z[ind.gl], "o", color="red",    fillstyle="none", markersize=ms )
    plt.plot( x[ind.r],  z[ind.r],  "s", color="red",    fillstyle="none", markersize=ms )
    plt.plot( x[ind.gr], z[ind.gr], "o", color="blue",   fillstyle="none", markersize=ms )
    plt.plot( x[ind.l],  z[ind.l],  "s", color="blue",   fillstyle="none", markersize=ms )
    plt.plot( x[ind.gb], z[ind.gb], "^", color="orange", fillstyle="none", markersize=ms )
    plt.plot( x[ind.b],  z[ind.b],  "v", color="orange", fillstyle="none", markersize=ms )
    plt.plot( x[ind.gt], z[ind.gt], "v", color="green",  fillstyle="none", markersize=ms )
    plt.plot( x[ind.t],  z[ind.t],  "^", color="green",  fillstyle="none", markersize=ms )
    if testCase != "igw" :
        plt.axis( 'equal' )
    plt.show()

###########################################################################

#Apply a differential operator (first derivative or HV) laterally:

def LxFD( U, w, jj, dx, FD, FDo2 ) :
    V = 0
    if len(np.shape(U)) == 3 :
        for i in range(FD+1) :
            V = V + w[i] * U[:,:,jj-FDo2+i]
    elif len(np.shape(U)) == 2 :
        for i in range(FD+1) :
            V = V + w[i] * U[:,jj-FDo2+i]
    else :
        sys.exit( "\nError: Input U should be a 2D or 3D array.\n" )
    return V / dx

###########################################################################

#Apply a differential operator (first derivative or HV) vertically:

def LsFD( U, w, ii, ds ) :
    if len(np.shape(U)) == 3 :
        V = w[0]*U[:,ii-1,:] + w[1]*U[:,ii,:] + w[2]*U[:,ii+1,:,]
    elif len(np.shape(U)) == 2 :
        V = w[0]*U[ii-1,:]   + w[1]*U[ii,:]   + w[2]*U[ii+1,:,]
    else :
        sys.exit( "\nError: Input U should be a 2D or 3D array.\n" )
    return V / ds

###########################################################################

def setGhostNodesFD( U \
, Tx, Tz, Nx, Nz, bigTx, bigTz \
, nLev, nCol, thetaBar, g, Cp \
, normGradS, ds, dsdxBottom, dsdzBottom \
, wx, jj, dx, FD, FDo2 ) :
    
    #extrapolate uT to bottom ghost nodes:
    uT = U[0,1:3,:][:,jj] * bigTx + U[1,1:3,:][:,jj] * bigTz
    uT = 2*uT[0,:] - uT[1,:]
    
    #get uN on bottom ghost nodes:
    uN = U[0,1,jj]*Nx + U[1,1,jj]*Nz
    uN = -uN
    
    #use uT and uN to get (u,w) on bottom ghost nodes, then get (u,w) on top ghost nodes:
    U[0,0,jj] = uT*Tx + uN*Nx
    U[1,0,jj] = uT*Tz + uN*Nz
    U[0,nLev+1,jj] = 2*U[0,nLev,jj] - U[0,nLev-1,jj]
    U[1,nLev+1,jj] = -U[1,nLev,jj]
    
    #extrapolate theta to bottom and top ghost nodes WITHOUT using thetaBar:
    U[2,0,jj] = 2*U[2,1,jj] - U[2,2,jj]
    U[2,nLev+1,jj] = 2*U[2,nLev,jj] - U[2,nLev-1,jj]
    
    # #extrapolate theta to bottom and top ghost nodes using thetaBar:
    # U[2,0,jj] = thetaBar[0,jj] + 2*(U[2,1,jj]-thetaBar[1,jj]) \
    # - (U[2,2,jj]-thetaBar[2,jj])
    # U[2,nLev+1,jj] = thetaBar[nLev+1,jj] + 2*(U[2,nLev,jj]-thetaBar[nLev,jj]) \
    # - (U[2,nLev-1,jj]-thetaBar[nLev-1,jj])
    
    #get pi on bottom ghost nodes using derived BC:
    dpidx = LxFD( U[3,1:3,:], wx, jj, dx, FD, FDo2 )
    dpidx = 3./2.*dpidx[0,:] - 1./2.*dpidx[1,:]
    th = ( U[2,0,jj] + U[2,1,jj] ) / 2.
    U[3,0,jj] = U[3,1,jj] + ds/normGradS**2 * ( g/Cp/th*dsdzBottom + dpidx*dsdxBottom )
    
    #get pi on top ghost nodes:
    th = ( U[2,nLev,jj] + U[2,nLev+1,jj] ) / 2.
    U[3,nLev+1,jj] = U[3,nLev,jj] - ds/dsdzBottom*g/Cp/th
    
    #enforce periodic lateral boundary condition:
    U[:,:,0:FDo2] = U[:,:,nCol:nCol+FDo2]
    U[:,:,nCol+FDo2:nCol+FD] = U[:,:,FDo2:FD]
    
    return U

###########################################################################

def odefunFD( t, U \
, setGhostNodes \
, dx, ds, wx, ws, wxhv, wshv \
, ii, jj, i0, i1, j0, j1 \
, dsdx, dsdz, FD, FDo2 \
, Cp, Cv, Rd, g, gamma ) :
    
    #Initialize output array:
    V = np.zeros( np.shape(U) )
    
    #Set ghost node values for all variables:
    U = setGhostNodes( U )
    
    #Us and Ux:
    Us = LsFD( U[:,:,jj], ws, ii, ds )
    Ux = LxFD( U[:,ii,:], wx, jj, dx, FD, FDo2 )
    
    #Get u and sDot:
    u = np.tile( U[0,ii,:][:,jj], (4,1,1) )
    sDot = U[0,ii,:][:,jj] * dsdx + U[1,ii,:][:,jj] * dsdz
    sDot = np.tile( sDot, (4,1,1) )
    
    #RHS of ODE function:
    V[ :, i0:i1, j0:j1 ] = - u * Ux - sDot * Us
    V[ 0, i0:i1, j0:j1 ] = V[0,ii,:][:,jj] - Cp*U[2,ii,:][:,jj] * ( Ux[3,:,:] + Us[3,:,:]*dsdx )
    V[ 1, i0:i1, j0:j1 ] = V[1,ii,:][:,jj] - Cp*U[2,ii,:][:,jj] * ( Us[3,:,:]*dsdz ) - g
    V[ 3, i0:i1, j0:j1 ] = V[3,ii,:][:,jj] - Rd/Cv*U[3,ii,:][:,jj] * ( Ux[0,:,:]+Us[0,:,:]*dsdx + Us[1,:,:]*dsdz )
    
    #Add dissipation:
    V[ :, i0:i1, j0:j1 ] = V[:,ii,:][:,:,jj] \
    + gamma * np.abs(u) * LxFD( U[:,ii,:], wxhv, jj, dx, FD, FDo2 ) \
    + (1./2.) * np.abs(sDot) * LsFD( U[:,:,jj], wshv, ii, ds )
    
    return V

###########################################################################

#STILL WORKING ON THIS LEAP-FROG SEMI-LAGRANGIAN STEP:

def semiLagrangianTimestep( Un1, U \
, dt, xz ) :
    
    #2(a):
    xStar = x0[ind.m] - dt/2. * u0[ind.m]
    zStar = z0[ind.m] - dt/2. * w0[ind.m]
    
    #2(b):
    uStar = ( un1 + u0 ) / 2.
    wStar = ( wn1 + w0 ) / 2.
    
    #2(c):
    stencils = phs2.getStencils( x0, z0, xStar, zStar, stencilSize )
    A = phs2.getAmatrices( stencils, rbfOrder, polyOrder )
    W = phs2.getWeights( stencils, A, "i", 0 )
    uStar = np.sum( W*uStar[stencils.idx], axis=1 )
    wStar = np.sum( W*wStar[stencils.idx], axis=1 )
    
    #2(d):
    xn1 = x0[ind.m] - dt * uStar
    zn1 = z0[ind.m] - dt * wStar
    
    #3:
    stencils = phs2.getStencils( x0, z0, xn1, zn1, stencilSize )
    A = phs2.getAmatrices( stencils, rbfOrder, polyOrder )
    W = phs2.getWeights( stencils, A, "i", 0 )
    un1  = np.sum( W*un1[stencils.idx],  axis=1 )
    wn1  = np.sum( W*wn1[stencils.idx],  axis=1 )
    thn1 = np.sum( W*thn1[stencils.idx], axis=1 )
    pin1 = np.sum( W*pin1[stencils.idx], axis=1 )
    
    #4:
    x1 = xn1 + 2.*dt * u0[ind.m]
    z1 = zn1 + 2.*dt * w0[ind.m]
    u1 = un1 - 2.*dt * Cp * th0[ind.m] * ( Dx(pi0) + Ds(pi0)*dsdx )
    w1 = wn1 - 2.*Dt * ( Cp * th0[ind.m] * Ds(pi0)*dsdz + g )
    th1 = thn1
    pi1 = pin1 - 2.*dt * Rd/Cv*pi0[ind.m] * ( Dx(u0)+Ds(u0)*dsdx + Ds(w0)*dsdz )
    
    #5:
    stencils = phs2.getStencils( x1, z1, x0[ind.m], z0[ind.m], stencilSize )
    A = phs2.getAmatrices( stencils, rbfOrder, polyOrder )
    W = phs2.getWeights( stencils, A, "i", 0 )
    
    return x1, z1, u1, w1, th1, pi1

###########################################################################

def setFigAndContourLevels( testCase ) :
    
    if testCase == "densityCurrent" :
        fig = plt.figure( figsize = (28,3) )
        CL = np.arange( -16.5, 1.5, 1. )
    elif testCase == "doubleDensityCurrent" :
        fig = plt.figure( figsize = (30,12) )
        CL = np.arange( -16.5, 1.5, 1. )
    elif testCase == "movingDensityCurrent" :
        fig = plt.figure( figsize = (30,5) )
        CL = np.arange( -16.5, 1.5, 1. )
    elif testCase == "bubble" :
        fig = plt.figure( figsize = (18,14) )
        CL = np.arange( -.05, 2.15, .1 )
    elif testCase == "igw" :
        fig = plt.figure( figsize = (40,4) )
        CL = np.arange( -.0021, .0035, .0002 )
    else :
        sys.exit( "\nError: Invalid test case string.\n" )
    
    return fig, CL

###########################################################################

def saveContourPlot( U, t \
, testCase, var, fig \
, x, z, thetaBar, piBar, CL, FDo2 \
, xLeft, xRight, zTop, dx, ds ):
    
    if var == 0 :
        plt.contourf( x, z, U[0,:,:], 20 )
    elif var == 1 :
        plt.contourf( x, z, U[1,:,:], 20 )
    elif var == 2 :
        plt.contourf( x, z, U[2,:,:]-thetaBar, CL )
    elif var == 3 :
        plt.contourf( x, z, U[3,:,:]-piBar, 20 )
    else :
        sys.exit( "\nError: var should be 0, 1, 2, or 3 (u,w,th,pi)\n" )
    
    if testCase != "igw" :
        plt.axis( 'equal' )
    plt.axis( [ xLeft-FDo2*dx, xRight+FDo2*dx, -ds, zTop+ds ] )
    plt.colorbar()
    # plt.title( 'testCase = {0}, t = {1:04d}'.format(testCase,np.int(np.round(t)+1e-12)) )
    fig.savefig( '{0:04d}'.format(np.int(np.round(t)+1e-12)) + '.png', bbox_inches = 'tight' )
    plt.clf()

###########################################################################

def printInfo( U, et , t \
, thetaBar, piBar ) :
    
    print()
    print( "t =", np.int(np.round(t)+1e-10) )
    print( "et =", time.clock()-et )
    et = time.clock()
    print( "minmaxU =",  [ np.min(U[0,:,:]),          np.max(U[0,:,:])          ] )
    print( "minmaxW =",  [ np.min(U[1,:,:]),          np.max(U[1,:,:])          ] )
    print( "minmaxTh =", [ np.min(U[2,:,:]-thetaBar), np.max(U[2,:,:]-thetaBar) ] )
    print( "minmaxPi =", [ np.min(U[3,:,:]-piBar),    np.max(U[3,:,:]-piBar)    ] )
    
    return et

###########################################################################