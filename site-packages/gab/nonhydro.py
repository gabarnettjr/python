import sys
import numpy as np
import matplotlib.pyplot as plt
from gab import phs2
from scipy import spatial
import time

###########################################################################

def getConstants() :
    
    Cp = 1004.
    Cv = 717.
    Rd = Cp - Cv
    g = 9.81
    Po = 10.**5.
    
    return Cp, Cv, Rd, g, Po

###########################################################################

def getSpaceDomain( testCase, dx, ds, FD ) :
    
    if testCase == "bubble" :
        xLeft = 0.
        xRight = 10000.
        zTop = 10000.
        kap = 10.
        def zSurf(xTilde) :
            # return 1000. * np.exp( -(kap*(xTilde-6000.)/(xRight-xLeft))**2 )
            # return 500. * ( 1. + np.sin( 2.*np.pi*xTilde / 5000. ) )
            return np.zeros( np.shape(xTilde) )
        def zSurfPrime(xTilde) :
            # return -2. * ( kap*(xTilde-6000.)/(xRight-xLeft) ) * kap/(xRight-xLeft) * zSurf(xTilde)
            # return np.pi/5. * np.cos( 2.*np.pi*xTilde / 5000. )
            return np.zeros( np.shape(xTilde) )
    elif testCase == "igw" :
        xLeft = 0.
        xRight = 300000.
        zTop = 10000.
        def zSurf(xTilde) :
            return np.zeros( np.shape(xTilde) )
        def zSurfPrime(xTilde) :
            return np.zeros( np.shape(xTilde) )
    elif testCase == "densityCurrent" :
        xLeft = -25600.
        xRight = 25600.
        zTop = 6400.
        def zSurf(xTilde) :
            return np.zeros( np.shape(xTilde) )
        def zSurfPrime(xTilde) :
            return np.zeros( np.shape(xTilde) )
    elif testCase == "doubleDensityCurrent" :
        xLeft = -6400.
        xRight = 6400.
        zTop = 6400.
        def zSurf(xTilde) :
            return 1000. * np.exp( -(16.*(xTilde-1000.)/(xRight-xLeft))**2. )
            # return np.zeros( np.shape(xTilde) )
        def zSurfPrime(xTilde) :
            return -2. * 16.*(xTilde-1000.)/(xRight-xLeft) *  16./(xRight-xLeft) * zSurf(xTilde)
            # return np.zeros( np.shape(xTilde) )
    elif testCase == "movingDensityCurrent" :
        xLeft = -18000.
        xRight = 18000.
        zTop = 6400.
        def zSurf(xTilde) :
            return np.zeros( np.shape(xTilde) )
        def zSurfPrime(xTilde) :
            return np.zeros( np.shape(xTilde) )
    else :
        sys.exit( "\nError: Invalid test case string.\n" )
    
    nLev = np.int( np.round( zTop / ds ) )
    nCol = np.int( np.round( (xRight-xLeft) / dx ) )
    
    x = np.linspace( xLeft+dx/2.-(FD/2.)*dx, xRight-dx/2.+(FD/2.)*dx, nCol+FD )
    zs = zSurf(x)
    dz = ( zTop - zs ) / zTop * ds
    z = np.zeros(( nLev+2, nCol+FD ))
    z[0,:] = zs - dz/2
    for i in np.arange(1,nLev+1) :
        z[i,:] = zs + dz/2 + (i-1)*dz
    z[nLev+1,:] = zTop + dz/2.
    x = np.tile( x, (nLev+2,1) )
    
    return xLeft, xRight, nLev, nCol, zTop, zSurf, zSurfPrime, x, z

###########################################################################

def getTimeDomain( testCase, dx, ds ) :
    
    maxVel = 40.
    
    if testCase == "bubble" :
        tf = 1500.
    elif testCase == "igw" :
        tf = 3000.
    elif testCase == "densityCurrent" :
        tf = 900.
    elif testCase == "doubleDensityCurrent" :
        tf = 900.
    elif testCase == "movingDensityCurrent" :
        tf = 900.
    else :
        sys.exit( "\nError: Invalid testCase string.\n" )
    
    # dx = min( dx, ds )
    # dt = dx / 16. / maxVel
    # dt = 1. / np.round(1./dt)
    # nTimesteps = np.int( np.round(tf/dt) + 1e-12 )
    # dt = tf / nTimesteps
    # dtEul = dt / 10.
    
    dt = 1./8.
    dtEul = 1./16.
    nTimesteps = np.int( np.round(tf/dt) + 1e-12 )
    
    return tf, dt, dtEul, nTimesteps

###########################################################################

#Scale-preserving and terrain-following height coordinate transformation.
#zBottom is assumed to be zero, and zTop is a positive length in meters.
#zSurf and zSurfPrime are functions of x
#s, dsdx, and dsdz are functions of original variables xTilde and zTilde.

def getHeightCoordinate( zTop, zSurf, zSurfPrime ) :
    
    def s( xTilde, zTilde ) :
        return ( zTilde - zSurf(xTilde) ) / ( zTop - zSurf(xTilde) ) * zTop
    
    def dsdx( xTilde, zTilde ) :
        return ( zTilde - zTop ) * zSurfPrime(xTilde) / ( zTop - zSurf(xTilde) )**2. * zTop
    
    def dsdz( xTilde, zTilde ) :
        return zTop / ( zTop - zSurf(xTilde) )
    
    return s, dsdx, dsdz

###########################################################################

#Get unit tangent and normal vectors on bottom boundary:

def getTanNorm( zSurfPrime, x ) :
    
    Tz = zSurfPrime( x )
    Tx = np.ones( np.shape(Tz) )
    normT = np.sqrt( Tx**2 + Tz**2 )
    Tx = Tx / normT
    Tz = Tz / normT
    Nx = -Tz
    Nz = Tx
    
    return Tx, Tz, Nx, Nz

###########################################################################

def getInitialConditions( testCase, formulation \
, nLev, nCol, FD, x, z \
, Cp, Cv, Rd, g, Po \
, dsdz ) :
    
    U = np.zeros(( 4, nLev+2, nCol+FD ))
    
    if testCase == "bubble" :
        thetaBar = 300. * np.ones(( nLev+2, nCol+FD ))
        piBar = 1. - g / Cp / thetaBar * z
        R = 1500.
        xc = 5000.
        zc = 3000.
        r = np.sqrt( (x-xc)**2 + (z-zc)**2 )
        ind = r < R
        thetaPrime0 = np. zeros( np.shape(r) )
        thetaPrime0[ind] = 2. * ( 1. - r[ind]/R )
        piPrime0 = 0.
        U[0,:,:] = np.zeros(( nLev+2, nCol+FD ))
    elif testCase == "igw" :
        N = .01
        theta0 = 300.
        thetaBar = theta0 * np.exp( (N**2/g) * z )
        piBar = 1. + g**2. / Cp / theta0 / N**2. * ( np.exp(-N**2./g*z) - 1. )
        thetaC = .01
        hC = 10000.
        aC = 5000.
        xC = 100000.
        thetaPrime0 = thetaC * np.sin( np.pi*z/hC ) / ( 1. + ((x-xC)/aC)**2 )
        piPrime0 = 0.
        U[0,:,:] = 20. * np.ones( np.shape(thetaPrime0) )
    elif testCase == "densityCurrent" :
        thetaBar = 300. * np.ones(( nLev+2, nCol+FD ))
        piBar = 1. - g / Cp / thetaBar * z
        xc = 0.
        zc = 3000.
        xr = 4000.
        zr = 2000.
        rTilde = np.sqrt( ((x-xc)/xr)**2 + ((z-zc)/zr)**2 )
        Tprime0 = np.zeros( np.shape(thetaBar) )
        ind = rTilde <= 1
        Tprime0[ind] = -15./2. * ( 1. + np.cos(np.pi*rTilde[ind]) )
        thetaPrime0 = Tprime0 / piBar
        piPrime0 = 0.
        U[0,:,:] = np.zeros( np.shape(thetaBar) )
    elif testCase == "doubleDensityCurrent" :
        thetaBar = 300. * np.ones(( nLev+2, nCol+FD ))
        piBar = 1. - g / Cp / thetaBar * z
        xc1 = -6400.
        xc2 = 6400.
        zc = 3000.
        xr = 4000.
        zr = 2000.
        rTilde1 = np.sqrt( ((x-xc1)/xr)**2 + ((z-zc)/zr)**2 )
        rTilde2 = np.sqrt( ((x-xc2)/xr)**2 + ((z-zc)/zr)**2 )
        Tprime0 = np.zeros( np.shape(thetaBar) )
        ind1 = rTilde1 <= 1
        ind2 = rTilde2 <= 1
        Tprime0[ind1] = -15./2. * ( 1. + np.cos(np.pi*rTilde1[ind1]) )
        Tprime0[ind2] = -15./2. * ( 1. + np.cos(np.pi*rTilde2[ind2]) )
        thetaPrime0 = Tprime0 / piBar
        piPrime0 = 0.
        U[0,:,:] = np.zeros( np.shape(thetaBar) )
    elif testCase == "movingDensityCurrent" :
        thetaBar = 300. * np.ones(( nLev+2, nCol+FD ))
        piBar = 1. - g / Cp / thetaBar * z
        xc = 0.
        zc = 3000.
        xr = 4000.
        zr = 2000.
        rTilde = np.sqrt( ((x-xc)/xr)**2 + ((z-zc)/zr)**2 )
        Tprime0 = np.zeros( np.shape(thetaBar) )
        ind = rTilde <= 1
        Tprime0[ind] = -15./2. * ( 1. + np.cos(np.pi*rTilde[ind]) )
        thetaPrime0 = Tprime0 / piBar
        piPrime0 = 0.
        U[0,:,:] = 20. * np.ones( np.shape(thetaBar) )
    else :
        sys.exit("\nError: Invalid test case string.\n")
    
    U[1,:,:] = np.zeros( np.shape(thetaBar) )
    U[2,:,:] = thetaBar + thetaPrime0
    
    if formulation == "exner" :
        U[3,:,:] = piBar + piPrime0
    elif formulation == "hydrostaticPressure" :
        U[3,:,:] = -g / Rd / U[2,:,:] / dsdz(x,z) * Po * (piBar+piPrime0)**(Cv/Rd)
        dpidsBar = -g / Rd / thetaBar / dsdz(x,z) * Po * piBar**(Cv/Rd)
        sys.exit( "\nError: This formulation isn't really working yet.  Use exner.\n" )
    else :
        sys.exit( "\nError: Invalid formulation string.\n" )
    
    return U, thetaBar, piBar

###########################################################################

def getIndexes( X, Z, xLeft, xRight, zSurf, zTop, FD, nLev, nCol ) :
    
    x = X.flatten()
    z = Z.flatten()
    
    pts = np.transpose( np.vstack((x,z)) )
    tree = spatial.cKDTree( pts )
    
    class ind :
        pass
    
    ind.m = (x>xLeft) & (x<xRight) & (z>zSurf(x)) & (z<zTop)
    
    ind.gl = (x<xLeft)
    ind.r  = tree.query( np.transpose( np.vstack(( x[ind.gl]+(xRight-xLeft), z[ind.gl] )) ), 1 )
    ind.r  = ind.r[1]
    
    ind.gr = (x>xRight)
    ind.l  = tree.query( np.transpose( np.vstack(( x[ind.gr]-(xRight-xLeft), z[ind.gr] )) ), 1 )
    ind.l  = ind.l[1]
    
    FDo2 = np.int(FD/2)
    
    ind.gb = tree.query( np.transpose( np.vstack(( X[0,FDo2:nCol+FDo2], Z[0,FDo2:nCol+FDo2] )) ), 1 )
    ind.gb = ind.gb[1]
    
    ind.b = tree.query( np.transpose( np.vstack(( X[1,FDo2:nCol+FDo2], Z[1,FDo2:nCol+FDo2] )) ), 1 )
    ind.b = ind.b[1]
    
    ind.gt = tree.query( np.transpose( np.vstack(( X[nLev+1,FDo2:nCol+FDo2], Z[nLev+1,FDo2:nCol+FDo2] )) ), 1 )
    ind.gt = ind.gt[1]
    
    ind.t = tree.query( np.transpose( np.vstack(( X[nLev,FDo2:nCol+FDo2], Z[nLev,FDo2:nCol+FDo2] )) ), 1 )
    ind.t = ind.t[1]
    
    return ind

###########################################################################

def plotNodes( x, z, ind, testCase ) :
    
    x = x.flatten()
    z = z.flatten()

    ms = 12

    plt.plot( x, z, ".", color="black" )
    plt.plot( x[ind.m],  z[ind.m],  "o", color="black",  fillstyle="none", markersize=10 )
    plt.plot( x[ind.gl], z[ind.gl], "o", color="red",    fillstyle="none", markersize=ms )
    plt.plot( x[ind.r],  z[ind.r],  "s", color="red",    fillstyle="none", markersize=ms )
    plt.plot( x[ind.gr], z[ind.gr], "o", color="blue",   fillstyle="none", markersize=ms )
    plt.plot( x[ind.l],  z[ind.l],  "s", color="blue",   fillstyle="none", markersize=ms )
    plt.plot( x[ind.gb], z[ind.gb], "^", color="orange", fillstyle="none", markersize=ms )
    plt.plot( x[ind.b],  z[ind.b],  "v", color="orange", fillstyle="none", markersize=ms )
    plt.plot( x[ind.gt], z[ind.gt], "v", color="green",  fillstyle="none", markersize=ms )
    plt.plot( x[ind.t],  z[ind.t],  "^", color="green",  fillstyle="none", markersize=ms )
    if testCase != "igw" :
        plt.axis( 'equal' )
    plt.show()

###########################################################################

#Apply a differential operator (first derivative or HV) laterally:

def LxFD( U, w, jj, dx, FD, FDo2 ) :
    V = 0
    if len(np.shape(U)) == 3 :
        for i in range(FD+1) :
            V = V + w[i] * U[:,:,jj-FDo2+i]
    elif len(np.shape(U)) == 2 :
        for i in range(FD+1) :
            V = V + w[i] * U[:,jj-FDo2+i]
    else :
        sys.exit( "\nError: Input U should be a 2D or 3D array.\n" )
    return V / dx

###########################################################################

#Apply a differential operator (first derivative or HV) vertically:

def LsFD( U, w, ii, ds ) :
    if len(np.shape(U)) == 3 :
        V = w[0]*U[:,ii-1,:] + w[1]*U[:,ii,:] + w[2]*U[:,ii+1,:,]
    elif len(np.shape(U)) == 2 :
        V = w[0]*U[ii-1,:]   + w[1]*U[ii,:]   + w[2]*U[ii+1,:,]
    else :
        sys.exit( "\nError: Input U should be a 2D or 3D array.\n" )
    return V / ds

###########################################################################

def setGhostNodesFD( U \
, Tx, Tz, Nx, Nz, bigTx, bigTz \
, nLev, nCol, thetaBar, g, Cp \
, normGradS, ds, dsdxBottom, dsdzBottom \
, wx, jj, dx, FD, FDo2 ) :
    
    #extrapolate uT to bottom ghost nodes:
    uT = U[0,1:3,:][:,jj] * bigTx + U[1,1:3,:][:,jj] * bigTz
    uT = 2*uT[0,:] - uT[1,:]
    
    #get uN on bottom ghost nodes:
    uN = U[0,1,jj]*Nx + U[1,1,jj]*Nz
    uN = -uN
    
    #use uT and uN to get (u,w) on bottom ghost nodes, then get (u,w) on top ghost nodes:
    U[0,0,jj] = uT*Tx + uN*Nx
    U[1,0,jj] = uT*Tz + uN*Nz
    U[0,nLev+1,jj] = 2*U[0,nLev,jj] - U[0,nLev-1,jj]
    U[1,nLev+1,jj] = -U[1,nLev,jj]
    
    #extrapolate theta to bottom and top ghost nodes WITHOUT using thetaBar:
    U[2,0,jj] = 2*U[2,1,jj] - U[2,2,jj]
    U[2,nLev+1,jj] = 2*U[2,nLev,jj] - U[2,nLev-1,jj]
    
    # #extrapolate theta to bottom and top ghost nodes using thetaBar:
    # U[2,0,jj] = thetaBar[0,jj] + 2*(U[2,1,jj]-thetaBar[1,jj]) \
    # - (U[2,2,jj]-thetaBar[2,jj])
    # U[2,nLev+1,jj] = thetaBar[nLev+1,jj] + 2*(U[2,nLev,jj]-thetaBar[nLev,jj]) \
    # - (U[2,nLev-1,jj]-thetaBar[nLev-1,jj])
    
    #get pi on bottom ghost nodes using derived BC:
    dpidx = LxFD( U[3,1:3,:], wx, jj, dx, FD, FDo2 )
    dpidx = 3./2.*dpidx[0,:] - 1./2.*dpidx[1,:]
    th = ( U[2,0,jj] + U[2,1,jj] ) / 2.
    U[3,0,jj] = U[3,1,jj] + ds/normGradS**2 * ( g/Cp/th*dsdzBottom + dpidx*dsdxBottom )
    
    #get pi on top ghost nodes:
    th = ( U[2,nLev,jj] + U[2,nLev+1,jj] ) / 2.
    U[3,nLev+1,jj] = U[3,nLev,jj] - ds/dsdzBottom*g/Cp/th
    
    #enforce periodic lateral boundary condition:
    U[:,:,0:FDo2] = U[:,:,nCol:nCol+FDo2]
    U[:,:,nCol+FDo2:nCol+FD] = U[:,:,FDo2:FD]
    
    return U

###########################################################################

def odefunFD( t, U \
, setGhostNodes, Dx, Ds, HVx, HVs \
, dx, ds, wx, ws, wxhv, wshv \
, ii, jj, i0, i1, j0, j1 \
, dsdx, dsdz, FD, FDo2 \
, Cp, Cv, Rd, g, gamma ) :
    
    #Initialize output array:
    V = np.zeros( np.shape(U) )
    
    #Set ghost node values for all variables:
    U = setGhostNodes( U )
    
    #Us and Ux:
    Us = Ds( U[:,:,jj] )
    Ux = Dx( U[:,ii,:] )
    
    #Get u and sDot:
    u = np.tile( U[0,ii,:][:,jj], (4,1,1) )
    sDot = U[0,ii,:][:,jj] * dsdx + U[1,ii,:][:,jj] * dsdz
    sDot = np.tile( sDot, (4,1,1) )
    
    #RHS of ODE function:
    V[ :, i0:i1, j0:j1 ] = - u * Ux - sDot * Us
    V[ 0, i0:i1, j0:j1 ] = V[0,ii,:][:,jj] - Cp*U[2,ii,:][:,jj] * ( Ux[3,:,:] + Us[3,:,:]*dsdx )
    V[ 1, i0:i1, j0:j1 ] = V[1,ii,:][:,jj] - Cp*U[2,ii,:][:,jj] * ( Us[3,:,:]*dsdz ) - g
    V[ 3, i0:i1, j0:j1 ] = V[3,ii,:][:,jj] - Rd/Cv*U[3,ii,:][:,jj] * ( Ux[0,:,:]+Us[0,:,:]*dsdx + Us[1,:,:]*dsdz )
    
    #Add dissipation:
    V[ :, i0:i1, j0:j1 ] = V[:,ii,:][:,:,jj] \
    + gamma * np.abs(u) * HVx( U[:,ii,:] ) \
    + (1./2.) * np.abs(sDot) * HVs( U[:,:,jj] )
    
    return V

###########################################################################

def conventionalSemiLagrangianTimestep( U0, U1, alp, bet \
, setGhostNodes, Dx, Ds \
, nLev, nCol, FD, FDo2, ds \
, Cp, Rd, Cv, g, dt \
, x2, z2, dsdx, dsdz \
, ind_m, i0, i1, j0, j1 \
, rbfOrder, polyOrder, stencilSize ) :
    
    U1star = 3./2.*U1 - 1./2.*U0
    
    dpidx = np.zeros(( nLev+2, nCol+FD ))
    dpidx[ :, j0:j1 ] = Dx( U1star[ 3, :, : ] )
    dpidx[ :,         0:FDo2    ] = dpidx[ :, nCol:nCol+FDo2 ]
    dpidx[ :, nCol+FDo2:nCol+FD ] = dpidx[ :, FDo2:FD        ]
    dpidx = dpidx.flatten()
    
    dpids = np.zeros(( nLev+2, nCol+FD ))
    dpids[ i0:i1, : ] = Ds( U1star[ 3, :, : ] )
    dpids[0,:]      = ( U1star[3,1,:]      - U1star[3,0,:] )    / ds
    dpids[nLev+1,:] = ( U1star[3,nLev+1,:] - U1star[3,nLev,:] ) / ds
    dpids = dpids.flatten()
    
    dudx = np.zeros(( nLev+2, nCol+FD ))
    dudx[ :, j0:j1 ] = Dx( U1star[ 0, :, : ] )
    dudx[ :,         0:FDo2    ] = dudx[ :, nCol:nCol+FDo2 ]
    dudx[ :, nCol+FDo2:nCol+FD ] = dudx[ :, FDo2:FD        ]
    dudx = dudx.flatten()
    
    duds = np.zeros(( nLev+2, nCol+FD ))
    duds[ i0:i1, : ] = Ds( U1star[ 0, :, : ] )
    duds[0,:]      = ( U1star[0,1,:]      - U1star[0,0,:] )    / ds
    duds[nLev+1,:] = ( U1star[0,nLev+1,:] - U1star[0,nLev,:] ) / ds
    duds = duds.flatten()
    
    dwds = np.zeros(( nLev+2, nCol+FD ))
    dwds[ i0:i1, : ] = Ds( U1star[ 1, :, : ] )
    dwds[0,:]      = ( U1star[1,1,:]      - U1star[1,0,:] )    / ds
    dwds[nLev+1,:] = ( U1star[1,nLev+1,:] - U1star[1,nLev,:] ) / ds
    dwds = dwds.flatten()
    
    u1star  = U1star[0,:,:] . flatten()
    w1star  = U1star[1,:,:] . flatten()
    pi1star = U1star[3,:,:] . flatten()
    
    for i in range(3) :
        stencils = phs2.getStencils( x2, z2, x2-alp/2., z2-bet/2., stencilSize )
        A = phs2.getAmatrices( stencils, rbfOrder, polyOrder )
        W = phs2.getWeights( stencils, A, "i", 0 )
        alp = dt * np.sum( W*u1star[stencils.idx], axis=1 )
        bet = dt * np.sum( W*w1star[stencils.idx], axis=1 )
    
    x1 = x2[ind_m] - alp[ind_m]
    z1 = z2[ind_m] - alp[ind_m]
    
    u1  = U1[0,:,:] . flatten()
    w1  = U1[1,:,:] . flatten()
    th1 = U1[2,:,:] . flatten()
    pi1 = U1[3,:,:] . flatten()
    
    stencils = phs2.getStencils( x2, z2, x1, z1, stencilSize )
    A = phs2.getAmatrices( stencils, rbfOrder, polyOrder )
    W = phs2.getWeights( stencils, A, "i", 0 )
    u1  = np.sum( W*u1[stencils.idx],  axis=1 )
    w1  = np.sum( W*w1[stencils.idx],  axis=1 )
    th1 = np.sum( W*th1[stencils.idx], axis=1 )
    pi1 = np.sum( W*pi1[stencils.idx], axis=1 )
    
    x1star = x2[ind_m] - alp[ind_m]/2.
    z1star = z2[ind_m] - bet[ind_m]/2.
    
    stencils = phs2.getStencils( x2, z2, x1star, z1star, stencilSize )
    A = phs2.getAmatrices( stencils, rbfOrder, polyOrder )
    W = phs2.getWeights( stencils, A, "i", 0 )
    th1star = th1
    pi1star = np.sum( W*pi1star[stencils.idx], axis=1 )
    dpidx   = np.sum( W*dpidx[stencils.idx],   axis=1 )
    dpids   = np.sum( W*dpids[stencils.idx],   axis=1 )
    dudx    = np.sum( W*dudx[stencils.idx],    axis=1 )
    duds    = np.sum( W*duds[stencils.idx],    axis=1 )
    dwds    = np.sum( W*dwds[stencils.idx],    axis=1 )
    
    u2 = u1 - dt * Cp * th1star * ( dpidx + dpids*dsdx )
    w2 = w1 - dt * ( Cp * th1star * dpids*dsdz + g )
    th2 = th1
    pi2 = pi1 - dt * Rd/Cv * pi1star * ( dudx+duds*dsdx + dwds*dsdz )
    
    U2 = np.zeros(( 4, (nLev+2)*(nCol+FD) ))
    U2[0,ind_m] = u2
    U2[1,ind_m] = w2
    U2[2,ind_m] = th2
    U2[3,ind_m] = pi2
    
    U2 = np.reshape( U2, (4,nLev+2,nCol+FD) )
    
    U2 = setGhostNodes( U2 )
    
    return U2, alp, bet

###########################################################################

#One leap-frog semi-Lagrangian step:

def mySemiLagrangianTimestep( Un1, U \
, setGhostNodes, Dx, Ds \
, x0, z0, ind_m, dt \
, nLev, nCol, FD, i0, i1, j0, j1 \
, Cp, Rd, Cv, g, dsdx, dsdz \
, rbfOrder, polyOrder, stencilSize ) :
    
    #Get all spatial derivatives that will be needed:
    
    dpidx = np.zeros(( nLev+2, nCol+FD ))
    dpidx[ i0:i1, j0:j1 ] = Dx( U[ 3, i0:i1, : ] )
    dpidx = dpidx.flatten()
    dpidx = dpidx[ind_m]
    
    dpids = np.zeros(( nLev+2, nCol+FD ))
    dpids[ i0:i1, j0:j1 ] = Ds( U[ 3, :, j0:j1 ] )
    dpids = dpids.flatten()
    dpids = dpids[ind_m]
    
    dudx = np.zeros(( nLev+2, nCol+FD ))
    dudx[ i0:i1, j0:j1 ] = Dx( U[ 0, i0:i1, : ] )
    dudx = dudx.flatten()
    dudx = dudx[ind_m]
    
    duds = np.zeros(( nLev+2, nCol+FD ))
    duds[ i0:i1, j0:j1 ] = Ds( U[ 0, :, j0:j1 ] )
    duds = duds.flatten()
    duds = duds[ind_m]
    
    dwds = np.zeros(( nLev+2, nCol+FD ))
    dwds[ i0:i1, j0:j1 ] = Ds( U[ 1, :, j0:j1 ] )
    dwds = dwds.flatten()
    dwds = dwds[ind_m]
    
    #Re-shape into vectors:
    
    un1  = Un1[0,:,:] . flatten()
    wn1  = Un1[1,:,:] . flatten()
    thn1 = Un1[2,:,:] . flatten()
    pin1 = Un1[3,:,:] . flatten()
    
    u0  = U[0,:,:] . flatten()
    w0  = U[1,:,:] . flatten()
    th0 = U[2,:,:] . flatten()
    pi0 = U[3,:,:] . flatten()
    
    #2(a)  Set (xStar,zStar) = (x0,z0) - dt/2 * (u0,w0) :
    xStar = x0[ind_m] - dt/2. * u0[ind_m]
    zStar = z0[ind_m] - dt/2. * w0[ind_m]
    
    #2(b)  Set (uStar,wStar) = ( (un1,wn1) + (u0,w0) ) / 2 :
    uStar = ( un1 + u0 ) / 2.
    wStar = ( wn1 + w0 ) / 2.
    
    #2(c)  Interpolate (uStar,wStar) from (x0,z0) to (xStar,zStar) :
    stencils = phs2.getStencils( x0, z0, xStar, zStar, stencilSize )
    A = phs2.getAmatrices( stencils, rbfOrder, polyOrder )
    W = phs2.getWeights( stencils, A, "i", 0 )
    uStar = np.sum( W*uStar[stencils.idx], axis=1 )
    wStar = np.sum( W*wStar[stencils.idx], axis=1 )
    
    #2(d)  Set (xn1,zn1) = (x0,z0) - dt * (uStar,wStar) :
    xn1 = x0[ind_m] - dt * uStar
    zn1 = z0[ind_m] - dt * wStar
    
    #3  Interpolate (un1,wn1,thn1,pin1) from (x0,z0) to (xn1,zn1) :
    stencils = phs2.getStencils( x0, z0, xn1, zn1, stencilSize )
    A = phs2.getAmatrices( stencils, rbfOrder, polyOrder )
    W = phs2.getWeights( stencils, A, "i", 0 )
    un1  = np.sum( W*un1[stencils.idx],  axis=1 )
    wn1  = np.sum( W*wn1[stencils.idx],  axis=1 )
    thn1 = np.sum( W*thn1[stencils.idx], axis=1 )
    pin1 = np.sum( W*pin1[stencils.idx], axis=1 )
    
    #4  Use S-L step to get (x1,z1) and (u1,w1,th1,pi1) :
    x1 = xn1 + 2.*dt * u0[ind_m]
    z1 = zn1 + 2.*dt * w0[ind_m]
    u1 = un1 - 2.*dt * Cp * th0[ind_m] * ( dpidx + dpids*dsdx )
    w1 = wn1 - 2.*dt * ( Cp * th0[ind_m] * dpids*dsdz + g )
    th1 = thn1
    pi1 = pin1 - 2.*dt * Rd/Cv*pi0[ind_m] * ( dudx+duds*dsdx + dwds*dsdz )
    
    #5  Interpolate (u1,w1,th1,pi1) from (x1,z1) to (x0,z0) :
    stencils = phs2.getStencils( x1, z1, x0[ind_m], z0[ind_m], stencilSize )
    A = phs2.getAmatrices( stencils, rbfOrder, polyOrder )
    W = phs2.getWeights( stencils, A, "i", 0 )
    u1  = np.sum( W*u1[stencils.idx],  axis=1 )
    w1  = np.sum( W*w1[stencils.idx],  axis=1 )
    th1 = np.sum( W*th1[stencils.idx], axis=1 )
    pi1 = np.sum( W*pi1[stencils.idx], axis=1 )
    
    U = np.zeros(( 4, (nLev+2)*(nCol+FD) ))
    U[0,ind_m] = u1
    U[1,ind_m] = w1
    U[2,ind_m] = th1
    U[3,ind_m] = pi1
    
    U = np.reshape( U, (4,nLev+2,nCol+FD) )
    
    U = setGhostNodes( U )
    
    return U

###########################################################################

def setFigAndContourLevels( testCase ) :
    
    if testCase == "densityCurrent" :
        fig = plt.figure( figsize = (28,3) )
        CL = np.arange( -16.5, 1.5, 1. )
    elif testCase == "doubleDensityCurrent" :
        fig = plt.figure( figsize = (30,12) )
        CL = np.arange( -16.5, 1.5, 1. )
    elif testCase == "movingDensityCurrent" :
        fig = plt.figure( figsize = (30,5) )
        CL = np.arange( -16.5, 1.5, 1. )
    elif testCase == "bubble" :
        fig = plt.figure( figsize = (18,14) )
        CL = np.arange( -.05, 2.15, .1 )
    elif testCase == "igw" :
        fig = plt.figure( figsize = (40,4) )
        CL = np.arange( -.0021, .0035, .0002 )
    else :
        sys.exit( "\nError: Invalid test case string.\n" )
    
    return fig, CL

###########################################################################

def saveContourPlot( U, t \
, testCase, var, fig \
, x, z, thetaBar, piBar, CL, FDo2 \
, xLeft, xRight, zTop, dx, ds ):
    
    if var == 0 :
        plt.contourf( x, z, U[0,:,:], 20 )
    elif var == 1 :
        plt.contourf( x, z, U[1,:,:], 20 )
    elif var == 2 :
        plt.contourf( x, z, U[2,:,:]-thetaBar, CL )
    elif var == 3 :
        plt.contourf( x, z, U[3,:,:]-piBar, 20 )
    else :
        sys.exit( "\nError: var should be 0, 1, 2, or 3 (u,w,th,pi)\n" )
    
    if testCase != "igw" :
        plt.axis( 'equal' )
    plt.axis( [ xLeft-FDo2*dx, xRight+FDo2*dx, -ds, zTop+ds ] )
    plt.colorbar()
    # plt.title( 'testCase = {0}, t = {1:04d}'.format(testCase,np.int(np.round(t)+1e-12)) )
    fig.savefig( '{0:04d}'.format(np.int(np.round(t)+1e-12))+'.png', bbox_inches = 'tight' )
    plt.clf()

###########################################################################

def printInfo( U, et , t \
, thetaBar, piBar ) :
    
    print()
    print( "t =", np.int(np.round(t)+1e-10) )
    print( "et =", time.clock()-et )
    et = time.clock()
    print( "minmaxU =",  [ np.min(U[0,:,:]),          np.max(U[0,:,:])          ] )
    print( "minmaxW =",  [ np.min(U[1,:,:]),          np.max(U[1,:,:])          ] )
    print( "minmaxTh =", [ np.min(U[2,:,:]-thetaBar), np.max(U[2,:,:]-thetaBar) ] )
    print( "minmaxPi =", [ np.min(U[3,:,:]-piBar),    np.max(U[3,:,:]-piBar)    ] )
    
    return et

###########################################################################