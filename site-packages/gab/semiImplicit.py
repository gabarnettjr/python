import sys
import numpy as np
import matplotlib.pyplot as plt
from scipy import spatial, sparse
from scipy.sparse import linalg
import time

###########################################################################

def getConstants() :
    
    Cp = 1004.
    Cv = 717.
    Rd = Cp - Cv
    g  = 9.81
    
    return Cp, Cv, Rd, g

###########################################################################

def getTfinal( testCase ) :

    if testCase == "bubble" :
        tf = 1500.
    elif testCase == "igw" :
        tf = 3000.
    elif testCase == "densityCurrent" :
        tf = 900.
    elif testCase == "doubleDensityCurrent" :
        tf = 900.
    elif testCase == "movingDensityCurrent" :
        tf = 900.
    else :
        sys.exit( "\nError: Invalid testCase string.\n" )
    
    return tf

###########################################################################

def getSpaceDomain( testCase, dx, dz ) :
    
    if testCase == "bubble" :
        xLeft  = 0.
        xRight = 10000.
        zTop   = 10000.
    elif testCase == "igw" :
        xLeft  = 0.
        xRight = 300000.
        zTop   = 10000.
    elif testCase == "densityCurrent" :
        xLeft  = -25600.
        xRight = 25600.
        zTop   = 6400.
    elif testCase == "doubleDensityCurrent" :
        xLeft  = -6400.
        xRight = 6400.
        zTop   = 6400.
    elif testCase == "movingDensityCurrent" :
        xLeft  = -18000.
        xRight = 18000.
        zTop   = 6400.
    else :
        sys.exit( "\nError: Invalid test case string.\n" )
    
    nLev = np.int( np.round(zTop/dz) + 1e-12 )
    nCol = np.int( np.round((xRight-xLeft)/dx) + 1e-12 )
    N = nLev * nCol
    
    x = np.linspace( xLeft+dx/2., xRight-dx/2., nCol )
    z = np.linspace( 0+dz/2., zTop-dz/2., nLev )
    
    [ xx, zz ] = np.meshgrid( x, z )
    
    x = np.transpose(xx) . flatten()
    z = np.transpose(zz) . flatten()
    
    return xLeft, xRight, zTop, nLev, nCol, N, xx, zz, x, z

###########################################################################

def getInitialConditions( testCase, nLev, nCol, x, z , Cp, Cv, Rd, g ) :
    
    N = nLev*nCol
    
    U = np.zeros(( 4*N ))
    
    if testCase == "bubble" :
        thetaBar = 300. * np.ones(np.shape(x))
        piBar = 1. - g / Cp / thetaBar * z
        R = 1500.
        xc = 5000.
        zc = 3000.
        r = np.sqrt( (x-xc)**2 + (z-zc)**2 )
        ind = r < R
        thetaPrime0 = np.zeros(np.shape(x))
        thetaPrime0[ind] = 2. * ( 1. - r[ind]/R )
        piPrime0 = np.zeros(np.shape(x))
        U[0:N] = np.zeros(np.shape(x))
        dthetabarDz = np.zeros(np.shape(x))
    elif testCase == "igw" :
        BVF = .01
        theta0 = 300.
        thetaBar = theta0 * np.exp( (BVF**2/g) * z )
        piBar = 1. + g**2. / Cp / theta0 / BVF**2. * ( np.exp(-BVF**2./g*z) - 1. )
        thetaC = .01
        hC = 10000.
        aC = 5000.
        xC = 100000.
        thetaPrime0 = thetaC * np.sin( np.pi*z/hC ) / ( 1. + ((x-xC)/aC)**2 )
        piPrime0 = np.zeros(np.shape(x))
        U[0:N] = 20. * np.ones(np.shape(x))
        dthetabarDz = theta0 * (BVF**2/g) * np.exp( (BVF**2/g) * z )
    elif testCase == "densityCurrent" :
        thetaBar = 300. * np.ones(np.shape(x))
        piBar = 1. - g / Cp / thetaBar * z
        xc = 0.
        zc = 3000.
        xr = 4000.
        zr = 2000.
        rTilde = np.sqrt( ((x-xc)/xr)**2 + ((z-zc)/zr)**2 )
        Tprime0 = np.zeros(np.shape(x))
        ind = rTilde <= 1.
        Tprime0[ind] = -15./2. * ( 1. + np.cos(np.pi*rTilde[ind]) )
        thetaPrime0 = Tprime0 / piBar
        piPrime0 = np.zeros(np.shape(x))
        U[0:N] = np.zeros(np.shape(x))
        dthetabarDz = np.zeros(np.shape(x))
    elif testCase == "doubleDensityCurrent" :
        thetaBar = 300. * np.ones(np.shape(x))
        piBar = 1. - g / Cp / thetaBar * z
        xc1 = -6400.
        xc2 = 6400.
        zc = 3000.
        xr = 4000.
        zr = 2000.
        rTilde1 = np.sqrt( ((x-xc1)/xr)**2 + ((z-zc)/zr)**2 )
        rTilde2 = np.sqrt( ((x-xc2)/xr)**2 + ((z-zc)/zr)**2 )
        Tprime0 = np.zeros(np.shape(x))
        ind1 = rTilde1 <= 1.
        ind2 = rTilde2 <= 1.
        Tprime0[ind1] = -15./2. * ( 1. + np.cos(np.pi*rTilde1[ind1]) )
        Tprime0[ind2] = -15./2. * ( 1. + np.cos(np.pi*rTilde2[ind2]) )
        thetaPrime0 = Tprime0 / piBar
        piPrime0 = np.zeros(np.shape(x))
        U[0:N] = np.zeros(np.shape(x))
        dthetabarDz = np.zeros(np.shape(x))
    elif testCase == "movingDensityCurrent" :
        thetaBar = 300. * np.ones(np.shape(x))
        piBar = 1. - g / Cp / thetaBar * z
        xc = 0.
        zc = 3000.
        xr = 4000.
        zr = 2000.
        rTilde = np.sqrt( ((x-xc)/xr)**2 + ((z-zc)/zr)**2 )
        Tprime0 = np.zeros(np.shape(x))
        ind = rTilde <= 1.
        Tprime0[ind] = -15./2. * ( 1. + np.cos(np.pi*rTilde[ind]) )
        thetaPrime0 = Tprime0 / piBar
        piPrime0 = np.zeros(np.shape(x))
        U[0:N] = 20. * np.ones(np.shape(x))
        dthetabarDz = np.zeros(np.shape(x))
    else :
        sys.exit("\nError: Invalid test case string.\n")
    
    dpibarDz = -g/Cp/thetaBar
    
    U[N:2*N]   = np.zeros(np.shape(x))
    U[2*N:3*N] = thetaPrime0
    U[3*N:4*N] = piPrime0
    
    return U, thetaBar, piBar, dthetabarDz, dpibarDz

###########################################################################

#Get sparse matrices for semi-implicit approximation of spatial operators:

def getDerivativeOperators( nCol, nLev, FD, dx, dz, gx, gz ) :
    
    if FD == 2 :
        wx  = np.array( [ -1./2., 0., 1./2. ] )
        hvx = np.array( [ 1., -2., 1. ] )
    elif FD == 4 :
        wx  = np.array( [ 1./12., -2./3., 0., 2./3., -1./12. ] )
        hvx = np.array( [ 1., -4., 6., -4., 1 ] )
    else :
        sys.exit( "\nError: FD should be 2 or 4 for this.\n" )
    wx  = wx  / dx
    hvx = gx * hvx / dx
    
    if FD == 2 :
        #first derivative:
        Lx = np.zeros(( 2, nCol ))
        Lx[0,:] = wx[0] * np.ones(( nCol ))
        Lx[1,:] = wx[2] * np.ones(( nCol ))
        Lx = sparse.spdiags( Lx, [-1,1], nCol, nCol )
        Lx = sparse.lil_matrix( Lx )
        Lx[0,nCol-1] = wx[0]
        Lx[nCol-1,0] = wx[2]
        #second derivative:
        HVx = np.zeros( (3,nCol), float )
        HVx[0,:] = hvx[0] * np.ones(( nCol ))
        HVx[1,:] = hvx[1] * np.ones(( nCol ))
        HVx[2,:] = hvx[2] * np.ones(( nCol ))
        HVx = sparse.spdiags( HVx, [-1,0,1], nCol, nCol )
        HVx = sparse.lil_matrix( HVx )
        HVx[0,nCol-1] = wx[0]
        HVx[nCol-1,0] = wx[2]
        #full matrices:
        Lx  = sparse.kron( Lx,  sparse.eye(nLev) )
        HVx = sparse.kron( HVx, sparse.eye(nLev) )
    elif FD == 4 :
        #first derivative:
        Lx = np.zeros(( 4, nCol ))
        Lx[0,:] = wx[0] * np.ones(( nCol ))
        Lx[1,:] = wx[1] * np.ones(( nCol ))
        Lx[2,:] = wx[3] * np.ones(( nCol ))
        Lx[3,:] = wx[4] * np.ones(( nCol ))
        Lx = sparse.spdiags( Lx, [-2,-1,1,2], nCol, nCol )
        Lx = sparse.lil_matrix( Lx )
        Lx[0,nCol-2] = wx[0]
        Lx[0,nCol-1] = wx[1]
        Lx[1,nCol-1] = wx[0]
        Lx[nCol-2,0] = wx[4]
        Lx[nCol-1,0] = wx[3]
        Lx[nCol-1,1] = wx[4]
        #fourth derivative:
        HVx = np.zeros(( 5, nCol ))
        HVx[0,:] = hvx[0] * np.ones(( nCol ))
        HVx[1,:] = hvx[1] * np.ones(( nCol ))
        HVx[2,:] = hvx[2] * np.ones(( nCol ))
        HVx[3,:] = hvx[3] * np.ones(( nCol ))
        HVx[4,:] = hvx[4] * np.ones(( nCol ))
        HVx = sparse.spdiags( HVx, [-2,-1,0,1,2], nCol, nCol )
        HVx = sparse.lil_matrix( HVx )
        HVx[0,nCol-2] = hvx[0]
        HVx[0,nCol-1] = hvx[1]
        HVx[1,nCol-1] = hvx[0]
        HVx[nCol-2,0] = hvx[4]
        HVx[nCol-1,0] = hvx[3]
        HVx[nCol-1,1] = hvx[4]
        #full matrices:
        Lx  = sparse.kron( Lx,  sparse.eye(nLev) )
        HVx = sparse.kron( HVx, sparse.eye(nLev) )
    else :
        sys.exit( '\nError: FD should be 2 or 4.\n' )
    
    #first derivative:
    v1 = np.zeros(( 2,nLev ))
    v1[0,:] = -np.ones(( nLev ))
    v1[1,:] =  np.ones(( nLev ))
    #second derivative:
    v2 = np.zeros( (3,nLev), float )
    v2[0,:] =  1.*np.ones(( nLev ))
    v2[1,:] = -2.*np.ones(( nLev ))
    v2[2,:] =  1.*np.ones(( nLev ))
    
    #Lz:
    
    class Lz :
        pass
    Lz.u  = sparse.lil_matrix( sparse.spdiags( v1, [-1,1], nLev, nLev ) )
    Lz.w  = sparse.lil_matrix( sparse.spdiags( v1, [-1,1], nLev, nLev ) )
    Lz.th = sparse.lil_matrix( sparse.spdiags( v1, [-1,1], nLev, nLev ) )
    Lz.pi = sparse.lil_matrix( sparse.spdiags( v1, [-1,1], nLev, nLev ) )
    #(u2-u0)/(2h) = (u2-(2u1-u2))/(2h) = (-2u1+2u2)/(2h):
    Lz.u [ 0,      0      ] = -2.
    Lz.u [ 0,      1      ] =  2.
    #(u2-u0)/(2h) = ((2u1-u0)-u0)/(2h) = (-2u0+2u1)/(2h):
    Lz.u [ nLev-1, nLev-2 ] = -2.
    Lz.u [ nLev-1, nLev-1 ] =  2.
    #(w2-w0)/(2h) = (w2-(-w1))/(2h) = (w1+w2)/(2h):
    Lz.w [ 0,      0      ] =  1.
    Lz.w [ 0,      1      ] =  1.
    #(w2-w0)/(2h) = (-w1-w0)/(2h) = (-w0-w1)/(2h):
    Lz.w [ nLev-1, nLev-2 ] = -1.
    Lz.w [ nLev-1, nLev-1 ] = -1.
    #(th2-th0)/(2h) = (th2-(2th1-th2))/(2h) = (-2th1+2th2)/(2h):
    Lz.th[ 0,      0      ] = -2.
    Lz.th[ 0,      1      ] =  2.
    #(th2-th0)/(2h) = ((th1-th0)-th0)/(2h) = (-2th0+2th1)/(2h):
    Lz.th[ nLev-1, nLev-2 ] = -2.
    Lz.th[ nLev-1, nLev-1 ] =  2.
    #(p1-p0)/h=(a/2)(3t1-t2) => p0=p1-(ah/2)(3t1-t2)
    #(p2-p0)/(2h) = (p2-p1)/(2h)+(a/4)(3t1-t2):
    Lz.pi[ 0,      0      ] = -1.
    Lz.pi[ 0,      1      ] =  1.
    #(p2-p1)/h=(b/2)(3t1-t0) => p2=p1+(bh/2)(3t1-t0)
    #(p2-p0)/(2h) = (p1-p0)/(2h)+(b/4)(3t1-t0)
    Lz.pi[ nLev-1, nLev-2 ] = -1.
    Lz.pi[ nLev-1, nLev-1 ] =  1.
    Lz.u  = Lz.u  / (2.*dz)
    Lz.w  = Lz.w  / (2.*dz)
    Lz.th = Lz.th / (2.*dz)
    Lz.pi = Lz.pi / (2.*dz)
    Lz.u  = sparse.kron( sparse.eye(nCol), Lz.u  )
    Lz.w  = sparse.kron( sparse.eye(nCol), Lz.w  )
    Lz.th = sparse.kron( sparse.eye(nCol), Lz.th )
    Lz.pi = sparse.kron( sparse.eye(nCol), Lz.pi )
    
    #HVz:
    
    class HVz :
        pass
    HVz.u  = sparse.lil_matrix( sparse.spdiags( v2, [-1,0,1], nLev, nLev ) )
    HVz.w  = sparse.lil_matrix( sparse.spdiags( v2, [-1,0,1], nLev, nLev ) )
    HVz.pi = sparse.lil_matrix( sparse.spdiags( v2, [-1,0,1], nLev, nLev ) )
    #(u0-2u1+u2)/h = ((2u1-u2)-2u1+u2)/h = 0:
    HVz.u [ 0,      0      ] =  0.
    HVz.u [ 0,      1      ] =  0.
    #(u0-2u1+u2)/h = (u0-2u1+(2u1-u0))/h = 0:
    HVz.u [ nLev-1, nLev-2 ] =  0.
    HVz.u [ nLev-1, nLev-1 ] =  0.
    #(w0-2w1+w2)/h = ((-w1)-2w1+w2)/h = (-3w1+w2)/h:
    HVz.w [ 0,      0      ] = -3.
    HVz.w [ 0,      1      ] =  1.
    #(w0-2w1+w2)/h = (w0-2w1+(-w1))/h = (w0-3w1)/h:
    HVz.w [ nLev-1, nLev-2 ] =  1.
    HVz.w [ nLev-1, nLev-1 ] = -3.
    #(p1-p0)/h=(a/2)(3t1-t2) => p0=p1-(ah/2)(3t1-t2)
    #(p0-2p1+p2)/h = (-p1+p2)/h -(a/2)(3t1-t2):
    HVz.pi[ 0,      0      ] = -1.
    HVz.pi[ 0,      1      ] =  1.
    #(p2-p1)/h=(b/2)(3t1-t0) => p2=p1+(bh/2)(3t1-t0)
    #(p0-2p1+p2)/h = (p0-p1)/h + (b/2)(3t1-t0):
    HVz.pi[ nLev-1, nLev-2 ] =  1.
    HVz.pi[ nLev-1, nLev-1 ] = -1.
    HVz.u  = gz * HVz.u  / dz
    HVz.w  = gz * HVz.w  / dz
    HVz.pi = gz * HVz.pi / dz
    HVz.u  = sparse.kron( sparse.eye(nCol), HVz.u  )
    HVz.w  = sparse.kron( sparse.eye(nCol), HVz.w  )
    HVz.pi = sparse.kron( sparse.eye(nCol), HVz.pi )
    HVz.th = HVz.u
    
    return Lx, Lz, HVx, HVz

###########################################################################

def getBoundaryConditionMatrices( thetaBar, nLev, nCol, g, Cp ) :
    
    ii = np.zeros( (4*nCol), int )
    k = 1
    for i in range(2*nCol) :
        if np.mod(i,2) == 0 :
            ii[2*i]    = (k-1)*nLev
            ii[2*i+1]  = (k-1)*nLev
        else :
            ii[2*i]    = k*nLev - 1
            ii[2*i+1]  = k*nLev - 1
            k = k + 1
    
    jj = np.zeros( (4*nCol), int )
    jj[0] = 0
    jj[1] = 1
    k = 2
    for i in range(1,nCol) :
        jj[k]   = i*nLev-2
        jj[k+1] = i*nLev-1
        jj[k+2] = i*nLev
        jj[k+3] = i*nLev+1
        k = k + 4
    jj[k]   = nCol*nLev-2
    jj[k+1] = nCol*nLev-1
    
    thetaBar = np.reshape( thetaBar, (nCol,nLev) )
    thetaBar = np.transpose( thetaBar )
    
    thetaBarBotHalf = 3./2.*thetaBar[0,:] - 1./2.*thetaBar[1,:]
    
    thetaBarTopHalf = 3./2.*thetaBar[nLev-1,:] - 1./2.*thetaBar[nLev-2,:]
    
    cBot = g / Cp  / thetaBarBotHalf**2.
    cTop = g / Cp  / thetaBarTopHalf**2.
    
    bc1 = np.zeros( (4*nCol), float )
    bc2 = np.zeros( (4*nCol), float )
    
    k = 0
    for i in range(nCol) :
        #(p1-p0)/h=(a/2)(3t1-t2) => p0=p1-(ah/2)(3t1-t2)
        #(p2-p0)/(2h) = (p2-p1)/(2h)+(a/4)(3t1-t2):
        bc1[k]   =  3./4.*cBot[i]
        bc1[k+1] = -1./4.*cBot[i]
        #(p2-p1)/h=(b/2)(3t1-t0) => p2=p1+(bh/2)(3t1-t0)
        #(p2-p0)/(2h) = (p1-p0)/(2h)+(b/4)(3t1-t0)
        bc1[k+2] = -1./4.*cTop[i]
        bc1[k+3] =  3./4.*cTop[i]
        #(p1-p0)/h=(a/2)(3t1-t2) => p0=p1-(ah/2)(3t1-t2)
        #(p0-2p1+p2)/h = (-p1+p2)/h -(a/2)(3t1-t2):
        bc2[k]   = -3./2.*cBot[i]
        bc2[k+1] =  1./2.*cBot[i]
        #(p2-p1)/h=(b/2)(3t1-t0) => p2=p1+(bh/2)(3t1-t0)
        #(p0-2p1+p2)/h = (p0-p1)/h + (b/2)(3t1-t0):
        bc2[k+2] = -1./2.*cTop[i]
        bc2[k+3] =  3./2.*cTop[i]
        k = k + 4
    
    Bc1 = sparse.coo_matrix( (bc1,(ii,jj)), (nLev*nCol,nLev*nCol) )
    Bc2 = sparse.coo_matrix( (bc2,(ii,jj)), (nLev*nCol,nLev*nCol) )
    
    return Bc1, Bc2

###########################################################################

def odeFun( t, U \
, Lx, Lz, HVx, HVz, Bc1, Bc2 \
, thetaBar, piBar, dthetabarDz, dpibarDz \
, N, gz, Cp, Cv, Rd, g, V ) :
    
    #temporary variables:
    dpidx = Lx.dot( U[3*N:4*N] )
    dpidz = Lz.pi.dot( U[3*N:4*N] ) + Bc1.dot(U[2*N:3*N])
    dudx = Lx.dot( U[0:N] )
    dwdz = Lz.w.dot( U[N:2*N] )
    thetabarPlusTheta = thetaBar + U[2*N:3*N]
    
    #du/dt:
    V[0:N] = -U[0:N] * dudx - U[N:2*N] * Lz.u.dot(U[0:N]) \
    - Cp * thetabarPlusTheta * dpidx \
    + HVx.dot(U[0:N]) \
    + HVz.u.dot(U[0:N])
    
    #dw/dt:
    V[N:2*N] = -U[0:N] * Lx.dot(U[N:2*N]) - U[N:2*N] * dwdz \
    - Cp * thetabarPlusTheta * dpidz \
    + g/thetaBar * U[2*N:3*N] \
    + HVx.dot(U[N:2*N]) \
    + HVz.w.dot(U[N:2*N])
    
    #dth/dt:
    V[2*N:3*N] = -U[0:N] * Lx.dot(U[2*N:3*N]) - U[N:2*N] * Lz.th.dot(U[2*N:3*N]) \
    - U[N:2*N] * dthetabarDz \
    + HVx.dot(U[2*N:3*N]) \
    + HVz.th.dot(U[2*N:3*N])
    
    #dpi/dt:
    V[3*N:4*N] = -U[0:N] * dpidx - U[N:2*N] * dpidz \
    +g/Cp/thetaBar * U[N:2*N] \
    -Rd/Cv * ( piBar + U[3*N:4*N] ) * ( dudx + dwdz ) \
    + HVx.dot(U[3*N:4*N]) \
    + HVz.pi.dot(U[3*N:4*N]) + gz*Bc2.dot(U[2*N:3*N])
    
    return V

###########################################################################

def getBlockMatrix( Lx, Lz, HVx, HVz, Bc1, Bc2, nLev, nCol \
, thetaBar, piBar, dthetabarDz, gz \
, Cp, Cv, Rd, g ) :
    
    gOcpOthetabar = sparse.spdiags( g/Cp/thetaBar, [0], nLev*nCol, nLev*nCol )
    gOthetabar    = sparse.spdiags( g/thetaBar,    [0], nLev*nCol, nLev*nCol )
    thetaBar      = sparse.spdiags( thetaBar,      [0], nLev*nCol, nLev*nCol )
    piBar         = sparse.spdiags( piBar,         [0], nLev*nCol, nLev*nCol )
    dthetabarDz   = sparse.spdiags( dthetabarDz,   [0], nLev*nCol, nLev*nCol )
    
    O = sparse.lil_matrix(( nLev*nCol, nLev*nCol ))
    I = sparse.eye( nLev*nCol )
    
    A1 = sparse.hstack(( -HVx-HVz.u,     O,                              O,                           Cp*thetaBar*Lx    ))
    A2 = sparse.hstack(( O,              -HVx-HVz.w,                     -gOthetabar+Cp*thetaBar*Bc1, Cp*thetaBar*Lz.pi ))
    A3 = sparse.hstack(( O,              dthetabarDz,                    -HVx-HVz.th,                 O                 ))
    A4 = sparse.hstack(( Rd/Cv*piBar*Lx, Rd/Cv*piBar*Lz.w-gOcpOthetabar, -gz*Bc2,                     -HVx-HVz.pi       ))
    
    A = sparse.vstack(( A1, A2, A3, A4 ))
    
    return A

###########################################################################

def leapfrogTimestep( t, U0, U1, dtImp, L, R \
, Lx, Lz, Bc1 \
, thetaBar, dthetabarDz \
, N, Cp, Cv, Rd, g, V ) :
    
    dpidz = Lz.pi.dot(U1[3*N:4*N]) + Bc1.dot(U1[2*N:3*N])
    
    V[0:N] = U1[0:N]*Lx.dot(U1[0:N]) + U1[N:2*N]*Lz.u.dot(U1[0:N]) \
    + Cp*U1[2*N:3*N] * Lx.dot(U1[3*N:4*N])
    
    V[N:2*N] = U1[0:N] * Lx.dot(U1[N:2*N]) + U1[N:2*N] * Lz.w.dot(U1[N:2*N]) \
    + Cp*U1[2*N:3*N] * dpidz
    
    V[2*N:3*N] = U1[0:N] * Lx.dot(U1[2*N:3*N]) + U1[N:2*N] * Lz.th.dot(U1[2*N:3*N])
    
    V[3*N:4*N] = U1[0:N] * Lx.dot(U1[3*N:4*N]) + U1[N:2*N] * dpidz \
    + Rd/Cv*U1[3*N:4*N] * ( Lx.dot(U1[0:N]) + Lz.w.dot(U1[N:2*N]) )
    
    V = R*U0 -2*dtImp * V
    
    U2 = L.solve( V )
    
    t = t + dtImp
    
    return t, U2

###########################################################################

def saveContourPlot( U, t \
, testCase, var, nLev, nCol, N \
, xx, zz, CL \
, xLeft, xRight, zTop, dx, dz ) :
    
    if var == 0 :
        U = np.reshape( U[0*N:1*N], (nCol,nLev) )
        plt.contourf( xx, zz, np.transpose(U), 20 )
    elif var == 1 :
        U = np.reshape( U[1*N:2*N], (nCol,nLev) )
        plt.contourf( xx, zz, np.transpose(U), 20 )
    elif var == 2 :
        U = np.reshape( U[2*N:3*N], (nCol,nLev) )
        plt.contourf( xx, zz, np.transpose(U), CL )
    elif var == 3 :
        U = np.reshape( U[3*N:4*N], (nCol,nLev) )
        plt.contourf( xx, zz, np.transpose(U), 20 )
    else :
        sys.exit( "\nError: var should be 0, 1, 2, or 3 (u,w,th,pi)\n" )
    
    if testCase != "igw" :
        plt.axis( 'equal' )
    plt.axis( [ xLeft-dx, xRight+dx, -dz, zTop+dz ] )
    plt.colorbar()
    # plt.title( 'testCase = {0}, t = {1:04d}'.format(testCase,np.int(np.round(t)+1e-12)) )
    plt.savefig( '{0:04d}'.format(np.int(np.round(t)+1e-12))+'.png', bbox_inches = 'tight' )
    plt.clf()

###########################################################################

def printInfo( U, et, t, N ) :
    
    print()
    print( "t =", np.int(np.round(t)+1e-12) )
    print( "et =", time.clock()-et )
    et = time.clock()
    print( "minmaxU  =", [ np.min(U[0*N:1*N]), np.max(U[0*N:1*N]) ] )
    print( "minmaxW  =", [ np.min(U[1*N:2*N]), np.max(U[1*N:2*N]) ] )
    print( "minmaxTh =", [ np.min(U[2*N:3*N]), np.max(U[2*N:3*N]) ] )
    print( "minmaxPi =", [ np.min(U[3*N:4*N]), np.max(U[3*N:4*N]) ] )
    
    return et

###########################################################################
