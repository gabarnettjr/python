import sys
import numpy as np
import matplotlib.pyplot as plt
from scipy import spatial, sparse
import time

###########################################################################

def getConstants() :
    
    Cp = 1004.
    Cv = 717.
    Rd = Cp - Cv
    g  = 9.81
    
    return Cp, Cv, Rd, g

###########################################################################

def getTfinal( testCase ) :

    if testCase == "bubble" :
        tf = 1500.
    elif testCase == "igw" :
        tf = 3000.
    elif testCase == "densityCurrent" :
        tf = 900.
    elif testCase == "doubleDensityCurrent" :
        tf = 900.
    elif testCase == "movingDensityCurrent" :
        tf = 900.
    else :
        sys.exit( "\nError: Invalid testCase string.\n" )
    
    return tf

###########################################################################

def getSpaceDomain( testCase, dx, dz ) :
    
    if testCase == "bubble" :
        xLeft  = 0.
        xRight = 10000.
        zTop   = 10000.
    elif testCase == "igw" :
        xLeft  = 0.
        xRight = 300000.
        zTop   = 10000.
    elif testCase == "densityCurrent" :
        xLeft  = -25600.
        xRight = 25600.
        zTop   = 6400.
    elif testCase == "doubleDensityCurrent" :
        xLeft  = -6400.
        xRight = 6400.
        zTop   = 6400.
    elif testCase == "movingDensityCurrent" :
        xLeft  = -18000.
        xRight = 18000.
        zTop   = 6400.
    else :
        sys.exit( "\nError: Invalid test case string.\n" )
    
    nLev = np.int( np.round(zTop/dz) + 1e-12 )
    nCol = np.int( np.round((xRight-xLeft)/dx) + 1e-12 )
    N = nLev * nCol
    
    x = np.linspace( xLeft+dx/2., xRight-dx/2., nCol )
    z = np.linspace( 0+dz/2., zTop-dz/2., nLev )
    
    [ xx, zz ] = np.meshgrid( x, z )
    
    x = np.transpose(xx).flatten()
    # X = np.zeros(( N, 1 ))
    # X[:,0] = x
    # x = X
    
    z = np.transpose(zz).flatten()
    # Z = np.zeros(( N, 1 ))
    # Z[:,0] = z
    # z = Z
    
    return xLeft, xRight, zTop, nLev, nCol, N, xx, zz, x, z

###########################################################################

def getInitialConditions( testCase, nLev, nCol, x, z , Cp, Cv, Rd, g ) :
    
    N = nLev*nCol
    
    U = np.zeros(( 4*N ))
    
    null = np.zeros(( N ))
    e    = np.ones (( N ))
    
    if testCase == "bubble" :
        thetaBar = 300. * e
        piBar = 1. - g / Cp / thetaBar * z
        R = 1500.
        xc = 5000.
        zc = 3000.
        r = np.sqrt( (x-xc)**2 + (z-zc)**2 )
        ind = r < R
        thetaPrime0 = null
        thetaPrime0[ind] = 2. * ( 1. - r[ind]/R )
        piPrime0 = 0.
        U[0:N] = null
        dthetabarDz = null
    elif testCase == "igw" :
        N = .01
        theta0 = 300.
        thetaBar = theta0 * np.exp( (N**2/g) * z )
        piBar = 1. + g**2. / Cp / theta0 / N**2. * ( np.exp(-N**2./g*z) - 1. )
        thetaC = .01
        hC = 10000.
        aC = 5000.
        xC = 100000.
        thetaPrime0 = thetaC * np.sin( np.pi*z/hC ) / ( 1. + ((x-xC)/aC)**2 )
        piPrime0 = 0.
        U[0:N] = 20. * e
        dthetabarDz = theta0 * (N**2/g) * np.exp( (N**2/g) * z )
    elif testCase == "densityCurrent" :
        thetaBar = 300. * e
        piBar = 1. - g / Cp / thetaBar * z
        xc = 0.
        zc = 3000.
        xr = 4000.
        zr = 2000.
        rTilde = np.sqrt( ((x-xc)/xr)**2 + ((z-zc)/zr)**2 )
        Tprime0 = null
        ind = rTilde <= 1
        Tprime0[ind] = -15./2. * ( 1. + np.cos(np.pi*rTilde[ind]) )
        thetaPrime0 = Tprime0 / piBar
        piPrime0 = 0.
        U[0:N] = null
        dthetabarDz = null
    elif testCase == "doubleDensityCurrent" :
        thetaBar = 300. * e
        piBar = 1. - g / Cp / thetaBar * z
        xc1 = -6400.
        xc2 = 6400.
        zc = 3000.
        xr = 4000.
        zr = 2000.
        rTilde1 = np.sqrt( ((x-xc1)/xr)**2 + ((z-zc)/zr)**2 )
        rTilde2 = np.sqrt( ((x-xc2)/xr)**2 + ((z-zc)/zr)**2 )
        Tprime0 = null
        ind1 = rTilde1 <= 1
        ind2 = rTilde2 <= 1
        Tprime0[ind1] = -15./2. * ( 1. + np.cos(np.pi*rTilde1[ind1]) )
        Tprime0[ind2] = -15./2. * ( 1. + np.cos(np.pi*rTilde2[ind2]) )
        thetaPrime0 = Tprime0 / piBar
        piPrime0 = 0.
        U[0:N] = null
        dthetabarDz = null
    elif testCase == "movingDensityCurrent" :
        thetaBar = 300. * e
        piBar = 1. - g / Cp / thetaBar * z
        xc = 0.
        zc = 3000.
        xr = 4000.
        zr = 2000.
        rTilde = np.sqrt( ((x-xc)/xr)**2 + ((z-zc)/zr)**2 )
        Tprime0 = null
        ind = rTilde <= 1
        Tprime0[ind] = -15./2. * ( 1. + np.cos(np.pi*rTilde[ind]) )
        thetaPrime0 = Tprime0 / piBar
        piPrime0 = 0.
        U[0:N] = 20. * e
        dthetabarDz = null
    else :
        sys.exit("\nError: Invalid test case string.\n")
    
    dpibarDz = -g/Cp/thetaBar
    
    U[N:2*N]   = null
    U[2*N:3*N] = thetaPrime0
    U[3*N:4*N] = piPrime0
    
    return U, thetaBar, piBar, dthetabarDz, dpibarDz

###########################################################################

#Get sparse matrices for semi-implicit approximation of spatial operators.
#Lx is the differentiation matrix using periodic lateral boundaries.

def getDerivativeOperators( nCol, nLev, FD, dx, dz ) :
    
    if FD == 2 :
        wx  = np.array( [ -1./2., 0., 1./2. ] )
        hvx = np.array( [ 1., -2., 1. ] )
        gamma = 1./2.
    elif FD == 4 :
        wx  = np.array( [ 1./12., -2./3., 0., 2./3., -1./12. ] )
        hvx = np.array( [ 1., -4., 6., -4., 1 ] )
        gamma = -1./12.
    else :
        sys.exit( "\nError: FD should be 2 or 4 for this.\n" )
    wx  = wx  / dx
    hvx = hvx / dx
    
    if FD == 2 :
        #first derivative:
        v = np.zeros( (2,nCol), float )
        v[0,:] = wx[0] * np.ones( (nCol), float )
        v[1,:] = wx[2] * np.ones( (nCol), float )
        Lx = sparse.spdiags( v, [-1,1], nCol, nCol )
        Lx = sparse.lil_matrix( Lx )
        Lx[0,nCol-1] = wx[0]
        Lx[nCol-1,0] = wx[2]
        #second derivative:
        v = np.zeros( (3,nCol), float )
        v[0,:] = hvx[0] * np.ones( (nCol), float )
        v[1,:] = hvx[1] * np.ones( (nCol), float )
        v[2,:] = hvx[2] * np.ones( (nCol), float )
        HVx = sparse.spdiags( v, [-1,0,1], nCol, nCol )
        HVx = sparse.lil_matrix( HVx )
        HVx[0,nCol-1] = wx[0]
        HVx[nCol-1,0] = wx[2]
    elif FD == 4 :
        #first derivative:
        v = np.zeros( (4,nCol), float )
        v[0,:] = wx[0] * np.ones( (nCol), float )
        v[1,:] = wx[1] * np.ones( (nCol), float )
        v[2,:] = wx[3] * np.ones( (nCol), float )
        v[3,:] = wx[4] * np.ones( (nCol), float )
        Lx = sparse.spdiags( v, [-2,-1,1,2], nCol, nCol )
        Lx = sparse.lil_matrix( Lx )
        Lx[0,nCol-2] = wx[0]
        Lx[0,nCol-1] = wx[1]
        Lx[1,nCol-1] = wx[0]
        Lx[nCol-2,0] = wx[4]
        Lx[nCol-1,0] = wx[3]
        Lx[nCol-1,1] = wx[4]
        #fourth derivative:
        v = np.zeros( (5,nCol), float )
        v[0,:] = hvx[0] * np.ones( (nCol), float )
        v[1,:] = hvx[1] * np.ones( (nCol), float )
        v[2,:] = hvx[2] * np.ones( (nCol), float )
        v[3,:] = hvx[3] * np.ones( (nCol), float )
        v[4,:] = hvx[4] * np.ones( (nCol), float )
        HVx = sparse.spdiags( v, [-2,-1,0,1,2], nCol, nCol )
        HVx = sparse.lil_matrix( HVx )
        HVx[0,nCol-2] = hvx[0]
        HVx[0,nCol-1] = hvx[1]
        HVx[1,nCol-1] = hvx[0]
        HVx[nCol-2,0] = hvx[4]
        HVx[nCol-1,0] = hvx[3]
        HVx[nCol-1,1] = hvx[4]
    else :
        sys.exit( '\nError: FD should be 2 or 4.\n' )
    I = sparse.eye( nLev, nLev, 0, float )
    Lx  = sparse.kron( Lx,  I )
    HVx = sparse.kron( HVx, I )
    
    #first derivative:
    v = np.zeros( (2,nLev), float )
    v[0,:] = -np.ones( (nLev), float )
    v[1,:] =  np.ones( (nLev), float )
    L = sparse.spdiags( v, [-1,1], nLev, nLev )
    L = sparse.lil_matrix( L )
    #second derivative:
    v = np.zeros( (3,nLev), float )
    v[0,:] =  1.*np.ones( (nLev), float )
    v[1,:] = -2.*np.ones( (nLev), float )
    v[2,:] =  1.*np.ones( (nLev), float )
    HV = sparse.spdiags( v, [-1,0,1], nLev, nLev )
    HV = sparse.lil_matrix( HV )
    
    class struct :
        pass
    
    I = sparse.eye( nCol, nCol, 0, float )
    
    #Lz:
    Lz  = struct
    Lz.u  = L
    Lz.w  = L
    Lz.pi = L
    Lz.u [ 0,      0      ] = -2.
    Lz.u [ 0,      1      ] =  2.
    Lz.u [ nLev-1, nLev-2 ] = -2.
    Lz.u [ nLev-1, nLev-1 ] =  2.
    Lz.w [ 0,      0      ] =  1.
    Lz.w [ 0,      1      ] =  1.
    Lz.w [ nLev-1, nLev-2 ] = -1.
    Lz.w [ nLev-1, nLev-1 ] = -1.
    Lz.pi[ 0,      0      ] = -1.
    Lz.pi[ 0,      1      ] =  1.
    Lz.pi[ nLev-1, nLev-2 ] = -1.
    Lz.pi[ nLev-1, nLev-1 ] =  1.
    Lz.u  = Lz.u  / (2.*dz)
    Lz.w  = Lz.w  / (2.*dz)
    Lz.pi = Lz.pi / (2.*dz)
    Lz.u  = sparse.kron( I, Lz.u  )
    Lz.w  = sparse.kron( I, Lz.w  )
    Lz.pi = sparse.kron( I, Lz.pi )
    Lz.th = Lz.u
    
    #HVz:
    HVz  = struct
    HVz.u  = HV
    HVz.w  = HV
    HVz.pi = HV
    HVz.u [ 0,      0      ] =  0.
    HVz.u [ 0,      1      ] =  0.
    HVz.u [ nLev-1, nLev-2 ] =  0.
    HVz.u [ nLev-1, nLev-1 ] =  0.
    HVz.w [ 0,      0      ] = -3.
    HVz.w [ 0,      1      ] =  1.
    HVz.w [ nLev-1, nLev-2 ] =  1.
    HVz.w [ nLev-1, nLev-1 ] = -3.
    HVz.pi[ 0,      0      ] = -1.
    HVz.pi[ 0,      1      ] =  1.
    HVz.pi[ nLev-1, nLev-2 ] = -1.
    HVz.pi[ nLev-1, nLev-1 ] =  1.
    HVz.u  = HVz.u  / dz
    HVz.w  = HVz.w  / dz
    HVz.pi = HVz.pi / dz
    HVz.u  = sparse.kron( I, HVz.u  )
    HVz.w  = sparse.kron( I, HVz.w  )
    HVz.pi = sparse.kron( I, HVz.pi )
    HVz.th = HVz.u
    
    return Lx, Lz, HVx, HVz, gamma

###########################################################################

def getBoundaryConditionMatrices( thetaBar, nLev, nCol, g, Cp ) :
    
    ii = np.zeros( (4*nCol), int )
    k = 1
    for i in range(2*nCol) :
        if np.mod(i,2) == 0 :
            ii[2*i]    = (k-1)*nLev
            ii[2*i+1]  = (k-1)*nLev
        else :
            ii[2*i]    = k*nLev - 1
            ii[2*i+1]  = k*nLev - 1
            k = k + 1
    
    jj = np.zeros( (4*nCol), int )
    jj[0] = 0
    jj[1] = 1
    k = 2
    for i in range(1,nCol) :
        jj[k]   = i*nLev-2
        jj[k+1] = i*nLev-1
        jj[k+2] = i*nLev
        jj[k+3] = i*nLev+1
        k = k + 4
    jj[k]   = nCol*nLev-2
    jj[k+1] = nCol*nLev-1
    
    thetaBar = np.reshape( thetaBar, (nCol,nLev) )
    thetaBar = np.transpose( thetaBar )
    
    thetaBarBot = thetaBar[0,:]
    thetaBarBotHalf = 3./2.*thetaBar[0,:] - 1./2.*thetaBar[1,:]
    
    thetaBarTop = thetaBar[nLev-1,:]
    thetaBarTopHalf = 3./2.*thetaBar[nLev-1,:] - 1./2.*thetaBar[nLev-2,:]
    
    # cBot1 = g * thetaBarBot / thetaBarBotHalf**2.
    # cTop1 = g * thetaBarTop / thetaBarTopHalf**2.
    
    cBot2 = g / Cp  / thetaBarBotHalf**2.
    cTop2 = g / Cp  / thetaBarTopHalf**2.
    
    cBot1 = cBot2
    cTop1 = cTop2
    
    bc1 = np.zeros( (4*nCol), float )
    bc2 = np.zeros( (4*nCol), float )
    k = 0
    for i in range(nCol) :
        bc1[k]   =  3./4.*cBot1[i]
        bc1[k+1] = -1./4.*cBot1[i]
        bc1[k+2] = -1./4.*cTop1[i]
        bc1[k+3] =  3./4.*cTop1[i]
        bc2[k]   = -3./2.*cBot2[i]
        bc2[k+1] =  1./2.*cBot2[i]
        bc2[k+2] = -1./2.*cTop2[i]
        bc2[k+3] =  3./2.*cTop2[i]
        k = k + 4
    
    Bc1 = sparse.csr_matrix( (bc1,(ii,jj)), (nLev*nCol,nLev*nCol) )
    Bc2 = sparse.csr_matrix( (bc2,(ii,jj)), (nLev*nCol,nLev*nCol) )
    
    return Bc1, Bc2

###########################################################################

def getBlockMatrix( Lx, Lz, Bc1, nLev, nCol \
, thetaBar, piBar \
, Cp, Cv, Rd ) :
    
    thetaBar = sparse.spdiags( thetaBar, [0], nLev*nCol, nLev*nCol )
    piBar    = sparse.spdiags( piBar,    [0], nLev*nCol, nLev*nCol )
    
    O = sparse.lil_matrix(( nLev*nCol, nLev*nCol ))
    I = sparse.eye( nLev*nCol )
    
    A1 = sparse.hstack(( O,              O,                O,   Cp*thetaBar*Lx    ))
    A2 = sparse.hstack(( O,              O,                Bc1, Cp*thetaBar*Lz.pi ))
    A3 = sparse.hstack(( O,              O,                O,   O                 ))
    A4 = sparse.hstack(( Rd/Cv*piBar*Lx, Rd/Cv*piBar*Lz.w, O,   O                 ))
    
    A = sparse.vstack(( A1, A2, A3, A4 ))
    
    return A

###########################################################################

def odeFun( t, U \
, Lx, Lz, HVx, HVz, Bc1, Bc2 \
, thetaBar, piBar, dthetabarDz, dpibarDz \
, N, gamma, Rd, Cv, Cp, g ) :
    
    V = np.zeros(( 4*N ))
    
    gammaAbsU = gamma*np.abs(U[0:N])
    halfAbsW  = 1./2.*np.abs(U[N:2*N])
    
    V[0:N] = -U[0:N]*Lx.dot(U[0:N]) - U[N:2*N]*Lz.u.dot(U[0:N]) \
    - Cp * ( thetaBar + U[2*N:3*N] ) * Lx.dot(U[3*N:4*N]) \
    + gammaAbsU * HVx.dot(U[0:N]) \
    + halfAbsW  * HVz.u.dot(U[0:N])
    
    V[N:2*N] = -U[0:N]*Lx.dot(U[N:2*N]) - U[N:2*N]*Lz.w.dot(U[N:2*N]) \
    - Cp * ( thetaBar + U[2*N:3*N] ) * ( Lz.pi.dot(U[3*N:4*N]) + Bc1.dot(U[2*N:3*N]) ) \
    + g * U[2*N:3*N] / thetaBar \
    + gammaAbsU * HVx.dot(U[N:2*N]) \
    + halfAbsW  * HVz.w.dot(U[N:2*N])
    
    V[2*N:3*N] = -U[0:N]*Lx.dot(U[2*N:3*N]) - U[N:2*N]*Lz.th.dot(U[2*N:3*N]) \
    - U[N:2*N]*dthetabarDz \
    + gammaAbsU * HVx.dot(U[2*N:3*N]) \
    + halfAbsW  * HVz.th.dot(U[2*N:3*N])
    
    V[3*N:4*N] = -U[0:N]*Lx.dot(U[3*N:4*N]) - U[N:2*N]*Lz.pi.dot(U[3*N:4*N]) \
    -U[N:2*N]*dpibarDz \
    -Rd/Cv * ( piBar + U[3*N:4*N] ) * ( Lx.dot(U[0:N]) + Lz.w.dot(U[N:2*N]) ) \
    + gammaAbsU * HVx.dot(U[3*N:4*N]) \
    + halfAbsW  * ( HVz.pi.dot(U[3*N:4*N]) + Bc2.dot(U[2*N:3*N]) )
    
    return V

###########################################################################

def leapfrogTimestep( t, dt, U ) :
    
    
    
    return U

###########################################################################

def printInfo( U, et , t, N ) :
    
    print()
    print( "t =", np.int(np.round(t)+1e-12) )
    print( "et =", time.clock()-et )
    et = time.clock()
    print( "minmaxU  =", [ np.min(U[0:N]),     np.max(U[0:N])     ] )
    print( "minmaxW  =", [ np.min(U[N:2*N]),   np.max(U[N:2*N])   ] )
    print( "minmaxTh =", [ np.min(U[2*N:3*N]), np.max(U[2*N:3*N]) ] )
    print( "minmaxPi =", [ np.min(U[3*N:4*N]), np.max(U[3*N:4*N]) ] )
    
    return et

###########################################################################