import sys
import numpy as np
import matplotlib.pyplot as plt
from scipy import spatial, sparse
import time

###########################################################################

def getInitialConditions( testCase, nLev, nCol, x, z \
, Cp, Cv, Rd, g, Po ) :
    
    U = np.zeros(( nLev*nCol, 4 ))
    
    if testCase == "bubble" :
        thetaBar = 300. * np.ones(( nLev*nCol ))
        piBar = 1. - g / Cp / thetaBar * z
        R = 1500.
        xc = 5000.
        zc = 3000.
        r = np.sqrt( (x-xc)**2 + (z-zc)**2 )
        ind = r < R
        thetaPrime0 = np. zeros( np.shape(r) )
        thetaPrime0[ind] = 2. * ( 1. - r[ind]/R )
        piPrime0 = 0.
        U[:,0] = np.zeros(( nLev*nCol ))
    elif testCase == "igw" :
        N = .01
        theta0 = 300.
        thetaBar = theta0 * np.exp( (N**2/g) * z )
        piBar = 1. + g**2. / Cp / theta0 / N**2. * ( np.exp(-N**2./g*z) - 1. )
        thetaC = .01
        hC = 10000.
        aC = 5000.
        xC = 100000.
        thetaPrime0 = thetaC * np.sin( np.pi*z/hC ) / ( 1. + ((x-xC)/aC)**2 )
        piPrime0 = 0.
        U[:,0] = 20. * np.ones( np.shape(thetaPrime0) )
    elif testCase == "densityCurrent" :
        thetaBar = 300. * np.ones(( nLev*nCol ))
        piBar = 1. - g / Cp / thetaBar * z
        xc = 0.
        zc = 3000.
        xr = 4000.
        zr = 2000.
        rTilde = np.sqrt( ((x-xc)/xr)**2 + ((z-zc)/zr)**2 )
        Tprime0 = np.zeros( np.shape(thetaBar) )
        ind = rTilde <= 1
        Tprime0[ind] = -15./2. * ( 1. + np.cos(np.pi*rTilde[ind]) )
        thetaPrime0 = Tprime0 / piBar
        piPrime0 = 0.
        U[:,0] = np.zeros( np.shape(thetaBar) )
    elif testCase == "doubleDensityCurrent" :
        thetaBar = 300. * np.ones(( nLev*nCol ))
        piBar = 1. - g / Cp / thetaBar * z
        xc1 = -6400.
        xc2 = 6400.
        zc = 3000.
        xr = 4000.
        zr = 2000.
        rTilde1 = np.sqrt( ((x-xc1)/xr)**2 + ((z-zc)/zr)**2 )
        rTilde2 = np.sqrt( ((x-xc2)/xr)**2 + ((z-zc)/zr)**2 )
        Tprime0 = np.zeros( np.shape(thetaBar) )
        ind1 = rTilde1 <= 1
        ind2 = rTilde2 <= 1
        Tprime0[ind1] = -15./2. * ( 1. + np.cos(np.pi*rTilde1[ind1]) )
        Tprime0[ind2] = -15./2. * ( 1. + np.cos(np.pi*rTilde2[ind2]) )
        thetaPrime0 = Tprime0 / piBar
        piPrime0 = 0.
        U[:,0] = np.zeros( np.shape(thetaBar) )
    elif testCase == "movingDensityCurrent" :
        thetaBar = 300. * np.ones(( nLev*nCol ))
        piBar = 1. - g / Cp / thetaBar * z
        xc = 0.
        zc = 3000.
        xr = 4000.
        zr = 2000.
        rTilde = np.sqrt( ((x-xc)/xr)**2 + ((z-zc)/zr)**2 )
        Tprime0 = np.zeros( np.shape(thetaBar) )
        ind = rTilde <= 1
        Tprime0[ind] = -15./2. * ( 1. + np.cos(np.pi*rTilde[ind]) )
        thetaPrime0 = Tprime0 / piBar
        piPrime0 = 0.
        U[:,0] = 20. * np.ones( np.shape(thetaBar) )
    else :
        sys.exit("\nError: Invalid test case string.\n")
    
    U[:,1] = np.zeros( np.shape(thetaBar) )
    U[:,2] = thetaBar + thetaPrime0
    
    U[3,:,:] = piBar + piPrime0
    
    return U, thetaBar, piBar, dthetabarDx, dthetabarDz, dpibarDx, dpibarDz

###########################################################################

#Get sparse matrices for semi-implicit approximation of spatial operators.
#Lx is the differentiation matrix using periodic lateral boundaries.

def getDerivativeOperators( nCol, nLev, FD, dx, dz ) :
    
    if FD == 2 :
        wx = np.array( [ -1./2., 0., 1./2. ] )
    elif FD == 4 :
        wx = np.array( [ 1./12., -2./3., 0., 2./3., -1./12. ] )
    else :
        sys.exit( "\nError: FD should be 2 or 4 for this.\n" )
    wx = wx / dx
    
    v = np.zeros( (FD,nCol), float )
    if FD == 2 :
        v[0,:] = wx[0] * np.ones( (nCol), float )
        v[1,:] = wx[2] * np.ones( (nCol), float )
        Lx = sparse.spdiags( v, [-1,1], nCol, nCol )
        Lx = sparse.lil_matrix( Lx )
        Lx[0,nCol-1] = wx[0]
        Lx[nCol-1,0] = wx[2]
    elif FD == 4 :
        v[0,:] = wx[0] * np.ones( (nCol), float )
        v[1,:] = wx[1] * np.ones( (nCol), float )
        v[2,:] = wx[3] * np.ones( (nCol), float )
        v[3,:] = wx[4] * np.ones( (nCol), float )
        Lx = sparse.spdiags( v, [-2,-1,1,2], nCol, nCol )
        Lx = sparse.lil_matrix( Lx )
        Lx[0,nCol-2] = wx[0]
        Lx[0,nCol-1] = wx[1]
        Lx[1,nCol-1] = wx[0]
        Lx[nCol-2,0] = wx[4]
        Lx[nCol-1,0] = wx[3]
        Lx[nCol-1,1] = wx[4]
    else :
        sys.exit( '\nError: FD should be 2 or 4.\n' )
    I = sparse.eye( nLev, nLev, 0, float )
    Lx = sparse.kron( Lx, I )
    
    v = np.zeros( (2,nLev), float )
    v[0,:] = -np.ones( (nLev), float )
    v[1,:] =  np.ones( (nLev), float )
    L = sparse.spdiags( v, [-1,1], nLev, nLev )
    L = sparse.lil_matrix( L )
    
    class Lz :
        pass
    
    Lz.u  = L
    Lz.w  = L
    Lz.pi = L
    
    Lz.u[ 0,      0      ] = -2.
    Lz.u[ 0,      1      ] =  2.
    Lz.u[ nLev-1, nLev-2 ] = -2.
    Lz.u[ nLev-1, nLev-1 ] =  2.
    
    Lz.w[ 0,      0      ] =  1.
    Lz.w[ 0,      1      ] =  1.
    Lz.w[ nLev-1, nLev-2 ] = -1.
    Lz.w[ nLev-1, nLev-1 ] = -1.
    
    Lz.pi[ 0,      0      ] = -1.
    Lz.pi[ 0,      1      ] =  1.
    Lz.pi[ nLev-1, nLev-2 ] = -1.
    Lz.pi[ nLev-1, nLev-1 ] =  1.
    
    Lz.u  = Lz.u  / (2.*dz)
    Lz.w  = Lz.w  / (2.*dz)
    Lz.pi = Lz.pi / (2.*dz)
    
    I = sparse.eye( nCol, nCol, 0, float )
    
    Lz.u  = sparse.kron( I, Lz.u  )
    Lz.w  = sparse.kron( I, Lz.w  )
    Lz.pi = sparse.kron( I, Lz.pi )
    
    Lz.th = Lz.u
    
    return Lx, Lz

###########################################################################

def getBlockMatrix( Lx, Lz, nLev, nCol \
, thetaBar, piBar, dpibarDx, dpibarDz \
, Cp, Cv, Rd, g ) :
    
    thetaBar = sparse.spdiags( thetaBar, [0], nLev*nCol, nLev*nCol )
    piBar    = sparse.spdiags( piBar,    [0], nLev*nCol, nLev*nCol )
    dpibarDx = sparse.spdiags( dpibarDx, [0], nLev*nCol, nLev*nCol )
    dpibarDz = sparse.spdiags( dpibarDz, [0], nLev*nCol, nLev*nCol )
    
    N = sparse.lil_matrix(( nLev*nCol, nLev*nCol ))
    I = sparse.eye( nLev*nCol )
    
    A1 = sparse.hstack(( N,              N,                Cp*dpibarDx*I,    Cp*thetaBar*Lx    ))
    A2 = sparse.hstack(( N,              N,                Cp*dpibarDz*I+Bc, Cp*thetaBar*Lz.pi ))
    A3 = sparse.hstack(( N,              N,                N,                N                 ))
    A4 = sparse.hstack(( Rd/Cv*piBar*Lx, Rd/Cv*piBar*Lz.w, N,                N                 ))
    
    A = sparse.vstack(( A1, A2, A3, A4 ))
    
    return A

###########################################################################

def getInitialConditions( testCase, nLev, nCol, x, z , Cp, Cv, Rd, g ) :
    
    U = np.zeros(( 4, nLev*nCol ))
    
    if testCase == "bubble" :
        thetaBar = 300. * np.ones(( nLev*nCol ))
        piBar = 1. - g / Cp / thetaBar * z
        R = 1500.
        xc = 5000.
        zc = 3000.
        r = np.sqrt( (x-xc)**2 + (z-zc)**2 )
        ind = r < R
        thetaPrime0 = np. zeros( np.shape(r) )
        thetaPrime0[ind] = 2. * ( 1. - r[ind]/R )
        piPrime0 = 0.
        U[0,:] = np.zeros(( nLev*nCol ))
    elif testCase == "igw" :
        N = .01
        theta0 = 300.
        thetaBar = theta0 * np.exp( (N**2/g) * z )
        piBar = 1. + g**2. / Cp / theta0 / N**2. * ( np.exp(-N**2./g*z) - 1. )
        thetaC = .01
        hC = 10000.
        aC = 5000.
        xC = 100000.
        thetaPrime0 = thetaC * np.sin( np.pi*z/hC ) / ( 1. + ((x-xC)/aC)**2 )
        piPrime0 = 0.
        U[0,:] = 20. * np.ones( np.shape(thetaPrime0) )
    elif testCase == "densityCurrent" :
        thetaBar = 300. * np.ones(( nLev*nCol ))
        piBar = 1. - g / Cp / thetaBar * z
        xc = 0.
        zc = 3000.
        xr = 4000.
        zr = 2000.
        rTilde = np.sqrt( ((x-xc)/xr)**2 + ((z-zc)/zr)**2 )
        Tprime0 = np.zeros( np.shape(thetaBar) )
        ind = rTilde <= 1
        Tprime0[ind] = -15./2. * ( 1. + np.cos(np.pi*rTilde[ind]) )
        thetaPrime0 = Tprime0 / piBar
        piPrime0 = 0.
        U[0,:] = np.zeros( np.shape(thetaBar) )
    elif testCase == "doubleDensityCurrent" :
        thetaBar = 300. * np.ones(( nLev*nCol ))
        piBar = 1. - g / Cp / thetaBar * z
        xc1 = -6400.
        xc2 = 6400.
        zc = 3000.
        xr = 4000.
        zr = 2000.
        rTilde1 = np.sqrt( ((x-xc1)/xr)**2 + ((z-zc)/zr)**2 )
        rTilde2 = np.sqrt( ((x-xc2)/xr)**2 + ((z-zc)/zr)**2 )
        Tprime0 = np.zeros( np.shape(thetaBar) )
        ind1 = rTilde1 <= 1
        ind2 = rTilde2 <= 1
        Tprime0[ind1] = -15./2. * ( 1. + np.cos(np.pi*rTilde1[ind1]) )
        Tprime0[ind2] = -15./2. * ( 1. + np.cos(np.pi*rTilde2[ind2]) )
        thetaPrime0 = Tprime0 / piBar
        piPrime0 = 0.
        U[0,:] = np.zeros( np.shape(thetaBar) )
    elif testCase == "movingDensityCurrent" :
        thetaBar = 300. * np.ones(( nLev*nCol ))
        piBar = 1. - g / Cp / thetaBar * z
        xc = 0.
        zc = 3000.
        xr = 4000.
        zr = 2000.
        rTilde = np.sqrt( ((x-xc)/xr)**2 + ((z-zc)/zr)**2 )
        Tprime0 = np.zeros( np.shape(thetaBar) )
        ind = rTilde <= 1
        Tprime0[ind] = -15./2. * ( 1. + np.cos(np.pi*rTilde[ind]) )
        thetaPrime0 = Tprime0 / piBar
        piPrime0 = 0.
        U[0,:] = 20. * np.ones( np.shape(thetaBar) )
    else :
        sys.exit("\nError: Invalid test case string.\n")
    
    U[1,:] = np.zeros( np.shape(thetaBar) )
    U[2,:] = thetaPrime0
    U[3,:] = piPrime0
    
    return U, thetaBar, piBar
    # , dthetabarDx, dthetabarDz, dpibarDx, dpibarDz

###########################################################################