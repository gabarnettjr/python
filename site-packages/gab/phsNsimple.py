
import numpy as np
from scipy import spatial

from mpl_toolkits.mplot3d import Axes3D  
import matplotlib.pyplot as plt
import halton

###########################################################################

# Approximate the value of a function based on known values, using a local
# cubic (rbfParam = 3) polyharmonic spline RBF approximation, together with
# polynomials up to degree 1.

# Greg Barnett
# July 2022

###########################################################################

# PHS RBF.  x is a vector.

def phi( x, rbfParam ) :
    z = x[0]**2
    for d in range(1, len(x)):
        z = z + x[d]**2
    z = z ** (rbfParam / 2)
    return z

###########################################################################

# Given points pts, where you know the values, and a point ptE, where you
# want to know the value, this function returns the index of the
# stencilSize nearest points in pts to ptE, origin-shifted.

def getStencil( pts, ptE, stencilSize, tree = () ) :
    
    if tree == () :
        tree = spatial.KDTree(pts)
    
    class stencil :
        pass
    
    stencil.idx = tree.query( ptE, stencilSize )
    stencil.rad = stencil.idx[0]
    stencil.idx = stencil.idx[1]
    
    stencil.pts = np.zeros(( stencilSize, len(ptE) ))
    for d in range( len(ptE) ) :
        stencil.pts[:,d] = pts[:,d][stencil.idx] - np.tile( ptE[d], (1, stencilSize) )

    stencil.size = stencilSize
    stencil.dim = len(ptE)
    
    return stencil

###########################################################################

def getAmatrix( stencil ) :
    
    class A :
        pass
    
    A.rbfParam = 3
    A.numPoly = 1 + stencil.dim
    A.matrix = np.zeros(( stencil.size + A.numPoly, stencil.size + A.numPoly ))
    
    for i in range(stencil.size) :
        for j in range(stencil.size) :
            A.matrix[i, j] = phi( stencil.pts[i,:] - stencil.pts[j,:], A.rbfParam )
        A.matrix[i, stencil.size] = 1
        A.matrix[stencil.size, i] = 1
        for j in range( stencil.size + 1, len(A.matrix) ) :
            A.matrix[i, j] = stencil.pts[i, j - stencil.size - 1]
            A.matrix[j, i] = stencil.pts[i, j - stencil.size - 1]
    
    # A.cond = np.linalg.cond(A.matrices)
    
    return A

###########################################################################

# f is a vector of known function values.

def getApprox( stencil, A, f ) :

    f = np.transpose( np.hstack(( f[stencil.idx], np.zeros((A.numPoly)) )) )
    
    b = np.zeros(( stencil.size + A.numPoly ))
    
    for j in range(stencil.size) :
        b[j] = phi( 0 - stencil.pts[j,:], A.rbfParam )
    b[stencil.size] = 1
    
    lam = np.linalg.solve( A.matrix, f )
    
    return b.dot(lam)

###########################################################################

# If you are changing things in here and re-running this test, then
# make sure you are in the same directory as this file, and do it like this
# in a python or ipython session:

# if True:
    # import importlib
    # import phsNsimple
    # importlib.reload(phsNsimple)
    # phsNsimple.testThisLibrary()

def testThisLibrary() :
        
    # Points where you know function values:
    dim = 8
    n = 1000
    pts = halton.halton(dim, n)
    # pts = np.random.rand(n, dim)
    
    # Number of evaluation points:
    N = 1000
    
    # Number of nearest neighbors to use when approximating:
    stencilSize = 30
    
    # Exact function to sample:
    def func(x) :
        try:
            p = (x[:,0] - .5) ** 2
            for i in range(1, dim) :
                p = p + (x[:,i] - .5) ** 2  
        except:
            p = (x[0] - .5) ** 2
            for i in range(1, dim) :
                p = p + (x[i] - .5) ** 2
        return np.exp(-40 * p)
    
    # Points where you WANT to know function values (eval pts):
    ptsE = 0.1 + 0.8 * np.random.rand(N, dim)
    # x = np.linspace( .1, .9, int(np.sqrt(N)) )
    # y = x.copy()
    # xx, yy = np.meshgrid(x, y)
    # ptsE = np.vstack(( xx.flatten(), yy.flatten() )) . T
    
    # # Plot the points where you know the function values, and
    # # the points where you WANT to know the function values:
    # plt.figure(1)
    # plt.plot( pts[:,0], pts[:,1], '.' )
    # plt.plot( ptsE[:,0], ptsE[:,1], 'x' )
    # plt.axis('image')
    # plt.axis([0, 1, 0, 1])
    # plt.show()

    # Use this library to get an approximation at each eval pt:
    approx = np.zeros( len(ptsE) )
    tree = spatial.KDTree(pts)
    for i in range( len(ptsE) ) :
        stencil = getStencil( pts, ptsE[i,:], stencilSize, tree = tree )
        A = getAmatrix( stencil )
        approx[i] = getApprox( stencil, A, func(pts) )
    
    # # Plot the approximation next to the exact function, for comparison:
    # approx = np.reshape( approx, np.shape(xx) )
    # exact = np.reshape(func(ptsE), np.shape(xx))
    # fig = plt.figure(2)
    # ax = fig.add_subplot( 131, projection = '3d' )
    # ax.plot_surface( xx, yy, approx )
    # plt.title("approximation")
    # ax = fig.add_subplot( 132, projection = '3d' )
    # ax.plot_surface( xx, yy, exact )
    # plt.title("exact")
    # ax = fig.add_subplot( 133, projection = '3d' )
    # ax.plot_surface( xx, yy, approx - exact )
    # plt.title("diff")
    # plt.show()

    # Get the average error:
    err = np.abs(approx[0] - func(ptsE[0,:]))
    for i in range( 1, len(ptsE) ) :
        err = err + np.abs(approx[i] - func(ptsE[i,:]))
    err = err / len(ptsE)
    print("Average Error = " + str(err))
        
    return
