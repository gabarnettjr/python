
import numpy as np
from scipy import spatial

from mpl_toolkits.mplot3d import Axes3D  
import matplotlib.pyplot as plt
import halton


###########################################################################

# Approximate the value of a function based on known values, using a local
# cubic (rbfParam = 3) polyharmonic spline RBF approximation, together with
# polynomials up to degree 1.

# Greg Barnett
# July 2022

###########################################################################

# PHS RBF.  x is a vector.

def phi( x, rbfParam ) :
    z = x[0]**2
    for d in range(1, len(x)):
        z = z + x[d]**2
    z = z ** (rbfParam / 2)
    return z

###########################################################################

# Given points pts, where you know the values, and a point ptE, where you
# want to know the value, this function returns the index of the
# stencilSize nearest points in pts to ptE, origin-shifted.

def getStencil( pts, ptE, stencilSize, tree = () ) :
    
    if tree == () :
        tree = spatial.KDTree(pts)
    
    class stencil :
        pass
    
    stencil.idx = tree.query( ptE, stencilSize )
    stencil.rad = stencil.idx[0]
    stencil.idx = stencil.idx[1]
    
    stencil.pts = np.zeros(( stencilSize, len(ptE) ))
    for d in range( len(ptE) ) :
        stencil.pts[:,d] = pts[:,d][stencil.idx] - np.tile( ptE[d], (1, stencilSize) )

    stencil.size = stencilSize
    stencil.dim = len(ptE)
    
    return stencil

###########################################################################

def getAmatrix( stencil ) :
    
    class A :
        pass
    
    A.rbfParam = 3
    A.numPoly = 1 + stencil.dim
    A.matrix = np.zeros(( stencil.size + A.numPoly, stencil.size + A.numPoly ))
    
    for i in range(stencil.size) :
        for j in range(stencil.size) :
            A.matrix[i, j] = phi( stencil.pts[i,:] - stencil.pts[j,:], A.rbfParam )
        A.matrix[i, stencil.size] = 1
        A.matrix[stencil.size, i] = 1
        for j in range( stencil.size + 1, len(A.matrix) ) :
            A.matrix[i, j] = stencil.pts[i, j - stencil.size - 1]
            A.matrix[j, i] = stencil.pts[i, j - stencil.size - 1]
    
    # A.cond = np.linalg.cond(A.matrices)
    
    return A

###########################################################################

# f is a vector of known function values.

def getApprox( stencil, A, f ) :

    f = np.transpose( np.hstack(( f[stencil.idx], np.zeros((A.numPoly)) )) )
    
    b = np.zeros(( stencil.size + A.numPoly ))
    
    for j in range(stencil.size) :
        b[j] = phi( 0 - stencil.pts[j,:], A.rbfParam )
    b[stencil.size] = 1
    
    lam = np.linalg.solve( A.matrix, f )
    
    return b.dot(lam)

###########################################################################

# If you are changing things in here and re-running this test, then
# do it like this in a python or ipython session:

# if True:
#   import importlib
#   import phsNsimple
#   importlib.reload(phsNsimple)
#   phsNsimple.testThisLibrary()

def testThisLibrary() :

    def func(x, y) :
        return np.cos( 2*np.pi * x ) * np.cos( 2*np.pi * y )
        # return np.exp( -10 * ( (x-.4)**2 + (y-.7)**2 ) )

    # Points where you know function values:
    dim = 2
    n = 1000
    pts = halton.halton(dim, n)

    # Points where you WANT to know function values (eval pts):
    x = np.linspace(.1, .9, 20)
    y = x.copy()
    [xx, yy] = np.meshgrid(x, y)
    ptsE = np.transpose( np.vstack(( xx.flatten(), yy.flatten() )) )

    # Number of nearest neighbors to use when approximating:
    stencilSize = 20

    # Plot the points where you know the function values, and
    # the points where you WANT to know the function values:
    plt.figure(1)
    plt.plot( pts[:,0], pts[:,1], '.' )
    plt.plot( xx.flatten(), yy.flatten(), 'x' )
    plt.axis('image')
    plt.axis([0, 1, 0, 1])
    plt.show()

    # Use this library to get an approximation at each eval pt:
    approx = np.zeros( len(ptsE) )
    tree = spatial.KDTree(pts)
    for i in range( len(ptsE) ) :
        stencil = getStencil( pts, ptsE[i,:], stencilSize, tree = tree )
        A = getAmatrix( stencil )
        approx[i] = getApprox( stencil, A, func(pts[:,0], pts[:,1]) )

    # Plot the approximation next to the exact function, for comparison:
    approx = np.reshape( approx, np.shape(xx) )
    fig = plt.figure(2)
    ax = fig.add_subplot( 131, projection = '3d' )
    ax.plot_surface( xx, yy, approx )
    plt.title("approximation")
    ax = fig.add_subplot( 132, projection = '3d' )
    ax.plot_surface( xx, yy, func(xx, yy) )
    plt.title("exact")
    ax = fig.add_subplot( 133, projection = '3d' )
    ax.plot_surface( xx, yy, approx - func(xx, yy) )
    plt.title("diff")
    plt.show()

    return
