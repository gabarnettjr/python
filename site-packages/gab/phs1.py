import numpy as np
from math import factorial
from scipy.sparse import csr_matrix, lil_matrix
from scipy.spatial import cKDTree

###########################################################################

def getWeights( z=0., x=np.arange(-3.,4.,1.), m=1 \
, phsDegree=5, polyDegree=3 \
, P=np.array([]), A=np.array([]), b=np.array([]) ) :
    
    """
    z (real) is where to approximate the derivative.
    x (real row-vector) is where function values are located.
    m (integer) is the derivative to approximate (0 for interpolation).
    phsDegree (odd integer) is the exponent in the PHS RBF.
    polyDegree is the highest degree polynomial to include in the basis.
    P (zeros) is optional ( len(x), polyDegree+1 )
    A (zeros) is optional ( len(x)+polyDegree+1, len(x)+polyDegree+1 )
    b (zeros) is optional ( len(x)+polyDegree+1, )
    
    The output w is a row-vector such that sum(w*f(x)) approximates the mth
    derivative of f at z.
    
    Successful approximation with polyharmonic spline RBFs and polynomials
    requires that two conditions be met:
        (1) len(x) >= polyDegree+1
        (2) phsDegree >= m+1
    
    Warning: To approximate the mth derivative with accuracy O(dx) on
    irregulary spaced nodes, the length of the vector x must be at least
    m+1.
    """
    
    width = np.max(x) - np.min(x)                        #width of interval
    ell = len(x)                                        #length of vector x
    
    x = ( x - z ) / width     #shift to zero and scale by width of interval
    
    #Make the least-squares polynomial matrix:
    if np.shape(P) != ( ell, polyDegree+1 )  :
        P = np.zeros(( ell, polyDegree+1 ))
    for j in range(polyDegree+1) :
        P[:,j] = x**j
    
    #Make the full polyharmonic spline plus polynomial matrix:
    if np.shape(A) != ( ell+polyDegree+1, ell+polyDegree+1 ) :
        A = np.zeros(( ell+polyDegree+1, ell+polyDegree+1 ))
    xx,yy = np.meshgrid( x, x )
    A[ 0:ell, 0:ell ] = np.abs(xx-yy) ** phsDegree
    A[ 0:ell, ell: ] = P
    A[ ell:, 0:ell ] = P.T
    
    #Initialize vector b if necessary:
    if np.shape(b) != ( ell+polyDegree+1, ) :
        b = np.zeros(( ell+polyDegree+1 ))
    
    #First ell elements of the vector b contain the derivative of each RBF
    #basis function evaluated at 0:
    if ( ell >= polyDegree+1 ) & ( phsDegree >= m+1 ) :
        if np.mod(m,2) == 0 :
            b[0:ell] \
            = np.prod( np.arange( phsDegree-(m-1), phsDegree+1 ) ) \
            * np.abs(0.-x) ** (phsDegree-m)
        else :
            b[0:ell] \
            = np.prod( np.arange( phsDegree-(m-1), phsDegree+1 ) ) \
            * (0.-x) ** (phsDegree-m) * np.sign(0.-x)
    else :
        raise ValueError( "Bad parameters.  Choose values such that \
        len(x)>=polyDegree+1 and phsDegree>=m+1." )
    
    #Last elements of the row-vector b contain the derivative of each
    #monomial basis function evaluated at 0 (these derivatives are all zero
    #except maybe one of them):
    if polyDegree >= m :
        b[ell+m] = factorial(m)
    
    w = np.linalg.solve( A, b )        #solve linear system for the weights
    w = w[0:ell]          #remove the weights which will be multiplied by 0
    
    return w / width**m                    #return correctly scaled weights

###########################################################################

def getDM( x=np.arange(-1.,1.2,.2), X=np.arange(-.9,1.1,.2), m=0 \
, phsDegree=5, polyDegree=3, stencilSize=7 ) :
    
    ell = len(X)
    
    ii = np.transpose( np.tile( np.arange(0,ell), (stencilSize,1) ) )
    
    w  = np.zeros(( ell, stencilSize ))
    
    xNew = np.zeros(( len(x), 1 ))
    xNew[:,0] = x
    tree = cKDTree( xNew )
    
    Xnew = np.zeros(( ell, 1 ))
    Xnew[:,0] = X
    
    jj = tree.query( Xnew, stencilSize )
    jj = jj[1]
    
    # jj = tree.query( Xnew, 1 )
    # jj = jj[1]
    # jj = tree.query( xNew[jj,:], stencilSize )
    # jj = jj[1]
    
    #These will be the same size for every stencil, so we initialize them
    #so they can be passed to the getWeights function:
    P = np.zeros(( stencilSize, polyDegree+1 ))
    A = np.zeros(( stencilSize+polyDegree+1, stencilSize+polyDegree+1 ))
    b = np.zeros(( stencilSize+polyDegree+1, ))
    # P = np.array([])
    # A = np.array([])
    # b = np.array([])
    
    for i in range(ell) :
        w[i,:] = getWeights( X[i], x[jj[i,:]], m \
        , phsDegree, polyDegree \
        , P, A, b )
    
    ii = ii.flatten()
    jj = jj.flatten()
    w  = w.flatten()
    
    W = csr_matrix( (w,(ii,jj)), [ell,len(x)] )
    
    return W

###########################################################################

def getPeriodicDM( period=2*np.pi, x='none', X='none', m=1 \
, phsDegree=5, polyDegree=3, stencilSize=7 ) :
    
    pad = np.int(np.round( (stencilSize-1)/2 ))
    
    x = np.hstack(( x[len(x)-pad:len(x)]-period, x, x[0:pad]+period ))
    
    W = getDM( x, X, m, phsDegree, polyDegree, stencilSize )
    
    W = lil_matrix( W )
    
    W[:,pad:2*pad]               = W[:,pad:2*pad]               + W[:,len(x)-pad:len(x)]
    W[:,len(x)-2*pad:len(x)-pad] = W[:,len(x)-2*pad:len(x)-pad] + W[:,0:pad]
    
    W = W[:,pad:len(x)-pad]
    
    W = csr_matrix(W)
    
    return W

###########################################################################
