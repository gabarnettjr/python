import numpy as np
from math import factorial
from scipy.sparse import csr_matrix, lil_matrix
from scipy.spatial import cKDTree

###########################################################################

def getWeights( z=0., x=np.arange(-3.,4.,1.), m=1 \
, phs=5, pol=3 \
, P=np.array([]), A=np.array([]), b=np.array([]) ) :
    
    """
    z (real) is where to approximate the derivative.
    x (real row-vector) is where function values are located.
    m (integer) is the derivative to approximate (0 for interpolation).
    phs (odd integer) is the exponent in the PHS RBF.
    pol is the highest degree polynomial to include in the basis.
    P (zeros) is optional ( len(x), pol+1 )
    A (zeros) is optional ( len(x)+pol+1, len(x)+pol+1 )
    b (zeros) is optional ( len(x)+pol+1, )
    
    The output w is a row-vector such that sum(w*f(x)) approximates the mth
    derivative of f at z.
    
    Successful approximation with polyharmonic spline RBFs and polynomials
    requires that two conditions be met:
        (1) len(x) >= pol+1
        (2) phs >= m+1
    
    Warning: To approximate the mth derivative with accuracy O(dx) on
    irregulary spaced nodes, the length of the vector x must be at least
    m+1.
    """
    
    width = np.max(x) - np.min(x)                        #width of interval
    ell = len(x)                                        #length of vector x
    
    x = (x - z) / width       #shift to zero and scale by width of interval

    #Initialize matrices if necessary:
    if np.shape(P) == (0,) :
        P = np.zeros((ell, pol+1))
        A = np.zeros((ell+pol+1, ell+pol+1))
        b = np.zeros((ell+pol+1))
    
    #Make the polynomial matrix:
    for j in range(pol+1) :
        P[:,j] = x**j
    
    #Make the full polyharmonic spline plus polynomial matrix:
    xx,yy = np.meshgrid(x, x)
    A[0:ell, 0:ell] = np.abs(xx - yy) ** phs
    A[0:ell, ell:] = P
    A[ell:, 0:ell] = P.T
    
    #First ell elements of the vector b contain the derivative of each RBF
    #basis function evaluated at 0:
    if (ell >= pol+1) & (phs >= m+1):
        if np.mod(m,2) == 0:
            b[0:ell] \
            = np.prod(np.arange(phs-(m-1), phs+1)) \
            * np.abs(0.-x) ** (phs-m)
        else:
            b[0:ell] \
            = np.prod(np.arange(phs-(m-1), phs+1)) \
            * (0.-x) ** (phs-m) * np.sign(0.-x)
    else :
        raise ValueError("Bad parameters.  Choose values such that " \
        + "len(x)>=pol+1 and phs>=m+1.")
    
    #Last elements of the row-vector b contain the derivative of each
    #monomial basis function evaluated at 0 (these derivatives are all zero
    #except maybe one of them):
    if pol >= m:
        b[ell+m] = factorial(m)
    
    w = np.linalg.solve(A, b)          #solve linear system for the weights
    w = w[0:ell]          #remove the weights which will be multiplied by 0
    
    return w / width**m                    #return correctly scaled weights

###########################################################################

def getDM(z=np.arange(-.9,1.1,.2), x=np.arange(-1.,1.2,.2), m=0 \
, phs=5, pol=3, stc=7):
    """
    z   : Where you want to approximate the derivative (real 1D array)
    x   : Where the function values are known (real 1D array)
    m   : Derivative to approximate (0,1,2,...)
    phs : Exponent in polyharmonic spline radial function (1,3,5,...)
    pol : Highest degree polynomial included in the basis (0,1,2,...)
    stc : Stencil-size (2,3,4,...)
    """
    ell = len(z)
    
    ii = np.transpose(np.tile(np.arange(0,ell), (stc,1)))
    
    w  = np.zeros((ell, stc))
    
    xNew = np.zeros((len(x), 1))
    xNew[:,0] = x
    tree = cKDTree(xNew)
    
    znew = np.zeros((ell, 1))
    znew[:,0] = z
    
    jj = tree.query(znew, stc)[1]
    
    # jj = tree.query( znew, 1 )
    # jj = jj[1]
    # jj = tree.query( xNew[jj,:], stc )
    # jj = jj[1]
    
    #These will be the same size for every stencil, so we initialize them
    #so they can be passed to the getWeights function:
    P = np.zeros((stc, pol+1))
    A = np.zeros((stc+pol+1, stc+pol+1))
    b = np.zeros((stc+pol+1,))
    # P = np.array([])
    # A = np.array([])
    # b = np.array([])
    
    for i in range(ell) :
        w[i,:] = getWeights(z=z[i], x=x[jj[i,:]], m=m \
        , phs=phs, pol=pol \
        , P=P, A=A, b=b)
    
    ii = ii.flatten()
    jj = jj.flatten()
    w  = w.flatten()
    
    W = csr_matrix((w,(ii,jj)), [ell,len(x)])
    
    return W

###########################################################################

def getPeriodicDM(z=np.linspace(0.,2*np.pi,21)[0:-1] \
, x=np.linspace(0.,2*np.pi,21)[0:-1], m=1 \
, phs=11, pol=5, stc=11, period=2*np.pi) :
    
    pad = np.int(np.round((stc-1) / 2))
    
    x = np.hstack((x[len(x)-pad:] - period, x, x[0:pad] + period))

    ell = len(x)
    
    W = getDM(z=z, x=x, m=m, phs=phs, pol=pol, stc=stc)
    
    W = lil_matrix(W)
    
    W[:,pad:2*pad]         = W[:,pad:2*pad]         + W[:,ell-pad:ell]
    W[:,ell-2*pad:ell-pad] = W[:,ell-2*pad:ell-pad] + W[:,0:pad]
    
    W = W[:,pad:ell-pad]
    
    W = csr_matrix(W)
    
    return W

###########################################################################
