import numpy as np
import math
from scipy.sparse import csr_matrix, lil_matrix
from scipy.spatial import cKDTree

###########################################################################

def getWeights( z=0., x=np.arange(-3.,4.,1.), m=1 \
, phsDegree=5, polyDegree=3 ) :
    
    """
    z (real) is where to approximate the derivative.
    x (real row-vector) is where function values are located.
    m (integer) is the derivative to approximate (0 for interpolation).
    phsDegree (odd integer) is the exponent in the PHS RBF.
    polyDegree is the highest degree polynomial to include in the basis.
    
    The output w is a row-vector such that sum(w*f(x)) approximates the mth
    derivative of f at z.
    
    Warning: To approximate the mth derivative, the length of the vector x
    must be at least m+1.
    
    Successful approximation with polyharmonic spline RBFs and polynomials
    has two additional requirements:
        (1) len(x) >= polyDegree+1
        (2) phsDegree >= m+1
    """
    
    width = np.max(x) - np.min(x)                        #width of interval
    ell = len(x)                                        #length of vector x
    
    x = ( x - z ) / width    #shift to zero and divide by width of interval
    
    P = np.zeros(( ell, polyDegree+1 )) #least squares polynomial matrix
    for j in range(polyDegree+1) :
        P[:,j] = x**j
    
    xx,yy = np.meshgrid( x, x )
    A = np.zeros(( ell+polyDegree+1, ell+polyDegree+1 ))
    A[ 0:ell, 0:ell ] = np.abs(xx-yy)**phsDegree
    A[ 0:ell, ell: ] = P
    A[ ell:, 0:ell ] = P.T
    
    #Row-vector b contains the derivative of each RBF basis function
    #evaluated at 0:
    if ( ell >= polyDegree+1 ) & ( phsDegree >= m+1 ) :
        if np.mod(m,2) == 0 :
            b = np.prod( np.arange( phsDegree-(m-1), phsDegree+1 ) ) \
            * np.abs(0.-x) ** (phsDegree-m)
        else :
            b = np.prod( np.arange( phsDegree-(m-1), phsDegree+1 ) ) \
            * (0.-x) ** (phsDegree-m) * np.sign(0.-x)
    else :
        raise ValueError( "Bad parameters.  Choose values such that \
        len(x)>=polyDegree+1 and phsDegree>=m+1." )
    
    #Row-vector c contains the derivative of each monomial basis function
    #evaluated at 0 (these derivatives are all zero except maybe one):
    c = np.zeros(( polyDegree + 1 ))
    if polyDegree >= m :
        c[m] = math.factorial(m)
    
    b = np.hstack(( b, c ))                     #full vector of derivatives
    w = np.linalg.solve( A, b )        #solve linear system for the weights
    w = w[0:ell]          #remove the weights which will be multiplied by 0
    
    return w / width**m                    #return correctly scaled weights

###########################################################################

def getDM( x=np.arange(-1.,1.2,.2), X=np.arange(-.9,1.1,.2), m=0 \
, phsDegree=5, polyDegree=3, stencilSize=7 ) :
    
    ell = len(X)
    
    ii = np.transpose( np.tile( np.arange(0,ell), (stencilSize,1) ) )
    
    w  = np.zeros(( ell, stencilSize ))
    
    xNew = np.zeros(( len(x), 1 ))
    xNew[:,0] = x
    tree = cKDTree( xNew )
    
    Xnew = np.zeros(( ell, 1 ))
    Xnew[:,0] = X
    
    jj = tree.query( Xnew, stencilSize )
    jj = jj[1]
    
    # jj = tree.query( Xnew, 1 )
    # jj = jj[1]
    # jj = tree.query( xNew[jj,:], stencilSize )
    # jj = jj[1]
    
    for i in range(ell) :
        w[i,:] = getWeights( X[i], x[jj[i,:]], m, phsDegree, polyDegree )
    
    ii = ii.flatten()
    jj = jj.flatten()
    w  = w.flatten()
    
    W = csr_matrix( (w,(ii,jj)), [ell,len(x)] )
    
    return W

###########################################################################

def getPeriodicDM( period=2*np.pi, x='none', X='none', m=1 \
, phsDegree=5, polyDegree=3, stencilSize=7 ) :
    
    pad = np.int(np.round( (stencilSize-1)/2 ))
    
    x = np.hstack(( x[len(x)-pad:len(x)]-period, x, x[0:pad]+period ))
    
    W = getDM( x, X, m, phsDegree, polyDegree, stencilSize )
    
    W = lil_matrix( W )
    
    W[:,pad:2*pad]               = W[:,pad:2*pad]               + W[:,len(x)-pad:len(x)]
    W[:,len(x)-2*pad:len(x)-pad] = W[:,len(x)-2*pad:len(x)-pad] + W[:,0:pad]
    
    W = W[:,pad:len(x)-pad]
    
    W = csr_matrix(W)
    
    return W

###########################################################################
