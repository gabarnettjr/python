
import numpy as np

################################################################################

# Polyharmonic spline radial basis function

def phs(x, y, rbfParam):
    return (x**2 + y**2) ** (rbfParam/2)

################################################################################

# RBF matrix

def rbf(x, y, xc, yc, rbfParam):

    A = np.zeros((len(x), len(xc)), float)
    
    for i in range(len(x)):
        for j in range(len(xc)):
            A[i,j] = phs(x[i] - xc[j], y[i] - yc[j], rbfParam)
            
    return A
    
################################################################################

# Polynomial matrix
    
def poly(x, y, pd):

    p = np.zeros((len(x), int((pd+1)*(pd+2)/2)), float)
    
    if pd >= 0:
        p[:,0] = 1.
    if pd >= 1:
        p[:,1] = x
        p[:,2] = y
    if pd >= 2:
        p[:,3] = x**2
        p[:,4] = x * y
        p[:,5] = y**2
    if pd >= 3:
        p[:,6] = x**3
        p[:,7] = x**2 * y
        p[:,8] = x * y**2
        p[:,9] = y**3
    if pd >= 4:
        p[:,10] = x**4
        p[:,11] = x**3 * y
        p[:,12] = x**2 * y**2
        p[:,13] = x * y**3
        p[:,14] = y**4
    if pd >= 5:
        p[:,15] = x**5
        p[:,16] = x**4 * y
        p[:,17] = x**3 * y**2
        p[:,18] = x**2 * y**3
        p[:,19] = x * y**4
        p[:,20] = y**5
    if pd >= 6:
        p[:,21] = x**6
        p[:,22] = x**5 * y
        p[:,23] = x**4 * y**2
        p[:,24] = x**3 * y**3
        p[:,25] = x**2 * y**4
        p[:,26] = x * y**5
        p[:,27] = y**6
    if (pd < 0) or (pd > 6):
        sys.exit("Please choose a better polynomial degree (0 <= pd <= 6).")
        
    return p

################################################################################

# Index of [x,y] inside the rectangle centered at [xmci,ymci] with width 2*w
# and length 2*ell.

def inSquare(x, y, xmci, ymci, ell, w):

    ind = np.array([], int)
    
    for j in range(len(x)):
        if (np.abs(x[j] - xmci) <= w) and (np.abs(y[j] - ymci) <= ell):
            ind = np.hstack((ind, j))
            
    return ind

################################################################################

# Assuming only a single subdomain, this function assigns default values to the
# variables that do not matter in this case.

def assignDefaults(x, y, xmc, ymc, ell, w, ELL, W):
    
    if len(xmc) == 0:
        xmc = np.array([(np.min(x) + np.max(x)) / 2])
    if len(ymc) == 0:
        ymc = np.array([(np.min(y) + np.max(y)) / 2])
    if not ell:
        ell = (np.max(y) - np.min(y)) / 2
    if not w:
        w = (np.max(x) - np.min(x)) / 2
    if not ELL:
        ELL = 3 * ell
    if not W:
        W = 3 * w
    
    return xmc, ymc, ell, w, ELL, W

################################################################################

# After breaking the large rectangular domain into small rectangular subdomains
# of length 2*ell and width 2*w, go through the subdomains and find a polynomial
# least squares approximation using data in the subdomain and all adjacent
# subdomains.

# pd is the desired polynomial degree.
# (x,y,f) defines the known function values.
# (X,Y) are the points where you WANT to know the function.
# (xmc,ymc) are the centers of the rectangular subdomains.
# ell is half the length of a rectangular subdomain.
# w is half the width of a rectangular subdomain.
# ELL = 3 * ell.
# W = 3 * w.

def polyLS(pd, x, y, f, X, Y \
, xmc = [], ymc = [], ell = [], w = [], ELL = [], W = []):
    
    xmc, ymc, ell, w, ELL, W = assignDefaults(x, y, xmc, ymc, ell, w, ELL, W)
    
    numP = int((pd + 1) * (pd + 2) / 2)
    zp1 = np.zeros((numP, 1))
    zp2 = np.zeros((numP, numP))
    approx = np.zeros(len(X), float)
    
    for i in range(len(xmc)):
        IND = inSquare(x, y, xmc[i], ymc[i], ELL, W)
        p = poly(x[IND], y[IND], pd)
        lam = np.linalg.lstsq(p, f[IND], rcond=None)[0]
        IND = inSquare(X, Y, xmc[i], ymc[i], ell, w)
        B = poly(X[IND], Y[IND], pd)
        approx[IND] = B.dot(lam).flatten()
        
    return approx

################################################################################

# After breaking the large rectangular domain into small rectangular subdomains
# of length 2*ell and width 2*w, go through the subdomains and find a radial
# basis function (plus polynomials) least squares approximation using data in
# the subdomain and all adjacent subdomains.

# rbfParam is the exponent in the polyharmonic spline radial basis function.
# pd is the desired polynomial degree.
# (x,y,f) defines the known function values.
# (X,Y) are the points where you WANT to know the function.
# (xmc,ymc) are the centers of the rectangular subdomains.
# ell is half the length of a rectangular subdomain.
# w is half the width of a rectangular subdomain.
# ELL = 3 * ell.
# W = 3 * w.

def RBFLS(rbfParam, pd, x, y, f, X, Y \
, xmc = [], ymc = [], ell = [], w = [], ELL = [], W = []):
    
    xmc, ymc, ell, w, ELL, W = assignDefaults(x, y, xmc, ymc, ell, w, ELL, W)
    
    approx = np.zeros(len(X), float)
    
    for i in range(len(xmc)):
        IND = inSquare(x, y, xmc[i], ymc[i], ELL, W)
        p = poly(x[IND], y[IND], pd)
        ind = inSquare(x[IND], y[IND], xmc[i], ymc[i], ell, w)
        xc = x[IND][ind]
        yc = y[IND][ind]
        A = rbf(x[IND], y[IND], xc, yc, rbfParam)
        A = np.hstack((A, p))
        lam = np.linalg.lstsq(A, f[IND], rcond=None)[0]
        IND = inSquare(X, Y, xmc[i], ymc[i], ell, w)
        A = rbf(X[IND], Y[IND], xc, yc, rbfParam)
        B = poly(X[IND], Y[IND], pd)
        B = np.hstack((A, B))
        approx[IND] = B.dot(lam).flatten()
        
    return approx

################################################################################

# After breaking the large rectangular domain into small rectangular subdomains
# of length 2*ell and width 2*w, go through the subdomains and find a radial
# basis function (plus polynomials) INTERPOLANT using data in the subdomain and
# all adjacent subdomains.

# rbfParam is the exponent in the polyharmonic spline radial basis function.
# pd is the desired polynomial degree.
# (x,y,f) defines the known function values.
# (X,Y) are the points where you WANT to know the function.
# (xmc,ymc) are the centers of the rectangular subdomains.
# ell is half the length of a rectangular subdomain.
# w is half the width of a rectangular subdomain.
# ELL = 3 * ell.
# W = 3 * w.

def RBFinterp(rbfParam, pd, x, y, f, X, Y \
, xmc = [], ymc = [], ell = [], w = [], ELL = [], W = []):
    
    xmc, ymc, ell, w, ELL, W = assignDefaults(x, y, xmc, ymc, ell, w, ELL, W)
    
    numP = int((pd + 1) * (pd + 2) / 2)
    zp1 = np.zeros((numP, 1))
    zp2 = np.zeros((numP, numP))
    approx = np.zeros(len(X), float)
    
    for i in range(len(xmc)):
        IND = inSquare(x, y, xmc[i], ymc[i], ELL, W)
        p = poly(x[IND], y[IND], pd)
        xc = x[IND]
        yc = y[IND]
        A = rbf(x[IND], y[IND], xc, yc, rbfParam)
        A = np.hstack((A, p))
        tmp = np.hstack(( p.T, zp2))
        A = np.vstack((A, tmp))
        tmp = np.reshape(f[IND], (len(IND), 1))
        lam = np.linalg.solve(A, np.vstack((tmp, zp1)))
        IND = inSquare(X, Y, xmc[i], ymc[i], ell, w)
        A = rbf(X[IND], Y[IND], xc, yc, rbfParam)
        B = poly(X[IND], Y[IND], pd)
        B = np.hstack((A, B))
        approx[IND] = B.dot(lam).flatten()
        
    return approx

################################################################################
